/******************************************************************************/
/*                                                                            */
/* radio module communication support routines                                */
/*                                                                            */
/* Author: F. Wornle (FW-mn-yr)                                               */
/* Latest change: fw-05-08                                                    */
/*                                                                            */
/******************************************************************************/

/* Model dependent constants -- generated by 'gen_mc_defines_h.m' */
#include "mc_defines.h"
#include "mc_signal.h"          /* abort_LED, etc.                          */


/* include radio module support ? */
#if HAS_RFCOMMS > 0


#include "bsp_includes.h"

/* radio communication modules */
#include "mc_radioComms.h"            /* global RF communication admin variables */
#include "mc_radioClient.h"           /* RF client */
#include "mc_radioServer.h"           /* RF server */


/* channel index pointer */
static tINT16S              currentRFchannel= -1; 



/* === CLIENT BLOCKS === */


/* only include this function if the model includes RFcomm 'client' blocks */
/* HAS_RFCOMMS:  '0' : no RF communications, '1' : server, '2' : client, '3' : 'both' */
#if ((HAS_RFCOMMS == 2) | (HAS_RFCOMMS == 3))


/* Function: process_RadioCommData_client ====================================================
 * Abstract:
 *  Attempts to read a telegram from the ring buffer of the radio module. If one is 
 *  found, it is copied to the appropriate buffer.
 *  This function simply returns if there are less than 4 bytes in the reception 
 *  buffer, otherwise it BLOCKS until the entire telegram has been received.
 */
tVOID process_RadioCommData_client(tINT16U raw_data, tINT8U client) {

   tINT8U            myBuf[4];
   tINT16U            i;

   static myUsrBuf   *admin;        /* static, coz they may get used in subsequent calls to this function */
   static tINT16U   size;          /* static, coz they may get used in subsequent calls to this function */
   static tINT8U    *buf;          /* static, coz they may get used in subsequent calls to this function */


   /* check if we're dealing with formatted data or not (raw_data == 1) */
   if(raw_data) {

      currentRFchannel=0;   /* using channel '0' for raw data transmissions */
      admin=radiocomTelBuf[5*client+currentRFchannel];
      size=(tINT16U)admin->buf_size;
      buf=admin->buf;

   }

   /* beginning of telegram -- only relevant when receiving formatted data telegrams */
   if(currentRFchannel==-1) {

      /* no header has previously been received -> try to fetch it */
      if(RadioClient_HasElements()>=4) {

         /* read first 4 bytes from the RF input buffer */
         for(i=0; i<4; i++) {

            /* fetch value from RF input buffer */
            myBuf[i]=RadioClient_InChar();

         }

         currentRFchannel=myBuf[1];
         admin=radiocomTelBuf[5*client+currentRFchannel];
         size=(tINT16U)admin->buf_size;
         buf=admin->buf;

      } /* header available */

   } /* currentRFchannel == -1 */


   /* remainder of telegram */
   if(currentRFchannel!=-1) {

      /* a header has previously been received -> try to fetch remainder*/

      /* read remainder of the telegram (if available) */
      if(RadioClient_HasElements()>=size) {

         /* at this stage, the entire remainder of the telegram is in the ring buffer */

         /* read remaining bytes from the ring buffer */
         for(i=0; i<size; i++) {

            /* fetch value from RF input buffer */
            buf[i]=RadioClient_InChar();

         }

         /* indicate receipt of a telegram */
         admin->buffer_full=1;

         /* reset global variable 'currentFPchannel' */
         currentRFchannel= -1;

      } /* remainder in buffer */

   } /* currentRFchannel != -1 */

} /* End of process_RadioCommData_client */



/* Function: put_RFdata_client =======================================================
 * Abstract:
 *  Sends nbyte through the RF module
 */
tVOID put_RFdata_client(tINT8U channel, tINT8U size, tINT8U dtype, tINT8U *src, tINT8U raw_data) {

   tINT16U   i;
   tINT8U  myBuf[4];


   /* check if we need to send a header at all... (formatted telegrams) */
   if(!raw_data) {

      /* yes -> assemble header (size, channel, data_type_len, '0') */
      myBuf[0]=(tINT8U)(size+4);
      myBuf[1]=channel;
      myBuf[2]=dtype;
      myBuf[3]=0;

      /* send header */
      for(i=0; i<4; i++) {

         /* ensure that RF transmission buffer is not full */
         while(RadioClient_IsOutFull()) {

            blinky(1000);

         }

         /* write output data to output buffer */
         RadioClient_OutChar(myBuf[i]);

      }

   } /* raw_data == 0 */

   /* send remainder of the telegram (data) */
   for(i=0; i<size; i++) {

      /* ensure that RF transmission buffer is not full */
      while(RadioClient_IsOutFull()) {

         blinky(1000);

      }

      /* write output data to output buffer */
      RadioClient_OutChar(src[i]);

   }

}  /* end of put_RFdata_client */


#endif /* HAS_RFCOMMS == 2 (client) */




/* === SERVER BLOCKS === */


/* only include this function if the model includes RFcomm 'server' blocks */
/* HAS_RFCOMMS:  '0' : no RF communications, '1' : server, '2' : client, '3' : 'both' */
#if ((HAS_RFCOMMS == 1) | (HAS_RFCOMMS == 3))

/* Function: process_RadioCommData_server ====================================================
 * Abstract:
 *  Attempts to read a telegram from the ring buffer of the radio module. If one is 
 *  found, it is copied to the appropriate buffer.
 *  This function simply returns if there are less than 4 bytes in the reception 
 *  buffer, otherwise it BLOCKS until the entire telegram has been received.
 */
tVOID process_RadioCommData_server(tINT16U raw_data, tINT8U client) {

   tINT8U            myBuf[4];
   tINT16U            i;

   static myUsrBuf   *admin;        /* static, coz they may get used in subsequent calls to this function */
   static tINT16U   size;          /* static, coz they may get used in subsequent calls to this function */
   static tINT8U    *buf;          /* static, coz they may get used in subsequent calls to this function */


   /* check if we're dealing with formatted data or not (raw_data == 1) */
   if(raw_data) {

      currentRFchannel=0;   /* using channel '0' for raw data transmissions */
      admin=radiocomTelBuf[5*client+currentRFchannel];
      size=(tINT16U)admin->buf_size;
      buf=admin->buf;

   }

   /* beginning of telegram -- only relevant when receiving formatted data telegrams */
   if(currentRFchannel==-1) {

      /* no header has previously been received -> try to fetch it */
      if(RadioServer_HasElements(client)>=4) {

         /* read first 4 bytes from the RF input buffer */
         for(i=0; i<4; i++) {

            /* fetch value from RF input buffer */
            myBuf[i]=RadioServer_InChar(client);

         }

         currentRFchannel=myBuf[1];
         admin=radiocomTelBuf[5*client+currentRFchannel];
         size=(tINT16U)admin->buf_size;
         buf=admin->buf;

      } /* header available */

   } /* currentRFchannel == -1 */


   /* remainder of telegram */
   if(currentRFchannel!=-1) {

      /* a header has previously been received -> try to fetch remainder */

      /* read remainder of the telegram (if available) */
      if(RadioServer_HasElements(client)>=size) {

         /* at this stage, the entire remainder of the telegram is in the ring buffer */

         /* read remaining bytes from the ring buffer */
         for(i=0; i<size; i++) {

            /* fetch value from RF input buffer */
            buf[i]=RadioServer_InChar(client);

         }

         /* indicate receipt of a telegram */
         admin->buffer_full=1;

         /* reset global variable 'currentFPchannel' */
         currentRFchannel= -1;

      } /* remainder in buffer */

   } /* currentRFchannel != -1 */

} /* End of process_RadioCommData_server */



/* Function: put_RFdata_server =======================================================
 * Abstract:
 *  Sends nbyte through the RF module
 */
tVOID put_RFdata_server(tINT8U channel, tINT8U size, tINT8U dtype, tINT8U *src, tINT8U raw_data, tINT8U  client) {

   tINT16U   i;
   tINT8U  myBuf[4];


   /* check if we need to send a header at all... (formatted telegrams) */
   if(!raw_data) {

      /* yes -> assemble header (size, channel, data_type_len, '0') */
      myBuf[0]=(tINT8U)(size+4);
      myBuf[1]=channel;
      myBuf[2]=dtype;
      myBuf[3]=0;

      /* send header */
      for(i=0; i<4; i++) {

         /* ensure that RF transmission buffer is not full */
         while(RadioServer_IsOutFull(client)) {

            blinky(1000);

         }

         /* write output data to output buffer */
         RadioServer_OutChar(client, myBuf[i]);

      }

   } /* raw_data == 0 */

   /* send remainder of the telegram (data) */
   for(i=0; i<size; i++) {

      /* ensure that RF transmission buffer is not full */
      while(RadioServer_IsOutFull(client)) {

         blinky(1000);

      }

      /* write output data to output buffer */
      RadioServer_OutChar(client, src[i]);

   }

}  /* end of put_RFdata_server */


#endif /* HAS_RFCOMMS == 1 (server) */


#endif /* HAS_RFCOMMS > 0 */
