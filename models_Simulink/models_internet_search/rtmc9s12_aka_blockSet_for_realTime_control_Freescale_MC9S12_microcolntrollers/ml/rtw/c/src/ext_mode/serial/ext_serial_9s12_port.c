/*
 * Copyright 2010 F. Wörnle
 *
 * File: ext_serial_9s12_port.c     $Revision.1 $
 *
 * Abstract:
 *  The External Mode Serial Port is a logical object providing a standard
 *  interface between the external mode code and the physical serial port.
 *  The prototypes in the 'Visible Functions' section of this file provide
 *  the consistent front-end interface to external mode code.  The
 *  implementations of these functions provide the back-end interface to the
 *  physical serial port.  This layer of abstraction allows for minimal
 *  modifications to external mode code when the physical serial port is
 *  changed.
 *
 *     ----------------------------------
 *     | Host/Target external mode code |
 *     ----------------------------------
 *                   / \
 *                  /| |\
 *                   | |
 *                   | |
 *                  \| |/
 *                   \ /  Provides a standard, consistent interface to extmode
 *     ----------------------------------
 *     | External Mode Serial Port      |
 *     ----------------------------------
 *                   / \  Function definitions specific to physical serial port
 *                  /| |\
 *                   | |
 *                   | |
 *                  \| |/
 *                   \ /
 *     ----------------------------------
 *     | HW/OS/Physical serial port     |
 *     ----------------------------------
 *
 *  See also ext_serial_pkt.c.
 *
 * 
 * Adapted for rtmc9s12-Target, fw-04-10
 */




/*
 *********************************************************************************************************
 *    INCLUDES
 *********************************************************************************************************
 */

#include <string.h>

#include "tmwtypes.h"

#include "ext_types.h"
#include "ext_share.h"
#include "ext_serial_port.h"
#include "ext_serial_pkt.h"

/* Model dependent constants -- generated by 'gen_mc_defines_h.m' */
#include "mc_defines.h"

#include "mc_signal.h"
#include "bsp_sci.h"              /* SCI0_Init, SCI1_Init */
#include "mc_debugMsgs.h"         /* macros PRINT_DEBUG_MSG_LVL1 to PRINT_DEBUG_MSG_LVL5,  fw-06-07 */



/*
 *********************************************************************************************************
 *    DEFINES
 *********************************************************************************************************
 */

/* ExtSerialPortDataPending... need at least 9 bytes to consider buffer contents a packet  --  fw-07-07 */
#define MIN_PACKET_SIZE  9    /* smallest packet size: ACK_PACKET (9) */
//#define MIN_PACKET_SIZE  1      /* safe assumption */



/*
 *********************************************************************************************************
 *    LOCAL FUNCTIONS
 *********************************************************************************************************
 */

#ifdef ERASE

/* Function: serial_get_string =================================================
 * Abstract:
 *  Attempts to get the specified number of bytes from the reception ring buffer. 
 *  The number of bytes read is returned via the 'nBytesGot' parameter. If the
 *  specified number of bytes is not read within the time out period specified
 *  by macro BSP_SCI{0,1}_TIMEOUT_MAX_SEC, an error is returned.
 *
 *  EXT_NO_ERROR is returned on success, EXT_ERROR on failure.
 *
 */
PRIVATE boolean_T serial_get_string(char_T    *dst,
                                    uint16_T   nBytesToGet, 
                                    uint32_T  *nBytesGot) {

boolean_T    error   = EXT_NO_ERROR;


    // local function name... debugging only
    DEFINE_DEBUG_FNAME("serial_get_string")

    PRINT_DEBUG_MSG_LVL5("IN");
    PRINT_DEBUG_MSG_NL5;

    /* attempt to receive the required number of bytes */
    #if SCI0_COMMS == MCOM
    
        /* External Mode through SCI0 */
        error = SCI0_InString(dst, nBytesToGet);

    #else

        /* External Mode through SCI1 */
        error = SCI1_InString(dst, nBytesToGet);

    #endif

    if (error != EXT_NO_ERROR) {

            /* couldn't retrieve the requested number of bytes */
            *nBytesGot = 0L;
            
            goto EXIT_POINT;

    }
    
    /* success -> return actual number of bytes */
    *nBytesGot = (uint32_T)nBytesToGet;


EXIT_POINT:

    PRINT_DEBUG_MSG_LVL5("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL5_UDec(error);
    PRINT_DEBUG_MSG_NL5;

    return error;

} /* end serial_get_string */

#endif  /* ERASE */


/* Function: serial_set_string =================================================
 * Abstract:
 *  Sets (sends) the specified number of bytes on SCI0 (or SCI1). The number of
 *  bytes sent is returned via the 'bytesWritten' parameter.
 *
 */
PRIVATE boolean_T serial_set_string(uint8_T    *src,
                                    uint32_T    size, 
                                    uint32_T   *bytesWritten) {

boolean_T    error   = EXT_NO_ERROR;
uint_T       i;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("serial_set_string")

    PRINT_DEBUG_MSG_LVL5("IN");
    PRINT_DEBUG_MSG_NL5;

    PRINT_DEBUG_MSG_LVL5("Number of bytes to be sent: ");
    PRINT_DEBUG_MSG_LVL5_UDec((uint16_T)size);
    PRINT_DEBUG_MSG_NL5;

    /* send string byte by byte */
    for (i = 0; i < size; i++) {

        /* make sure we're using the right port... */
        #if SCI0_COMMS == MCOM
        
            /* External Mode through SCI0 */
            error = (SCI0_OutChar(src[i]) == 0 ? EXT_NO_ERROR : EXT_ERROR);

        #else

            /* External Mode through SCI1 */
            error = (SCI1_OutChar(src[i]) == 0 ? EXT_NO_ERROR : EXT_ERROR);

        #endif
        
        if (error != EXT_NO_ERROR) {

                /* couldn't send the specified number of bytes */
                goto EXIT_POINT;

        }

        PRINT_DEBUG_MSG_LVL2("Sending  ");
        PRINT_DEBUG_MSG_LVL2_UHex(src[i]);
        PRINT_DEBUG_MSG_NL2;
    }


EXIT_POINT:

    /* actual number of bytes written to the RB / sent */
    *bytesWritten = (uint32_T)i;

    PRINT_DEBUG_MSG_LVL5("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL5_UDec(error);
    PRINT_DEBUG_MSG_NL5;

    return error;

} /* end serial_set_string */


/* Function: SCIx_init ===========================================================
 * Abstract:
 *  Called by ExtInit
 *
 * NOTES:
 *  o This function always returns 'EXT_NO_ERROR'
 */
PRIVATE boolean_T SCIx_init(uint16_T port, uint8_T baud) {

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("SCIx_init")

    PRINT_DEBUG_MSG_LVL2("IN, MATLAB communication port: SCI");
    PRINT_DEBUG_MSG_LVL2_UDec(port - 1);
    PRINT_DEBUG_MSG_NL2;

    /* make sure we're using the right port... */
    if (port == 1) {

        #if TARGET_BOARD != BSP_DRAGONFLY12C32
        SCI1_Init(baud);
        #endif

        /* promote SCI1 interrupt REQUESTS to hightest priority */
        HPRIO = 0xD4;         /* 0xFFD4 -> SCI1 interrupt = highest priority */

    } else {

        SCI0_Init(baud);

        /* promote SCI0 interrupt REQUESTS to hightest priority */
        HPRIO = 0xD2;         /* 0xFFD2 -> SCI0 interrupt = highest priority */

    }

    PRINT_DEBUG_MSG_LVL2("OUT, error status: EXT_NO_ERROR");
    PRINT_DEBUG_MSG_NL2;

    /* return error flag */
    return EXT_NO_ERROR;

} /* end SCIx_init */





/*
 *********************************************************************************************************
 *    PUBLIC FUNCTIONS
 *********************************************************************************************************
 */

/* Function: ExtSerialPortMoveRBTail ================================================
 * Abstract:
 *  Set the RB reception ring buffer tail to 'tailOffset'; used to remove erroneous packets
 *  from the reception buffer
 */
PUBLIC void ExtSerialPortMoveRBTail(uint16_T tailOffset) {

    #if SCI0_COMMS == MCOM
    
        /* External Mode through SCI0 */
        SCI0_InBufferMoveTail(tailOffset);

    #else

        /* External Mode through SCI1 */
        SCI1_InBufferMoveTail(tailOffset);

    #endif

} /* end ExtSerialPortMoveRBTail */


#if DEBUG_MSG_LVL > 0
/* Function: ExtSerialPortPeekRB ===========================================
 * Abstract:
 *  Displays the last 'n' bytes on the RB reception buffer without removing them...
 */
PUBLIC void ExtSerialPortPeekRB(uint16_T nBytesToDisplay) {

uint16_T    i, nBytesAvailable;
uint8_T     currChar;

uint_T      tailOffset;          /* uint_T == tINT16U */


    /* determine number of bytes available on the chosen external mode buffer */
    #if SCI0_COMMS == MCOM
    
        /* External Mode through SCI0 */
        nBytesAvailable = SCI0_InStatus();

    #else

        /* External Mode through SCI1 */
        nBytesAvailable = SCI1_InStatus();

    #endif

    /* display either the requested number of bytes, or whatever portion thereof is available... */
    nBytesAvailable = (nBytesAvailable > nBytesToDisplay) ? nBytesToDisplay : nBytesAvailable;

    /* begin to read from the current tail position */
    tailOffset = 0;
    
    /* fetch values one by one */
    for (i = 0; i < nBytesAvailable; i++) {

        #if SCI0_COMMS == MCOM
        
            /* External Mode through SCI0 */
            SCI0_InBufferPeek(&currChar, &tailOffset);

        #else

            /* External Mode through SCI1 */
            SCI1_InBufferPeek(&currChar, &tailOffset);

        #endif

        PRINT_DEBUG_MSG_LVL1_Raw(" ");
        PRINT_DEBUG_MSG_LVL1_UHex((uint16_T)currChar);
      
    }

} /* end ExtSerialPortPeekRB */
#endif


/* Function: ExtSerialPortCreate ===============================================
 * Abstract:
 *  Creates an External Mode Serial Port object.  The External Mode Serial Port
 *  is an abstraction of the physical serial port providing a standard
 *  interface for external mode code.  A pointer to the created object is
 *  returned.
 *
 */
PUBLIC ExtSerialPort *ExtSerialPortCreate(void) {

static ExtSerialPort         serialPort;
       ExtSerialPort        *portDev        = &serialPort;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ExtSerialPortCreate")

    PRINT_DEBUG_MSG_LVL2("IN");
    PRINT_DEBUG_MSG_NL2;

    /* Determine and save endianness */
    {

        union Char2Integer_tag {

            int16_T   IntegerMember;
            char_T    CharMember[sizeof(int16_T)];

        } temp;

        /* set integer */
        temp.IntegerMember = 1;
        
        /* check first byte */
        if(temp.CharMember[0] != 1) {

            /* big endian: 00:01 */
            portDev->isLittleEndian = false;

        } else {

            /* little endian: 01:00 */
            portDev->isLittleEndian = true;

        }

    }

    /* port just created -> not connected yet */
    portDev->fConnected = false;
    
    //PRINT_DEBUG_MSG_LVL1("portDev->fConnected = FALSE");
    //PRINT_DEBUG_MSG_NL1;

    PRINT_DEBUG_MSG_LVL2("OUT");
    PRINT_DEBUG_MSG_NL2;

    return portDev;

} /* end ExtSerialPortCreate */


/* Function: ExtSerialPortConnect ==============================================
 * Abstract:
 *  Performs a logical connection between the external mode code and the
 *  External Mode Serial Port object and a real connection between the External
 *  Mode Serial Port object and the physical serial port.
 *
 *  EXT_NO_ERROR is returned on success, EXT_ERROR on failure.
 */
PUBLIC boolean_T ExtSerialPortConnect(ExtSerialPort *portDev,
                                      uint16_T       port,
                                      uint32_T       baudRate) {

boolean_T   error = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ExtSerialPortConnect")

    PRINT_DEBUG_MSG_LVL2("IN");
    PRINT_DEBUG_MSG_NL2;

    /* trying to connect again, while already being connected? */
    if (portDev->fConnected) {

        /* yep -> mistake */
        
        //abort_LED(3);
        error = EXT_ERROR;
        
        goto EXIT_POINT;

    }

    /* set status to 'connected' */
    portDev->fConnected = true;
    
    //PRINT_DEBUG_MSG_LVL1("portDev->fConnected = TRUE");
    //PRINT_DEBUG_MSG_NL1;

    /* open port (SCI0 / SCI1) */
    error = SCIx_init(port, (uint8_T)baudRate);
    
    if (error != EXT_NO_ERROR) {

        /* couldn't connect -> reset 'fConnected' */
        portDev->fConnected = false;
        
        //PRINT_DEBUG_MSG_LVL1("portDev->fConnected = FALSE");
        //PRINT_DEBUG_MSG_NL1;

        //abort_LED(4);
        error = EXT_ERROR;

        goto EXIT_POINT;

    }


EXIT_POINT:
    
    PRINT_DEBUG_MSG_LVL2("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL2_UDec(error);
    PRINT_DEBUG_MSG_NL2;

    return error;

} /* end ExtSerialPortConnect */


/* Function: ExtSerialPortDisconnect ===========================================
 * Abstract:
 *  Performs a logical disconnection between the external mode code and the
 *  External Mode Serial Port object and a real disconnection between the
 *  External Mode Serial Port object and the physical serial port.
 *
 *  EXT_NO_ERROR is returned on success, EXT_ERROR on failure.
 */
PUBLIC boolean_T ExtSerialPortDisconnect(ExtSerialPort *portDev) {

boolean_T   error = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ExtSerialPortDisconnect")

    PRINT_DEBUG_MSG_LVL2("IN");
    PRINT_DEBUG_MSG_NL2;

    /* trying to disconnect without being connected? */
    if (!portDev->fConnected) {
    
        /* yep -> mistake */

        //abort_LED(5);
        error=EXT_ERROR;

        goto EXIT_POINT;

    }

    /* set status to 'disconnected' */
    portDev->fConnected = false;
    
    //PRINT_DEBUG_MSG_LVL1("portDev->fConnected = FALSE");
    //PRINT_DEBUG_MSG_NL1;


EXIT_POINT:

    PRINT_DEBUG_MSG_LVL2("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL2_UDec(error);
    PRINT_DEBUG_MSG_NL2;

    return error;

} /* end ExtSerialPortDisconnect */


/* Function: ExtSerialPortSetData ==============================================
 * Abstract:
 *  Sets (sends) the specified number of bytes on the comm line.  The number of
 *  bytes sent is returned via the 'bytesWritten' parameter.
 *
 *  EXT_NO_ERROR is returned on success, EXT_ERROR on failure.
 */
PUBLIC boolean_T ExtSerialPortSetData(ExtSerialPort *portDev,
                                      uint8_T       *data,
                                      uint32_T       size,
                                      uint32_T      *bytesWritten) {

    /* are we connected at all? */
    if (!portDev->fConnected) {

        /* nope -> mistake */
        return EXT_ERROR;

    } else {

        /* connected -> write data to RB */
        return serial_set_string(data, size, bytesWritten);
        
    }

} /* end ExtSerialPortSetData */


/* Function: ExtSerialPortDataPending ==========================================
 * Abstract:
 *  Returns, via the 'bytesPending' arg, the number of bytes pending on the
 *  comm line: returns 'bytesPending = 1' if a full packet is available, 
 *  'bytesPending = 0' if no valid packet is available and '-1' if a target 
 *  timeout condition has been detected.
 *
 *  EXT_NO_ERROR is returned on success, EXT_ERROR on failure.
 */
PUBLIC boolean_T ExtSerialPortDataPending(ExtSerialPort *portDev,
                                          int32_T       *bytesPending) {

boolean_T  error      = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ExtSerialPortDataPending")

    /* are we connected at all? */
    if (!portDev->fConnected) {

        /* nope -> mistake */
        error = EXT_ERROR;

    } else {

        /* connected */
        //PRINT_DEBUG_MSG_LVL5("IN");
        //PRINT_DEBUG_MSG_NL5;

        /* determine the number of elements in the RB */
        #if SCI0_COMMS == MCOM
        
            /* External Mode through SCI0 */
            *bytesPending = (int32_T)SCI0_InStatus();

        #else

            /* External Mode through SCI1 */
            *bytesPending = (int32_T)SCI1_InStatus();

        #endif

    }  /* connected */


    //PRINT_DEBUG_MSG_LVL5("OUT, error status: ");
    //PRINT_DEBUG_MSG_LVL5_UDec(error);
    //PRINT_DEBUG_MSG_NL5;

    return error;
    
} /* end ExtSerialPortDataPending */


/* Function: ExtSerialPortGetRawChar ===========================================
 * Abstract:
 *  Attempts to get one byte from the comm line.  The number of bytes read is
 *  returned via the 'bytesRead' parameter.
 *
 *  EXT_NO_ERROR is returned on success, EXT_ERROR on failure.
 */
PUBLIC boolean_T ExtSerialPortGetRawChar(ExtSerialPort *portDev,
                                         uint8_T       *c,
                                         uint32_T      *bytesRead) {

boolean_T  error      = EXT_NO_ERROR;
int16_T    bTimeout;


    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ExtSerialPortGetRawChar")

    //PRINT_DEBUG_MSG_LVL5("IN");
    //PRINT_DEBUG_MSG_NL5;

    /* are we connected at all? */
    if (!portDev->fConnected) {

        /* nope -> mistake */
        error = EXT_ERROR;

    } else {

        /* connected -> read one byte from input (register or RB) */
        #if SCI0_COMMS == MCOM
        
            /* External Mode through SCI0 */
            bTimeout = SCI0_InChar(c);

        #else

            /* External Mode through SCI1 */
            bTimeout = SCI1_InChar(c);

        #endif
        
        /* timeout ? */
        if (bTimeout == -1) {
            
            /* yes -> return EXT_ERROR */
            error = EXT_ERROR;

        } else {
            
            /* no timeout -> success */
            *bytesRead = 1L;
            
        }

    }


    //PRINT_DEBUG_MSG_LVL5("OUT, error status: ");
    //PRINT_DEBUG_MSG_LVL5_UDec(error);
    //PRINT_DEBUG_MSG_NL5;

    return error;
    
} /* end ExtSerialPortGetRawChar */


/* Function: ExtSerialPortPeekRawChar ===========================================
 * Abstract:
 *  Peeks at next byte from the comm line / ring buffer. The read position is 
 *  determined by 'myTailOffset'. Setting 'myTailOffset' to '0' will result in 
 *  reading from the current tail position of the ring buffer. Variable 'myTailOffset'
 *  is increased by one with every call to this function.
 *
 *  EXT_NO_ERROR is returned on success, EXT_ERROR on failure.
 */
PUBLIC boolean_T ExtSerialPortPeekRawChar(ExtSerialPort *portDev,
                                          uint8_T       *c,
                                          uint_T        *myTailOffset) {

boolean_T  error      = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ExtSerialPortPeekRawChar")

    //PRINT_DEBUG_MSG_LVL5("IN");
    //PRINT_DEBUG_MSG_NL5;

    /* are we connected at all? */
    if (!portDev->fConnected) {

        /* nope -> mistake */
        error = EXT_ERROR;

    } else {

        /* connected -> check one byte from input (register or RB) */
        #if SCI0_COMMS == MCOM
        
            /* get a copy of the next character on the ring buffer */
            SCI0_InBufferPeek(c, myTailOffset);
            
        #else

            /* get a copy of the next character on the ring buffer */
            SCI1_InBufferPeek(c, myTailOffset);
            
        #endif

    }


    //PRINT_DEBUG_MSG_LVL5("OUT, error status: ");
    //PRINT_DEBUG_MSG_LVL5_UDec(error);
    //PRINT_DEBUG_MSG_NL5;

    return error;
    
} /* end ExtSerialPortPeekRawChar */


/* [EOF] ext_serial_9S12_port.c */
