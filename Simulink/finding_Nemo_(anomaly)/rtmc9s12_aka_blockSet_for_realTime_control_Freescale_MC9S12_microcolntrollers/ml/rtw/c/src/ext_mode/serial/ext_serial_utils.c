/*
 * Copyright 1994-2008 The MathWorks, Inc.
 *
 * File: ext_serial_utils.c     $Revision: 1.1.6.5 $
 *
 * Absract:
 *  External mode shared data structures and functions used by the external
 *  communication, mex link, and generated code.  This file is for definitions
 *  related to custom external mode implementations (e.g., tcpip, serial).
 *  See ext_share.h for definitions common to all implementations of external
 *  mode (ext_share.h should NOT be modified).
 *
 *
 *   Adapted for rtmc9s12-Target, fw-12-09
 */


/***************** TRANSPORT-DEPENDENT DEFS AND INCLUDES **********************/

#include <stdlib.h>
#include <string.h>

#include "tmwtypes.h"
#include "ext_share.h"
#include "simstruc_types.h"
#include "ext_svr.h"
#include "ext_serial_port.h"
#include "ext_serial_pkt.h"


/* this file is used by both host and target... */
#ifndef rtmc9s12_HOST

/* TARGET ONLY ------------------- */

/* Model dependent constants -- generated by 'gen_mc_defines_h.m' */
#include "mc_defines.h"

#include "mc_signal.h"                /* blinky */
#include "mc_debugMsgs.h"             /* macros PRINT_DEBUG_MSG_LVL1 to PRINT_DEBUG_MSG_LVL1,  fw-06-07 */

#ifdef HOSTALIVECHECK
/* flag is reset to TRUE with every properly received ACK_PACKET;
 * flag is set to FALSE when the target buffer is full (-> most likely cause: host inactive)
 * used to control the writing of new data into the circBuf
 *
 * fw-07-07
 */

/* stop buffering data when the target buffer is full and the host seems busy */
extern boolean_T   HostIsAlive;     /* defined in mc_main.c */
#endif  /* HOSTALIVECHECK */


#else  /* rtmc9s12_HOST */


/* HOST ONLY --------------------- */

#include "debugMsgs_host.h"          /* macros PRINT_DEBUG_MSG_LVL1 to PRINT_DEBUG_MSG_LVL1,  fw - 06 - 07 */


#define abort_LED(err)    /* nothing */

/* FIFOHOSTFACTOR should be > 2 (the larger, the more stable the host after long blockages of Simulink (e.g. menu open)
 * The memory needed on the host is: FIFOBUFNUM * FIFOBUFSIZE = CIRCBUFSIZE * FIFOHOSTFACTOR... at least: 2000 * FIFOHOSTFACTOR
 * An insanely high factor of '50' thus leads to a memory requirement of 2k * 50 = 100 kByte, nothing on a PC. With a factor '50'
 * a DP9S12 based target with a target buffer size of 2k target should survive a host blockage of approx. 10 minutes... 
 * ... in theory :)  
 *
 * fw-07-07
 */
#define FIFOHOSTFACTOR    50

#define FIFOBUFNUM   CIRCBUFSIZE/FIFOBUFSIZE * FIFOHOSTFACTOR
//#define FIFOBUFNUM   2

/* used here to activate/deactivate the deadlock emergency control (ExtSetPkt)   --   fw-07-07 */
/* HostSimStatus is an enum defined in ext_share.h */
extern HostSimStatus  HostStatus;

#endif  /* rtmc9s12_HOST */


/* Display clear text messages of what packet has been sent/received (debug mode only) */
#if DEBUG_MSG_LVL > 0

static const char_T     *debugTelTypeStrings[3]= {
   "Packet type is UNDEFINED_PACKET",
   "Packet type is EXTMODE_PACKET",
   "Packet type is ACK_PACKET"
};

#ifdef MATLAB_MEX_FILE
#define numActionStrings   34
extern const char_T     *debugActionStrings[];  /* defined in ext_svr.c, 34 strings */
#endif  /* MATLAB_MEX_FILE */

// monitor the number of stored packets (queue: FIFOPkt)
static uint_T                numFIFOPkts    = 0;

#endif


/* defined in 'ext_work.c', here only referenced */
extern int_T                 startModel;

/*
 * Buffers used for storing incoming and outgoing packets.
 */
PRIVATE ExtSerialPacket      buffer1st;
PRIVATE ExtSerialPacket      buffer2nd;
PRIVATE ExtSerialPacket     *InBuffer       = &buffer1st;
PRIVATE ExtSerialPacket     *OutBuffer      = &buffer2nd;

/*
 * If waitForAck is true, a packet can not be sent until the other side sends
 * an ack indicating there is space to store the unsent packet.
 */
PRIVATE boolean_T            waitForAck     = false;


/* needed for host sided communication module... fw-06-07 */
#ifdef MATLAB_MEX_FILE
/*
 * NOTE:  When adding or removing a valid baud rate, both the baudRates and
 *        baudRatesStr variables must be modified!
 */
PRIVATE const uint32_T  baudRates[]= {
    1200,
    2400,
    4800,
    9600,
    14400,
    19200,
    38400,
    56000,
    57600,
    115200
};
PRIVATE const char_T    *baudRatesStr = "baud rate must be one of the following:\n"
"\t1200, 2400, 4800, 9600, 14400,\n"
"\t19200, 38400, 56000, 57600, 115200\n";
#endif

/*
 * The maximum number of bytes a serial packet may contain.  Serial pkts
 * larger than the maximum size will be broken up into multiple pkts
 * (each equal to or less than the max size) for transmission.
 */
#define MAX_SERIAL_PKT_SIZE                   FIFOBUFSIZE

/*
* The maximum number of (maximum sized) packets that can be stored at
* any one time.
*/
#define NUM_FIFO_BUFFERS                      FIFOBUFNUM


typedef struct FIFOBuffer_tag {

    char_T                   pktBuf[MAX_SERIAL_PKT_SIZE];
    uint32_T                 size;
    uint32_T                 offset;
    struct FIFOBuffer_tag   *next;

} FIFOBuffer;

PRIVATE FIFOBuffer      *FreeFIFOHead       = NULL;
PRIVATE FIFOBuffer      *FreeFIFOTail       = NULL;
PRIVATE FIFOBuffer      *PktFIFOHead        = NULL;
PRIVATE FIFOBuffer      *PktFIFOTail        = NULL;


PRIVATE boolean_T isFIFOEmpty(FIFOBuffer *head, FIFOBuffer *tail) {

    if ((head == NULL) && (tail == NULL)) {
    
        return true;
        
    }

    return false;
    
}


PRIVATE void InsertFIFO(FIFOBuffer **head, FIFOBuffer **tail, FIFOBuffer *buf) {

    if (isFIFOEmpty(*head, *tail)) {
        *head = *tail = buf;
        buf->next = NULL;
    } else {
        (*tail)->next = buf;
        *tail = buf;
        buf->next = NULL;
    }
}

PRIVATE FIFOBuffer *RemoveFIFO(FIFOBuffer **head, FIFOBuffer **tail) {

    FIFOBuffer *buf = NULL;

    if (isFIFOEmpty(*head, *tail)) {
        return NULL;
    } else {
        buf = *head;
        *head = buf->next;
        if (*head==NULL) {

            *tail = NULL;

        }
        buf->next = NULL;
    }

    return buf;
}

PRIVATE boolean_T isFIFOFreeEmpty(void) {

    return isFIFOEmpty(FreeFIFOHead, FreeFIFOTail);
}

PRIVATE boolean_T isFIFOPktEmpty(void) {

    return isFIFOEmpty(PktFIFOHead, PktFIFOTail);
}

PRIVATE void InsertFIFOFree(FIFOBuffer *buf) {

    InsertFIFO(&FreeFIFOHead, &FreeFIFOTail, buf);
}

PRIVATE FIFOBuffer *RemoveFIFOFree(void) {

    return RemoveFIFO(&FreeFIFOHead, &FreeFIFOTail);
}

PRIVATE void InsertFIFOPkt(FIFOBuffer *buf) {

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("InsertFIFOPkt")

    #if DEBUG_MSG_LVL > 0
    numFIFOPkts++;
    PRINT_DEBUG_MSG_LVL3("Number of stored messages in FIFOPkt: ");
    PRINT_DEBUG_MSG_LVL3_UDec((uint16_T)(numFIFOPkts));
    PRINT_DEBUG_MSG_NL3;
    #endif

    InsertFIFO(&PktFIFOHead, &PktFIFOTail, buf);

}

PRIVATE FIFOBuffer * RemoveFIFOPkt(void) {

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("RemoveFIFOPkt")

    #if DEBUG_MSG_LVL > 0
    PRINT_DEBUG_MSG_LVL3("Fetching last previously stored packet...");
    PRINT_DEBUG_MSG_NL3;
    numFIFOPkts--;
    PRINT_DEBUG_MSG_LVL3("Number of stored messages left in FIFOPkt: ");
    PRINT_DEBUG_MSG_LVL3_UDec((uint16_T)(numFIFOPkts));
    PRINT_DEBUG_MSG_NL3;
    #endif

    return RemoveFIFO(&PktFIFOHead, &PktFIFOTail);

}

PRIVATE FIFOBuffer * GetFIFOPkt(void) {

    return PktFIFOHead;

}

PRIVATE boolean_T AddToFIFOFree(void) {

    int_T       i;
    boolean_T error = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("AddToFIFOFree")

    PRINT_DEBUG_MSG_LVL3("Allocating memory for (another) ");
    PRINT_DEBUG_MSG_LVL3_UDec((uint16_T)NUM_FIFO_BUFFERS);
    PRINT_DEBUG_MSG_LVL3_Raw(" free FIFO buffers");
    PRINT_DEBUG_MSG_NL3;
   
    for (i = 0 ; i < NUM_FIFO_BUFFERS ; i++) {
    
        FIFOBuffer *buf = calloc(1, sizeof(FIFOBuffer));

        if (buf == NULL) {

            //abort_LED(22);
            error = EXT_ERROR;
            goto EXIT_POINT;

        }

        InsertFIFOFree(buf);

    }
    
EXIT_POINT:

    return error;

}

PRIVATE void SavePkt(uint8_T *mem, int_T size) {

    FIFOBuffer *buf = RemoveFIFOFree();

    #ifdef MATLAB_MEX_FILE
    /* The ack protocol NO LONGER ensures there is available space to save the pkt.   --  fw-07-07 */
    if (buf == NULL) {

      
        //mexPrintf("Allocating more FIFO buffers... \n");
       
        /* allocate another FIFOBUFNUM buffers... */
        if (AddToFIFOFree() != EXT_NO_ERROR) {

            /* out of memory... */
            mexErrMsgTxt("Out of memory while trying to allocate more FIFO buffers...\n\r");
           
        }

        /* now get one of the newly allocated (free) FIFOs... */
        buf = RemoveFIFOFree();

    } /* buf == NULL */
    #endif

    assert(buf!=NULL);

    /* The max transmission size ensures we never exceed memory when copying. */
    assert (size <= MAX_SERIAL_PKT_SIZE);

    memcpy(buf->pktBuf,mem,size);
    buf->size   = size;
    buf->offset = 0;

    InsertFIFOPkt(buf);
}


#if DEBUG_MSG_LVL > 0
/* Debug function: display actually received contents... */
PRIVATE void DisplayActualReceivedPacket(ExtSerialPacket *pkt) {
  
    uint_T      i;
    uint8_T    *myPtr   = (uint8_T *)pkt;
    uint32_T    mySize  = pkt->size;
   
    PRINT_DEBUG_MSG_LVL1_Raw("[");
   
    /* header (2), type (1)  -->  3 elements altogether */
    for (i = 0; i < 3; i++) {
    
        PRINT_DEBUG_MSG_LVL1_Raw(" ");
        PRINT_DEBUG_MSG_LVL1_UHex((uint16_T)(*myPtr++));
        
    }
   
    /* size (uint32_T)  -->  4 elements altogether */
    myPtr = (uint8_T *)&mySize;
    for (i = 0; i < sizeof(mySize); i++) {
    
        PRINT_DEBUG_MSG_LVL1_Raw(" ");
        PRINT_DEBUG_MSG_LVL1_UHex((uint16_T)(*myPtr++));
        
    }
   
    /* data */
    for (i = 0; i < mySize; i++) {
    
        PRINT_DEBUG_MSG_LVL1_Raw(" ");
        PRINT_DEBUG_MSG_LVL1_UHex((uint16_T)(pkt->Buffer[i]));
    
    }
   
    /* tail */
    myPtr = (uint8_T *)&pkt->tail;
    for (i = 0; i < 2; i++) {
    
        PRINT_DEBUG_MSG_LVL1_Raw(" ");
        PRINT_DEBUG_MSG_LVL1_UHex((uint16_T)(*myPtr++));
        
    }
   
    PRINT_DEBUG_MSG_LVL1_Raw(" ]");
    PRINT_DEBUG_MSG_NL1;

}
#endif



/***************** PRIVATE FUNCTIONS ******************************************/

/* Forward declaration */
PRIVATE boolean_T ExtSetPkt(ExtSerialPort*, char_T *, int_T, int_T *, PacketTypeEnum);

/* Function: ExtGetPktBlocking =================================================
 * Abstract:
 *  Blocks until a packet is available on the comm line.  If the incoming packet
 *  is an ACK, the packet is processed and thrown away.  Otherwise, the packet
 *  is saved.
 *
 *  EXT_NO_ERROR is returned on success, EXT_ERROR on failure.
 */
PRIVATE boolean_T ExtGetPktBlocking(ExtSerialPort *portDev) {

    boolean_T error = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ExtGetPktBlocking")

    PRINT_DEBUG_MSG_LVL3("IN");
    PRINT_DEBUG_MSG_NL3;

    #ifndef MATLAB_MEX_FILE
        #if DEBUG_MSG_LVL > 0
        /* 
         * Target only:
         * Display contents of the current reception ring buffer (without removing them).
         * Up to MAX_SERIAL_PKT_SIZE bytes are displayed.
         */
        ExtSerialPortPeekRB(MAX_SERIAL_PKT_SIZE);
        #endif
    #endif  /* MATLAB_MEX_FILE */
   
    /* Block until a packet is available from the comm line. */
    error = GetExtSerialPacket(InBuffer, portDev);
   
    /* mark the end of the (blocking) packet receiving call */
    PRINT_DEBUG_MSG_LVL1_Raw(">");
    PRINT_DEBUG_MSG_NL1;
        
    #if DEBUG_MSG_LVL > 0
    DisplayActualReceivedPacket(InBuffer);
    #endif
         
    if (error != EXT_NO_ERROR) {

        //abort_LED(23);

        PRINT_DEBUG_MSG_LVL3("Error in call to GetExtSerialPacket");
        PRINT_DEBUG_MSG_NL3;
        goto EXIT_POINT;

    }
    
    PRINT_DEBUG_MSG_LVL3("Received valid packet. Type: ");
    PRINT_DEBUG_MSG_LVL3_UDec((uint16_T)(InBuffer->PacketType));
    PRINT_DEBUG_MSG_NL3;
    PRINT_DEBUG_MSG_LVL3((const char_T *)debugTelTypeStrings[(uint16_T)InBuffer->PacketType]);
    PRINT_DEBUG_MSG_NL3;

    #ifdef MATLAB_MEX_FILE
        #if DEBUG_MSG_LVL > 0
        if (InBuffer->PacketType == EXTMODE_PACKET && InBuffer->BufferSize >= 4) {

            uint8_T  myAction = InBuffer->Buffer[3];     // stored in reverse order, e.g.  0  0  0  27

            PRINT_DEBUG_MSG_LVL3("Payload indicates data action (if it is an action at all...): ");
            PRINT_DEBUG_MSG_LVL3_UHex(myAction);
            if (myAction < numActionStrings) {

                PRINT_DEBUG_MSG_LVL3_Raw(" (");
                PRINT_DEBUG_MSG_LVL3_Raw(debugActionStrings[myAction]);
                PRINT_DEBUG_MSG_LVL3_Raw(")");
                if (InBuffer->PacketType == EXTMODE_PACKET && InBuffer->BufferSize >= 8) {

                uint8_T  mySize = InBuffer->Buffer[7];    // stored in reverse order, e.g.  0  0  0  size(<=255)

                PRINT_DEBUG_MSG_LVL3_Raw(", data size: ");
                PRINT_DEBUG_MSG_LVL3_UHex(mySize);
                PRINT_DEBUG_MSG_LVL3_Raw(" (");
                PRINT_DEBUG_MSG_LVL3_UDec(mySize);
                PRINT_DEBUG_MSG_LVL3_Raw(" bytes)");

                }

            }
            PRINT_DEBUG_MSG_NL3;

        }
        #endif  /* DEBUG_MSG_LVL */
    #endif  /* MATLAB_MEX_FILE */


    /* Process ACK packets, don't pass on to application. */
    if (InBuffer->PacketType == ACK_PACKET) {

        PRINT_DEBUG_MSG_LVL1("Received ACK_PACKET -> waitForAck = FALSE;");
        PRINT_DEBUG_MSG_NL1;

        waitForAck = FALSE;

        #ifdef HOSTALIVECHECK
        HostIsAlive = TRUE;     /* automatic target data buffer control  --  fw-07-07 */
        #endif
      
        goto EXIT_POINT;

    }

    PRINT_DEBUG_MSG_LVL2("Storing received EXTMODE_PACKET in FIFO buffer");
    PRINT_DEBUG_MSG_NL2;
    SavePkt(InBuffer->Buffer, (int_T)InBuffer->size);

    /* fw-06-10: should the acknowledgement of the intercepted packet really depend on the queue status of FIFOFree?? */
    if (!isFIFOFreeEmpty()) {
        int_T bytesWritten;

        PRINT_DEBUG_MSG_LVL2("Sending ACK_PACKET to acknowledge the receipt of the received EXTMODE_PACKET...");
        PRINT_DEBUG_MSG_NL2;

        error = ExtSetPkt(portDev, NULL, 0, &bytesWritten, ACK_PACKET);
        
        PRINT_DEBUG_MSG_LVL2("... ACK_PACKET sent.");
        PRINT_DEBUG_MSG_NL2;

        if (error != EXT_NO_ERROR) {

            PRINT_DEBUG_MSG_LVL3("Error in call to ExtSetPkt (while sending ACK_PACKET)");
            PRINT_DEBUG_MSG_NL3;

            //abort_LED(24);

            goto EXIT_POINT;

        }

    }

EXIT_POINT:

    PRINT_DEBUG_MSG_LVL3("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL3_UDec(error);
    PRINT_DEBUG_MSG_NL3;

    return error;

}  /* end ExtGetPktBlocking */


/* Function: ExtSetPkt =========================================================
 * Abstract:
 *  Sets (sends) the specified number of bytes on the comm line.  As long as an
 *  error does not occur, this function is guaranteed to set the requested
 *  number of bytes.  The number of bytes set is returned via the 'nBytesSet'
 *  parameter.  If a previously sent packet has not yet received an ACK, then we
 *  block for the next packet which must be an ACK.
 *
 *  EXT_NO_ERROR is returned on success, EXT_ERROR on failure.
 */
PRIVATE boolean_T ExtSetPkt(ExtSerialPort  *portDev,
                            char_T         *pktData,
                            int_T           pktSize,
                            int_T          *bytesWritten,
                            PacketTypeEnum  pktType) {

    int_T       bytesToSend;
    uint_T      deadlockCntr;
    boolean_T   error = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ExtSetPkt")

    PRINT_DEBUG_MSG_LVL3("IN");
    PRINT_DEBUG_MSG_NL3;

    /* 
     * limit 'bytesToSend' to MAX_SERIAL_PKT_SIZE bytes (FIFO buffer size) 
     *
     * no longer required - calling functin takes care of this now (ExtSetPktWithACK)
     * left active to be sure (this function gets called recursively when an packet is 
     * intercepted - should not cause any problems, but better safe than sorry...
     *
     * fw-06-10
     */
    bytesToSend  = (pktSize > MAX_SERIAL_PKT_SIZE) ? MAX_SERIAL_PKT_SIZE : pktSize;

    /* nothing's been written yet */
    *bytesWritten = 0;

    #if COMMSTATE_ON_PTT == 1
    /* display current state of 'waitForAck' on PTT.1 */
    if (waitForAck) {

        PTT |=  0x01;

    } else {

        PTT &= ~0x01;

    }
    #endif

    /* debug: display current 'waitForAck' state on SCI0 */
    #if DEBUG_MSG_LVL > 0
    if (pktType != ACK_PACKET) {
    
        if (waitForAck) {
        
            PRINT_DEBUG_MSG_LVL3("waitForAck = TRUE  -> need to wait for ACK_PACKET");
            PRINT_DEBUG_MSG_NL3;
            
        }
        /* else message is printed below... (otherwise the 'clear to send' appears twice... */
        
    } else {
    
        PRINT_DEBUG_MSG_LVL3("Sending (regular) ACK_PACKET... (always possible, regardless the state of the 'waitForAck' flag)");
        PRINT_DEBUG_MSG_NL3;
        
    }
    #endif

    /*
     * Wait for an ACK packet if needed. Every packet sent must be ACKed before
     * another can be sent (the only exceptions are ACK packets which are never
     * ACKed).
     */
    deadlockCntr = 0;
    while (waitForAck && (pktType != ACK_PACKET)) {
    
        int32_T numPending = 0;

        error = ExtSerialPortDataPending(portDev, &numPending);
        if (error != EXT_NO_ERROR) {

            //abort_LED(25);
            goto EXIT_POINT;

        }

        /* has a valid packet been intercepted? */
        if (numPending >= MIN_PACKET_SIZE) {

            /* yes -> this could be the ACK_PACKET we are waiting for */

            /* indicate beginning of 'blocking call section' (entry point #2 = ExtSetPkt) */
            PRINT_DEBUG_MSG_LVL1_Raw("<2");
            PRINT_DEBUG_MSG_LVL3("Making blocking call to fetch detected pending data from the comms line...");
            PRINT_DEBUG_MSG_NL3;

            /* fetch the intercepted packet */
            error = ExtGetPktBlocking(portDev);
            if (error != EXT_NO_ERROR) {

                //abort_LED(26);
                goto EXIT_POINT;

            }

        }
      
        /* on the target only... */
        #ifndef MATLAB_MEX_FILE
        else {
        
            if (numPending == -1) {
            
                /* 
                 * target timeout has been detected...
                 * incomplete ACK_PACKET (currently only an assumption! -> perform check) packet has been removed
                 */
                PRINT_DEBUG_MSG_LVL1("Target timeout, setting waitForAck = FALSE");
                PRINT_DEBUG_MSG_NL1;
                waitForAck = false;
                
                /* exit from the while loop */
                break;
        
            }
        
        }
        #endif /* MATLAB_MEX_FILE */
        
        
        /*
         * If we are in this loop, it means we are trying to send a pkt but
         * have not received an ACK from the other side.  If we don't get an
         * ACK after some amount of time, we may be in a deadlock condition
         * where both sides are waiting for an ACK.  In this case, allocating
         * some more free packets will break the deadlock condition.
         */
        if ((++deadlockCntr >= 200) && isFIFOFreeEmpty()) {

            int_T temp;

            PRINT_DEBUG_MSG_LVL3("ACK deadlock situation detected (host & target might be waiting for ACK)");
            PRINT_DEBUG_MSG_NL3;

            deadlockCntr = 0;
                
            error = AddToFIFOFree();
            if (error != EXT_NO_ERROR) {

                //abort_LED(27);
                goto EXIT_POINT;

            }

            PRINT_DEBUG_MSG_LVL3("Sending ACK_PACKET to target to (hopefully) unblock communication");
            PRINT_DEBUG_MSG_NL3;

            error = ExtSetPkt(portDev, NULL, 0, &temp, ACK_PACKET);
            if (error != EXT_NO_ERROR) {

                //abort_LED(28);
                goto EXIT_POINT;

            }

        }  /* if (++deadlockCntr...) */
        
    }  /* while */

    /*
     * Write the packet to the outgoing buffer. The output buffer is
     * guaranteed to be big enough to hold the maximum size packet.
     */
    OutBuffer->size = (uint32_T)bytesToSend;
    OutBuffer->PacketType = (char_T)pktType;
    memcpy(OutBuffer->Buffer, pktData, (uint_T)bytesToSend);

    /* Send the packet over the comm line. */
    #if DEBUG_MSG_LVL > 0
    if (pktType != ACK_PACKET) {
    
        PRINT_DEBUG_MSG_LVL1("waitForAck = FALSE -> clear to send");
        PRINT_DEBUG_MSG_NL1;
    
    }
    #endif

    PRINT_DEBUG_MSG_LVL3("Sending now...");
    PRINT_DEBUG_MSG_NL3;
   
    /* send the packet (ext_serial_pkt.c) */
    error = SetExtSerialPacket(OutBuffer, portDev);
    if (error != EXT_NO_ERROR) {
    
            goto EXIT_POINT;
        
      }

    /* at this stage, the packet has been sent */
    *bytesWritten = bytesToSend;

EXIT_POINT:

    PRINT_DEBUG_MSG_LVL3("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL3_UDec(error);
    PRINT_DEBUG_MSG_NL3;

    return error;

}  /* end ExtSetPkt */



/* Function: ExtAdjPktSize =====================================================
 * Abstract:
 *  Adjusts the size of packets to be transmitted to avoid 'split packates'. 
 *  Split packages are multi-record packages which exceed the size of an 
 *  individual FIFO buffer and are split in the middle of a record. This 
 *  can cause the host-target communication system to enter a deadlock 
 *  situation.
 *
 *  The returned packet size is adjusted to ensure that a transmission packet 
 *  always ends on a record boundary, i. e. there are no 'split packages'
 *
 *  EXT_NO_ERROR is returned (always)
 */

PRIVATE boolean_T ExtAdjPktSize(int_T    pktSize, 
                                int_T    totalBytesWritten, 
                                char_T  *pktData, 
                                int_T   *adjPktSize) {

    uint_T      currRecStartIdx     = totalBytesWritten;
    uint32_T    bytesStillToWrite   = pktSize - totalBytesWritten;
    uint32_T    currPktDataSize     = 0;
    uint32_T    currRecSize;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ExtAdjPktSize")

    PRINT_DEBUG_MSG_LVL3("IN");
    PRINT_DEBUG_MSG_NL3;

    /* 
     * adjust (= reduce) packet length to end on a record boundary 
     * and fit the maximum FIFO buffer size 
     */
    while (currPktDataSize < bytesStillToWrite) {
    
        /* 
         * fetch next record size. Note that this will work irrespective the 
         * endianness of the current platform as the data has been placed in 
         * the buffer by a function working to the same endianness.
         *
         * size info is always stored in bytes 4 - 7 of the current record
         */
        currRecSize = (uint32_T)(*(uint32_T *)&pktData[currRecStartIdx + 4]);
    
        /* adjust packet size: each record is '4 (= type) + currRecSize' bytes long */
        currPktDataSize += (8 + currRecSize);
        
        /* are we done? */
        if (currPktDataSize > MAX_SERIAL_PKT_SIZE) {
            
            /* exceeding maximum admissible FIFO buffer size -> exit while loop */
            break;
            
        } else {
            
            /* there still remains some space for further data -> next index */
            
            /* start of the next record */
            currRecStartIdx = (uint_T)currPktDataSize;
            
        }
        
    }


    /* return the number of bytes to be written in the call to ExtSetPkt */
    if (currPktDataSize > MAX_SERIAL_PKT_SIZE) {
        
        /* 'currPktDataSize' exceeds maximum admissible FIFO buffer size */
        *adjPktSize = (int_T)(currPktDataSize - 8 - currRecSize);
        
    } else {
        
        /* 'currPktDataSize' just attains the maximum admissible FIFO buffer size */
        *adjPktSize = (int_T)currPktDataSize;
        
    }


    PRINT_DEBUG_MSG_LVL3("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL3_UDec(EXT_NO_ERROR);
    PRINT_DEBUG_MSG_NL3;

    return EXT_NO_ERROR;

}  /* ExtAdjPktSize */



/* Function: ExtSetPktWithACK ==================================================
 * Abstract:
 *  Sets (sends) the specified number of bytes on the comm line and waits for a
 *  return packet.  As long as an error does not occur, this function is
 *  guaranteed to set the requested number of bytes.  The number of bytes set is
 *  returned via the 'nBytesSet' parameter.
 *
 *  If the return packet is an ACK, the ACK is processed and thrown away.  If
 *  the return packet is something other than an ACK, the packet is saved and
 *  processed and a global flag is set to indicate we are still waiting for an
 *  ACK packet.  A typical scenario where the return packet is not an ACK is
 *  when both the host and target send a packet to each other simultaneously.
 *
 *  EXT_NO_ERROR is returned on success, EXT_ERROR on failure.
 */
PRIVATE boolean_T ExtSetPktWithACK(ExtSerialPort  *portDev,
                                   char_T         *pktData,
                                   int_T           pktSize,
                                   PacketTypeEnum  pktType) {

    int_T       pktSizeAdjusted;
    int_T       bytesWritten      = 0;
    int_T       totalBytesWritten = 0;
    boolean_T   error             = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ExtSetPktWithACK")

    PRINT_DEBUG_MSG_LVL3("IN");
    PRINT_DEBUG_MSG_NL3;
    
    /* NOTE: ExtSetPkt can only send up to MAX_SERIAL_PKT_SIZE (= FIFOBUFSIZE) at a time... this 
     *       loop spreads larger packets (theoretically up to CIRCBUFSIZE over multiple calls
     *       to ExtSetPkt      --    fw-07-07
     */
    while (totalBytesWritten < pktSize) {
    
        /* 
         * adjust package size to ensure that only entire log data records 
         * / packages are being sent
         *
         * only do this for packets which exceed the FIFO buffer size!
         */
        if (pktSize > MAX_SERIAL_PKT_SIZE) {
          
            
            /* 
             * current packet size needs adjusted (= shortened), as the 
             * packet does not fit completely into the FIFO buffer
             */
            (void)ExtAdjPktSize(pktSize, totalBytesWritten, pktData, &pktSizeAdjusted);
            
        } else {
          
            /* 
             * no packet size adjustment required as the 
             * entire packet fits into the FIFO buffer
             */
            pktSizeAdjusted = pktSize;
            
        }

        /* Send packet / the next section of the entire packet */
        error = ExtSetPkt(portDev, 
                          pktData + totalBytesWritten,   /* pointer to beginning of next section of data */
                          pktSizeAdjusted,               /* number of bytes still to be written */
                          &bytesWritten, 
                          pktType);

        if (error != EXT_NO_ERROR) {
        
            goto EXIT_POINT;
            
        }

        /* adjust number of bytes which have been sent so far */
        totalBytesWritten += bytesWritten;

        /* We must get an ACK back. */
        waitForAck = true;
        
        PRINT_DEBUG_MSG_LVL1("ExtMode packet sent, setting waitForAck to TRUE");
        PRINT_DEBUG_MSG_NL1;
        
    }  /* while (totalBytesWritten < pktSize) */

EXIT_POINT:

    PRINT_DEBUG_MSG_LVL3("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL3_UDec(error);
    PRINT_DEBUG_MSG_NL3;
    
    return error;

}  /* end ExtSetPktWithACK */


/* Function: ExtGetPkt =========================================================
 * Abstract:
 *  Attempts to get the specified number of bytes from the comm line.  The
 *  number of bytes read is returned via the 'nBytesGot' parameter.
 *
 *  EXT_NO_ERROR is returned on success, EXT_ERROR on failure.
 *
 * NOTES:
 *  o it is not an error for 'nBytesGot' to be returned as 0
 *  o this function blocks if no data is available
 */
PRIVATE boolean_T ExtGetPkt(ExtSerialPort *portDev,
                            char_T *dst,
                            int_T nBytesToGet,
                            int_T *returnBytesGot)
{
    FIFOBuffer *buf;
    int_T       UnusedBytes;
    boolean_T   error = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ExtGetPkt")

    PRINT_DEBUG_MSG_LVL3("IN");
    PRINT_DEBUG_MSG_NL3;

    buf = GetFIFOPkt();
    while (buf == NULL) {
            PRINT_DEBUG_MSG_LVL1("2");
            PRINT_DEBUG_MSG_NL1;

        error = ExtGetPktBlocking(portDev);
        if (error != EXT_NO_ERROR) {
        
            goto EXIT_POINT;
            
        }

        buf = GetFIFOPkt();
    }

    UnusedBytes = (int_T)(buf->size - buf->offset);
    
    PRINT_DEBUG_MSG_LVL3("Number of unprocessed bytes in packet received from FIFO: ");
    PRINT_DEBUG_MSG_LVL3_UDec((uint16_T)UnusedBytes);
    PRINT_DEBUG_MSG_NL3;

    /* Test packet size. */
    if (nBytesToGet >= UnusedBytes) {
    
        /* only 'UnusedBytes' left (requested amount or less than requested) -> return these bytes */
        *returnBytesGot = UnusedBytes;
        
    } else {
    
        /* more than the requested amount of bytes left -> return requested amount */
        *returnBytesGot = nBytesToGet;
        
    }

    /* Save packet using char* for proper math. */
    {
        char_T *tempPtr = buf->pktBuf;
        tempPtr += buf->offset;
        (void)memcpy(dst, tempPtr, *returnBytesGot);
    }

    /* Adjust packet internal offset */
    buf->offset += *returnBytesGot;

    /* Determine if the packet can be discarded. */
    if (buf->offset == buf->size) {
    
        /* done with this packet -> remove from FIFOPkt queue */
        int_T  bytesWritten;
        boolean_T isEmpty = isFIFOFreeEmpty();

        /* mark as 'free' */
        buf->size   = 0;
        buf->offset = 0;

        /* remove packet and return it to the FIFOFree queue */
        InsertFIFOFree(RemoveFIFOPkt());

        /* all available FIFO entries in use? (prior to returning the just processed FIFO entry) */
        if (isEmpty) {
        
            /* yes -> acknowledge receipt of the now completely processed FIFO packet */
            PRINT_DEBUG_MSG_LVL3("All FIFO entries in use -> sending ACK_PACKET.");
            PRINT_DEBUG_MSG_NL3;
            
            error = ExtSetPkt(portDev, NULL, 0, &bytesWritten, ACK_PACKET);
            if (error != EXT_NO_ERROR) {
            
                goto EXIT_POINT;
                
            }
            
        }
    }

EXIT_POINT:

    PRINT_DEBUG_MSG_LVL3("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL3_UDec(error);
    PRINT_DEBUG_MSG_NL3;
    return error;

}  /* end ExtGetPkt */


/* Function: ExtPktPending =====================================================
 * Abstract:
 *  Returns true, via the 'pending' arg, if data is pending on the comm line.
 *  Returns false otherwise.  If data is pending, the packet is read from the
 *  comm line.  If that packet is an ACK packet, false is returned.  If the
 *  packet is an extmode packet, it is saved and true is returned.
 *
 *  EXT_NO_ERROR is returned on success, EXT_ERROR on failure.
 */
PRIVATE boolean_T ExtPktPending(ExtSerialPort *portDev,
                                boolean_T     *pending, 
                                const int_T    nBytesToGet) {

    boolean_T error = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ExtPktPending")

    PRINT_DEBUG_MSG_LVL5("IN");
    PRINT_DEBUG_MSG_NL5;

    *pending = false;

    if (isFIFOPktEmpty()) {

        /*
         * Is there a pkt already waiting?  If so, return true for pending pkt.
         * Otherwise, try to grab a pkt from the comm line (if one exists).
         */
        int32_T numPending = 0;

        PRINT_DEBUG_MSG_LVL5("Checking for pending packets");
        PRINT_DEBUG_MSG_NL5;

        error = ExtSerialPortDataPending(portDev, &numPending);
        if (error != EXT_NO_ERROR) {

            //abort_LED(33);
            goto EXIT_POINT;

        }

        if (numPending >= MIN_PACKET_SIZE) {
         
            /*
             * The current version of 'CheckExtSerialPacket' leads to a (reproducible) communication error 
             * upon downloading new parameter sets. The error occurs because variable 'peekDataSize' is 
             * not reset in subsequent calls to this function (by design of this function - i.e. on purpose).
             * Function 'CheckExtSerialPacket' is called during various phases of the communication cycle 
             * - this can lead to situations in which the host is waiting for more bytes than what is sent 
             * by the target... as variable 'peekDataSize' refers to a previous upload. Removing the following
             * call to 'CheckExtSerialPacket' (used nowhere else) leads to stable operation.
             *
             * --> DO NOT DEFINE MACRO 'CHECKPACKETSTRUCTURE'
             *
             * fw-07-10
             */
            #undef CHECKPACKETSTRUCTURE
            #ifdef CHECKPACKETSTRUCTURE
            /* 
             * -> check if a full packet has arrived (requires knowledge
             *    of the packet format).
             * -> this addition to the original code is hoped to improve 
             *    stability of the external mode interface  (fw-05-10)
             */
            if (CheckExtSerialPacket(portDev)) {
            #else
            {
            #endif
             
                /* 
                 * at least one full packet is available
                 * -> return number of bytes pending
                 */
                PRINT_DEBUG_MSG_LVL5("At least one full packet pending...");

                /* indicate beginning of 'blocking call section' (entry point #1 = ExtPktPending) */
                PRINT_DEBUG_MSG_LVL1_Raw("<1");
                PRINT_DEBUG_MSG_LVL3("Making blocking call to fetch detected pending data from the comms line...");
                PRINT_DEBUG_MSG_NL3;
             
                error = ExtGetPktBlocking(portDev);
                if (error != EXT_NO_ERROR) {

                    //abort_LED(34);
                    goto EXIT_POINT;

                }

                /*
                 * Only if the pkt is saved in the fifo do we return a pkt is
                 * pending.  If the acquired pkt was an ACK, it would have been
                 * thrown away.
                 */
                if (!isFIFOPktEmpty()) {

                    PRINT_DEBUG_MSG_LVL3("Pending non-ACK packet detected (in FIFO)...");
                    PRINT_DEBUG_MSG_NL3;

                    *pending = true;

                }

            }  /* fullPacketAvailable */

        }
      
        /* on the target only... */
        #ifndef MATLAB_MEX_FILE
        else {
        
            if (numPending == -1) {
                
                /* target timeout has been detected... */
                /* incomplete ACK_PACKET (currently only an assumption! -> perform check) packet has been removed */
                PRINT_DEBUG_MSG_LVL1("Target timeout, setting waitForAck = FALSE");
                PRINT_DEBUG_MSG_NL1;

                waitForAck = false;
            
            }
            
        }
        #endif  /* MATLAB_MEX_FILE */
        
    } else {

        PRINT_DEBUG_MSG_LVL3("Pending non-ACK packet detected (in FIFO)...");
        PRINT_DEBUG_MSG_NL3;

        *pending = true;

    }

EXIT_POINT:

    PRINT_DEBUG_MSG_LVL5("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL5_UDec(error);
    PRINT_DEBUG_MSG_NL5;

    return error;

}  /* end ExtPktPending */


/* Function: ExtClearSerialConnection ==========================================
 * Abstract:
 *  Clear the connection by setting certain global variables to their initial
 *  states.  The difference between ExtResetSerialConnection() and
 *  ExtClearSerialConnection() is that the reset function frees all allocated
 *  memory and nulls out all pointers.  The clear function only initializes
 *  some global variables without freeing any memory.  When the connection is
 *  being opened or closed, use the reset function.  If the host and target
 *  are only disconnecting, use the clear function.
 */
PRIVATE void ExtClearSerialConnection(void) {

    waitForAck = false;

}  /* end ExtClearSerialConnection */


/* Function: ExtResetSerialConnection ==========================================
 * Abstract:
 *  Reset the connection with the target by initializing some global variables
 *  and freeing/nulling all allocated memory.
 */
PRIVATE void ExtResetSerialConnection(void) {

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ExtResetSerialConnection")
    #if DEBUG_MSG_LVL > 0
    int_T         bufCount;
    #endif

    PRINT_DEBUG_MSG_LVL3("Freeing memory of FIFOFree queue...");
    PRINT_DEBUG_MSG_NL3;
    #if DEBUG_MSG_LVL > 0
    bufCount = 0;
    #endif
   
    while (!isFIFOFreeEmpty()) {
    
        free(RemoveFIFOFree());

        #if DEBUG_MSG_LVL > 0
        bufCount++;
        #endif

    }

    PRINT_DEBUG_MSG_LVL3("... ");
    PRINT_DEBUG_MSG_LVL3_UDec((uint16_T)bufCount);
    PRINT_DEBUG_MSG_LVL3_Raw(" buffers representing a total of ");
    PRINT_DEBUG_MSG_LVL3_UDec((uint16_T)(bufCount * (MAX_SERIAL_PKT_SIZE + 12)));
    PRINT_DEBUG_MSG_LVL3_Raw(" bytes");
    PRINT_DEBUG_MSG_NL3;

    PRINT_DEBUG_MSG_LVL3("Freeing memory of FIFOPkt queue...");
    PRINT_DEBUG_MSG_NL3;
    #if DEBUG_MSG_LVL > 0
    bufCount = 0;
    #endif

    while (!isFIFOPktEmpty()) {
        free(RemoveFIFOPkt());
        #if DEBUG_MSG_LVL > 0
        bufCount++;
        #endif
    }
    
    PRINT_DEBUG_MSG_LVL3("... ");
    PRINT_DEBUG_MSG_LVL3_UDec((uint16_T)bufCount);
    PRINT_DEBUG_MSG_LVL3_Raw(" buffers representing a total of ");
    PRINT_DEBUG_MSG_LVL3_UDec((uint16_T)(bufCount * (MAX_SERIAL_PKT_SIZE + 12)));
    PRINT_DEBUG_MSG_LVL3_Raw(" bytes");
    PRINT_DEBUG_MSG_NL3;

    PRINT_DEBUG_MSG_LVL3("Freeing memory of InBuffer (");
    PRINT_DEBUG_MSG_LVL3_UDec((uint16_T)(MAX_SERIAL_PKT_SIZE));
    PRINT_DEBUG_MSG_LVL3_Raw(" bytes)");
    PRINT_DEBUG_MSG_NL3;
   
    free(InBuffer->Buffer);
    memset(InBuffer, 0, sizeof(ExtSerialPacket));

    PRINT_DEBUG_MSG_LVL3("Freeing memory of OutBuffer (");
    PRINT_DEBUG_MSG_LVL3_UDec((uint16_T)(MAX_SERIAL_PKT_SIZE));
    PRINT_DEBUG_MSG_LVL3_Raw(" bytes)");
    PRINT_DEBUG_MSG_NL3;
   
    free(OutBuffer->Buffer);
    memset(OutBuffer, 0, sizeof(ExtSerialPacket));

    PktFIFOHead  = PktFIFOTail  = NULL;
    FreeFIFOHead = FreeFIFOTail = NULL;

    /* reinitialize 'waitForAck' (to FALSE) */
    ExtClearSerialConnection();

}  /* end ExtResetSerialConnection */


/* Function: ExtOpenSerialConnection ===========================================
 * Abstract:
 *  Open the connection with the target.
 */
PRIVATE ExtSerialPort *ExtOpenSerialConnection(uint16_T port, uint32_T baud) {

    ExtSerialPort *portDev = NULL;
    uint32_T       maxSize  = MAX_SERIAL_PKT_SIZE;    /* removed factor '*2'  --  fw - 07 - 07 */
    boolean_T     error    = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ExtOpenSerialConnection")

    portDev = ExtSerialPortCreate();
    if (portDev == NULL) {

        //abort_LED(35);
        goto EXIT_POINT;

    }
    ExtResetSerialConnection();

    /*
     * Allocate the buffers for sending and receiving packets big enough to
     * hold the maximum size packet possible for transmission.
     */

    PRINT_DEBUG_MSG_LVL3("Allocating memory for OutBuffer (");
    PRINT_DEBUG_MSG_LVL3_UDec((uint16_T)maxSize);
    PRINT_DEBUG_MSG_LVL3_Raw(" bytes)");
    PRINT_DEBUG_MSG_NL3;

    OutBuffer->Buffer = (uint8_T *)malloc(maxSize);
    if (OutBuffer->Buffer == NULL) {
        //abort_LED(36);
        error = EXT_ERROR;
        goto EXIT_POINT;
    }
    OutBuffer->BufferSize = maxSize;

    PRINT_DEBUG_MSG_LVL3("Allocating memory for InBuffer (");
    PRINT_DEBUG_MSG_LVL3_UDec((uint16_T)maxSize);
    PRINT_DEBUG_MSG_LVL3_Raw(" bytes)");
    PRINT_DEBUG_MSG_NL3;
   
    InBuffer->Buffer = (uint8_T *)malloc(maxSize);
    if (InBuffer->Buffer == NULL) {
        //abort_LED(37);
        error = EXT_ERROR;
        goto EXIT_POINT;
    }
    InBuffer->BufferSize = maxSize;

    error = AddToFIFOFree();
    if (error != EXT_NO_ERROR) {

        //abort_LED(38);
        goto EXIT_POINT;

    }

    error = ExtSerialPortConnect(portDev, port, baud);
    if (error != EXT_NO_ERROR) {

        //abort_LED(39);
        goto EXIT_POINT;

    }


EXIT_POINT:

    if (error != EXT_NO_ERROR) {

        portDev = NULL;

    }

    return portDev;

}  /* end ExtOpenSerialConnection */


/* Function: ExtCloseSerialConnection ==========================================
 * Abstract:
 *  Close the connection with the target.
 */
PRIVATE boolean_T ExtCloseSerialConnection(ExtSerialPort *portDev) {

    ExtResetSerialConnection();

    return ExtSerialPortDisconnect(portDev);

}  /* end ExtCloseSerialConnection */


/* [EOF] ext_serial_utils.c */