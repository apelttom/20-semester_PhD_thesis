/*
 *********************************************************************************************************
 *
 * MAIN module of rtmc9s12-target
 *
 * (c) Frank Wörnle, 2010
 * 
 *********************************************************************************************************
 *
 * File              : mc_main.c
 * Version           : 1.00
 * Last modification : 10.08.2010, Frank Wörnle, prepared for optional use of FreeRTOS
 *
 *********************************************************************************************************
 */



/*
 *********************************************************************************************************
 *    INCLUDES
 *********************************************************************************************************
 */

/* Model dependent constants -- generated by 'gen_mc_defines_h.m' */
#include "mc_defines.h"
#include "mc_debugMsgs.h"       /* macros PRINT_DEBUG_MSG_LVL1 to PRINT_DEBUG_MSG_LVL1,  fw-06-07 */

#include "bsp_includes.h"       /* all controller specific includes         */
#include "bsp_pll.h"            /* PLL_Init()                               */
#include "bsp_sci.h"            /* SCIx_Init, etc.                          */
#include "bsp_rti.h"            /* CoreTimer_Start, CoreTimer_Stop, etc.    */
#include "bsp_timer.h"          /* ECT_Init, ECT_Start, etc.                */

/* Toolbox headers */
#include "mc_signal.h"          /* abort_LED, etc.                          */
#include "mc_freePortComms.h"   /* freePortComms support                    */
#include "mc_radioComms.h"      /* radioComms support                       */
#include "mc_lcd.h"             /* LCD_init()                               */


/* RTW headers */
#include  "rtwtypes.h"
# include "rtmodel.h"
#include  "rt_sim.h"

/* DBL_EPSILON */
#include <float.h>


/* External Mode headers */
#if EXT_MODE == 1

#include "rtw_extmode.h"
#include "ext_svr.h"            /* rt_ExtModeInit(), ExtSetWaitForStartMsg() */
#include "ext_share.h"          /* included here 'coz it (re-)defines PUBLIC as 'empty' (cf. ext_svr_transport.h) */
#include "ext_svr_transport.h"  /* *RecBufPtr, ExtInit() */

#else

// TODO: use RTOS memory management
// TODO: use RTOS memory management
// TODO: use RTOS memory management
#include <stdlib.h>             /* malloc, calloc, free, realloc */

#endif


/*
 * startModel
 * prototypes/deactivating macros for ExtMode functions (rtExtModeOneStep, usw.)
 */
#include "ext_work.h"



/*
 *********************************************************************************************************
 *    DEFINES
 *********************************************************************************************************
 */

/* LCD support (if any) */
#if LCDUSE4ERRORS == 1
  #define LCD_LINE_1   0
  #define LCD_LINE_2   1
#endif

   
/*========================* 
 * Setup for multitasking * 
 *========================*/
#if defined(MT)
# if MT == 0
#  undef MT
# else
#  define MULTITASKING 1
# endif
#endif

#ifndef TRUE
#define FALSE (0)
#define TRUE  (1)
#endif

#ifndef EXIT_FAILURE
#define EXIT_FAILURE  1
#endif
#ifndef EXIT_SUCCESS
#define EXIT_SUCCESS  0
#endif

#define QUOTE1(name) #name
#define QUOTE(name) QUOTE1(name)    /* need to expand name    */

#ifndef RT
# error "must define RT"
#endif

#ifndef MODEL
# error "must define MODEL"
#endif

#ifndef NUMST
# error "must define number of sample times, NUMST"
#endif

#ifndef NCSTATES
# error "must define NCSTATES"
#endif

#ifndef SAVEFILE
# define MATFILE2(file) #file ".mat"
# define MATFILE1(file) MATFILE2(file)
# define MATFILE MATFILE1(MODEL)
#else
# define MATFILE QUOTE(SAVEFILE)
#endif

#define RUN_FOREVER -1.0

#define EXPAND_CONCAT(name1,name2) name1 ## name2
#define CONCAT(name1,name2) EXPAND_CONCAT(name1,name2)
#define RT_MODEL            CONCAT(MODEL,_rtModel)



/*
 *********************************************************************************************************
 *    CONSTANTS
 *********************************************************************************************************
 */



/*
 *********************************************************************************************************
 *    MODULE GLOBAL VARIABLES
 *********************************************************************************************************
 */

/*
 * freePort communication admin variables ( initialised in mc_main->Init_ComVars() )
 */
myUsrBuf               *freecomTelBuf[MAX_FREECOM_CHANNELS];


/*
 * radioComm communication admin variables ( initialised in mc_main->Init_ComVars() )
 */
#if (HAS_RFCOMMS > 0)
myUsrBuf               *radiocomTelBuf[MAX_RADIOCOM_CHANNELS];
#endif


/*
 * error messages on the on-board LCD display
 */
#if LCDUSE4ERRORS == 1
static char_T           myLCDtxt[16]             = "                ";
const  char_T          *myPtr                    = MODELSTR;
#endif


/* 
 * defining macro RUN_IMMEDIATELY causes the code 
 * to run immediately, i. e. withour waiting for a start message from the host
 *
 * flag 'RunningAfterPowerUpReset = 1' indicates that this is the 'first run' 
 * following a power-up reset
 */
#if RUN_IMMEDIATELY == 1
static uint_T           RunningAfterPowerUpReset = 1;
#endif

/*
 * flag for delaying controller shutdown upon receiving TERMINATING signal;
 * 'mdlShutDwnComplete' is set to 'true' at the end of the terminating section of 'model_run';
 * 'mdlShutDwnComplete' is set back to 'false' upon entering function 'model_init'
 */
//static boolean_T        mdlShutDwnComplete;


/* 
 * function 'rt_InitInfAndNaN' sets constants rtInf, rtMinusInf as well as rtNaN. This function
 * is generated by 'genrtnonfinite.tlc' - we don't use this at the momemt (fw-04-10).
 *
 * Consequence:
 * Functions rtIsInf (double) / rtIsInfF (float) / rtIsNan (double) / rtIsNanF (double)
 * are currently not supported
 */
#ifdef ERASE
const real_T            rtInf                    = 0x7f800000;
const real_T            rtMinusInf               = 0xff800000;
const real_T            rtNaN                    = 0x7fffffff;
#endif


/*
 * model info
 */
static RT_MODEL        *S;


/* controls the reinitialization of the static memory manager (see: mem_mgr.c)  -  fw-07-07 */
uint_T                  reInitMemory;


/* 
 * flag 'HostIsAlive' is reset to TRUE with every properly received ACK_PACKET;
 * the flag is set to FALSE when the target buffer is full (-> most likely cause: host inactive)
 *
 * can be used to stop SL from storing process data in buffer 'circBuf' while 
 * the host is incative - that way, outdated process data is not collected.
 *
 * (see: mc_main::model_init, mc_main::rt_OneStep, ext_serial_utils.c and updown.c)
 */
#ifdef HOSTALIVECHECK
boolean_T               HostIsAlive;
#endif


/* SL runtime parameters (see grt_main.c)  --  currently not used (fw-05-10) */
#ifdef ERASE
static struct {

    int_T          stopExecutionFlag;
    int_T          isrOverrun;
    int_T          overrunFlags[NUMST];
    const char_T  *errmsg;
    
} GBLbuf;
#endif


/* 
 * development stage:
 * determine data type sizes on the micro.
 * --> use map file to inspect these
 *
 *
 * mc9s12 / CodeWarrior:
 *
 * ------- ROM-ADDRESS: 0x7C54 ---- RAM-ADDRESS: 0x1000 ---- SIZE       1 ---
 * Name of initialized Object : myChar
 * FF
 * ------- ROM-ADDRESS: 0x7C55 ---- RAM-ADDRESS: 0x1001 ---- SIZE       2 ---
 * Name of initialized Object : myInt
 *  FFFF
 * ------- ROM-ADDRESS: 0x7C57 ---- RAM-ADDRESS: 0x1003 ---- SIZE       4 ---
 * Name of initialized Object : myLong
 *  FFFFFFFF
 * ------- ROM-ADDRESS: 0x7C5B ---- RAM-ADDRESS: 0x1007 ---- SIZE       4 ---
 * Name of initialized Object : myFloat
 *  BF8CCCCD
 * ------- ROM-ADDRESS: 0x7C5F ---- RAM-ADDRESS: 0x100B ---- SIZE       4 ---
 * Name of initialized Object : myDouble
 *  BF8CCCCD
 * ------- ROM-ADDRESS: 0x7C8B ---- RAM-ADDRESS: 0x100F ---- SIZE       1 ---
 * Name of initialized Object : myChar_T
 *  FF
 * ------- ROM-ADDRESS: 0x7C8C ---- RAM-ADDRESS: 0x1010 ---- SIZE       2 ---
 * Name of initialized Object : myInt_T
 *  FFFF
 * ------- ROM-ADDRESS: 0x7C8E ---- RAM-ADDRESS: 0x1012 ---- SIZE       4 ---
 * Name of initialized Object : myLong_T
 * FFFFFFFF
 * ------- ROM-ADDRESS: 0x7C92 ---- RAM-ADDRESS: 0x1016 ---- SIZE       4 ---
 * Name of initialized Object : myReal_T
 *  BF8CCCCD
 */   

//#define CHECKDATATYPES
#ifdef CHECKDATATYPES

char     myChar   = -1;
int      myInt    = -1;
long     myLong   = -1;
float    myFloat  = -1.1;
double   myDouble = -1.1;

char_T   myChar_T = -1;
int_T    myInt_T  = -1;
int32_T  myLong_T = -1;
real_T   myReal_T = -1.1;

#endif /* CHECKDATATYPES */




/*
 *********************************************************************************************************
 *    FUNCTION PROTOTYPES
 *********************************************************************************************************
 */

/* enable a proper soft reset...  --  fw-07-07 */
extern tVOID     _Startup                     (tVOID);

extern RT_MODEL *MODEL                        (tVOID);
extern tVOID     MdlInitializeSizes           (tVOID);
extern tVOID     MdlInitializeSampleTimes     (tVOID);
extern tVOID     MdlStart                     (tVOID);
extern tVOID     MdlOutputs                   (int_T tid);
extern tVOID     MdlUpdate                    (int_T tid);
extern tVOID     MdlTerminate                 (tVOID);

#if NCSTATES > 0

/* model with at least one continuous state */
extern tVOID     rt_ODECreateIntegrationData  (RTWSolverInfo *si);
extern tVOID     rt_ODEUpdateContinuousStates (RTWSolverInfo *si);

#define rt_CreateIntegrationData(S)  \
        rt_ODECreateIntegrationData(rtmGetRTWSolverInfo(S));
#define rt_UpdateContinuousStates(S) \
        rt_ODEUpdateContinuousStates(rtmGetRTWSolverInfo(S));

#else

/* model with no continuous states */
#define rt_CreateIntegrationData(S)  \
        rtsiSetSolverName(rtmGetRTWSolverInfo(S),"FixedStepDiscrete");
#define rt_UpdateContinuousStates(S) \
        /* do nothing */

#endif





/*
 *********************************************************************************************************
 *    LOCAL FUNCTIONS
 *********************************************************************************************************
 */


/*
 *********************************************************************************************************
 * Function      : rtExtModeSingleTaskUpload()
 *
 * Description   : 'Inline function' (sort of... macro) - places data in ExtMode upload buffers
 * Arguments     : pointer to the model 'rtwStruct' (S)
 * Return values : none
 * Comment       : -
 *********************************************************************************************************
 */

#if EXT_MODE == 1
#define rtExtModeSingleTaskUpload(S)                            \
   {                                                            \
        int stIdx;                                              \
        rtExtModeUploadCheckTrigger(rtmGetNumSampleTimes(S));   \
        for (stIdx=0; stIdx<NUMST; stIdx++) {                   \
            if (rtmIsSampleHit(S, stIdx, 0 /*unused*/)) {       \
                rtExtModeUpload(stIdx,rtmGetTaskTime(S,stIdx)); \
            }                                                   \
        }                                                       \
   }
#else
#define rtExtModeSingleTaskUpload(S)   /* no ExtMode -> do nothing */
#endif


/*
 *********************************************************************************************************
 * Function      : rtOneStep()
 *
 * Description   : Compute model, one step  --  called by function 'model_run' (see below)
 * Arguments     : none
 * Return values : none
 * Comment       : the implementation for SINGLETASKING differs from that for MULTITASKING
 *********************************************************************************************************
 */

#if MULTITASKING == 0  /* SINGLETASKING */

/* Function: rtOneStep ========================================================
 *
 * Abstract:
 *      Perform one step of the model. This function is modeled such that
 *      it could be called from an interrupt service routine (ISR) with minor
 *      modifications.
 */
static tVOID rt_OneStep(tVOID) {

real_T   tnext;


    /*
     * In a multi-tasking environment, this would be removed from the base rate
     * and called as a "background" task.
     *
     * The following code section must never be called from within the ISR / 
     * foreground task!!  (See .../docs for a detailed analysis)
     * 
     * fw-08-10
     */
    #ifdef MUST_NEVER_BE_PART_OF_THE_FOREGROUND_TASK
    if (!startModel) {
    
        PRINT_DEBUG_MSG_LVL1_Raw("^");

        rtExtModeOneStep(rtmGetRTWExtModeInfo(S),
                         rtmGetNumSampleTimes(S),
                         (boolean_T *)&rtmGetStopRequested(S));

        PRINT_DEBUG_MSG_LVL1_Raw("°");
        
    }
    #endif /* MUST_NEVER_BE_PART_OF_THE_FOREGROUND_TASK */


    /* set stop time for solver (next sample hit or '-1' for 'RUN_FOREVER') */
    tnext = rt_SimGetNextSampleHit();
    rtsiSetSolverStopTime(rtmGetRTWSolverInfo(S), tnext);


    /* compute model outputs */
    MdlOutputs(0);


    /*
     * HOSTALIVECHECK is no longer used.
     *
     * fw-08-10
     */
    #ifdef HOSTALIVECHECK
    if(HostIsAlive) {

        /* 
         * make the call to 'rtExtModeSingleTaskUpload' (place data points in circular ExtMode buffer, 
         * see updown.c) depend on the current state of the host: HostIsAlive is set to FALSE when the 
         * circBuf buffer (updown.c) is full and reset to TRUE when a valid ACK_PACKET has been received 
         * (see ext_serial_utils.c)
         *
         * fw-07-07
         */
        rtExtModeSingleTaskUpload(S);

    }
    #else

    /* place new data points in the circular ExtMode buffer (see updown.c) */
    rtExtModeSingleTaskUpload(S);

    #endif  /* HOSTALIVECHECK */


    /* compute model state update */
    MdlUpdate(0);


    /* update continuous states (if any) */
    rt_SimUpdateDiscreteTaskSampleHits(rtmGetNumSampleTimes(S),
                                       rtmGetTimingData(S),
                                       rtmGetSampleHitPtr(S),
                                       rtmGetTPtr(S));

    if (rtmGetSampleTime(S, 0) == CONTINUOUS_SAMPLE_TIME) {

        rt_UpdateContinuousStates(S);

    }


    /* ExtMode: need to check for scope trigger events */
    #if EXT_MODE == 1
    rtExtModeCheckEndTrigger();
    #endif


}  /* end rtOneStep  (SINGLETASKING) */


#else /* MULTITASKING */


# if TID01EQ == 1
#  define FIRST_TID 1
# else
#  define FIRST_TID 0
# endif

/* Function: rtOneStep ========================================================
 *
 * Abstract:
 *      Perform one step of the model. This function is modeled such that
 *      it could be called from an interrupt service routine (ISR) with minor
 *      modifications.
 *
 *      This routine is modeled for use in a multitasking environment and
 *    therefore needs to be fully re-entrant when it is called from an
 *    interrupt service routine.
 *
 * Note:
 *      Error checking is provided which will only be used if this routine
 *      is attached to an interrupt.
 *
 */
static tVOID rt_OneStep(tVOID) {

int_T     i;
real_T    tnext;
int_T    *sampleHit = rtmGetSampleHitPtr(S);


#error MULTITASKING currently not supported (fw-08-10)

    /*
     * In a multi-tasking environment, this would be removed from the base rate
     * and called as a "background" task.
     *
     * The following code section must never be called from within the ISR / 
     * foreground task!!  (See .../docs for a detailed analysis)
     * 
     * fw-08-10
     */
    #ifdef MUST_NEVER_BE_PART_OF_THE_FOREGROUND_TASK
    if (!startModel) {
    
        PRINT_DEBUG_MSG_LVL1_Raw("^");

        rtExtModeOneStep(rtmGetRTWExtModeInfo(S),
                         rtmGetNumSampleTimes(S),
                         (boolean_T *)&rtmGetStopRequested(S));

        PRINT_DEBUG_MSG_LVL1_Raw("°");
        
    }
    #endif /* MUST_NEVER_BE_PART_OF_THE_FOREGROUND_TASK */



    /***********************************************
     * Update discrete events                      *
     ***********************************************/
    tnext = rt_SimUpdateDiscreteEvents(rtmGetNumSampleTimes(S),
                                       rtmGetTimingData(S),
                                       rtmGetSampleHitPtr(S),
                                       rtmGetPerTaskSampleHitsPtr(S));
                                       
    rtsiSetSolverStopTime(rtmGetRTWSolverInfo(S), tnext);
    for (i = FIRST_TID + 1; i < NUMST; i++) {

        if (sampleHit[i] && GBLbuf.eventFlags[i]++) {

            GBLbuf.isrOverrun--; 
            GBLbuf.overrunFlags[i]++;    /* Are we sampling too fast for */
            GBLbuf.stopExecutionFlag=1;  /*   sample time "i"?           */

            return;

        }

    }


    /*******************************************
     * Step the model for the base sample time *
     *******************************************/
    MdlOutputs(FIRST_TID);


    rtExtModeUploadCheckTrigger(rtmGetNumSampleTimes(S));
    rtExtModeUpload(FIRST_TID, rtmGetTaskTime(S, FIRST_TID));


    MdlUpdate(FIRST_TID);


    if (rtmGetSampleTime(S, 0) == CONTINUOUS_SAMPLE_TIME) {

        rt_UpdateContinuousStates(S);

    } else {

        rt_SimUpdateDiscreteTaskTime(rtmGetTPtr(S), rtmGetTimingData(S), 0);

    }


    #if FIRST_TID == 1
    rt_SimUpdateDiscreteTaskTime(rtmGetTPtr(S), rtmGetTimingData(S), 1);
    #endif


    /************************************************************************
     * Model step complete for base sample time, now it is okay to          *
     * re-interrupt this ISR.                                               *
     ************************************************************************/


    /*********************************************
     * Step the model for any other sample times *
     *********************************************/
    for (i = FIRST_TID + 1; i < NUMST; i++) {

        /* If task "i" is running, don't run any lower priority task */
        //if (GBLbuf.overrunFlags[i]) return;

        //if (GBLbuf.eventFlags[i]) {
        //    GBLbuf.overrunFlags[i]++;

        MdlOutputs(i);

        rtExtModeUpload(i, rtmGetTaskTime(S, i));

        MdlUpdate(i);

        rt_SimUpdateDiscreteTaskTime(rtmGetTPtr(S), rtmGetTimingData(S), i);

        // modified grt_main.c  (fw-06-07)
        //            /* Indicate task complete for sample time "i" */
        //            GBLbuf.overrunFlags[i]--;
        //}

    }

    rtExtModeCheckEndTrigger();

} /* end rtOneStep */

#endif /* MULTITASKING */


/*
 *********************************************************************************************************
 * Function      : model_init()
 *
 * Description   : initialize model
 * Arguments     : none
 * Return values : none
 * Comment       : also initializes SCIx and the External Mode interface (if used)
 *********************************************************************************************************
 */

static tVOID model_init(tVOID) {

// local function name... debugging only
DEFINE_DEBUG_FNAME("model_init")

const char_T  *status;
real_T         finaltime = -2.0;


    /* indicate that model shutdown phase has not yet been completed */
    //mdlShutDwnComplete = true;


    /************************
     * Initialize the model *
     ************************/

    /*
     * Functions rtIsInf (double) / rtIsInfF (float) / rtIsNan (double) / rtIsNanF (double)
     * are currently not supported  -->  initialization via 'rt_initInfAndNan' not required.
     *
     * fw-04-10
     */
    //rt_InitInfAndNaN(sizeof(real_T));

    S = MODEL();

    if (rtmGetErrorStatus(S) != NULL) {

        abort_LED(97);

    }

    if (finaltime >= 0.0 || finaltime == RUN_FOREVER) {
    
        rtmSetTFinal(S,finaltime);
        
    }

    MdlInitializeSizes();
    MdlInitializeSampleTimes();

    status = rt_SimInitTimingEngine( rtmGetNumSampleTimes(S),
                                     rtmGetStepSize(S),
                                     rtmGetSampleTimePtr(S),
                                     rtmGetOffsetTimePtr(S),
                                     rtmGetSampleHitPtr(S),
                                     rtmGetSampleTimeTaskIDPtr(S),
                                     rtmGetTStart(S),
                                    &rtmGetSimTimeStep(S),
                                    &rtmGetTimingData(S));

    if (status != NULL) {

        abort_LED(98);

    }

    rt_CreateIntegrationData(S);


    /* initialise serial interface, enable buffering and set userData flag 'waitForStartMsg' to TRUE */
    #if EXT_MODE == 1
    PRINT_DEBUG_MSG_LVL1("MODEL initialised, initialising External Mode interface.");
    PRINT_DEBUG_MSG_NL1;
    rt_ExtModeInit();
    #endif


    #if RUN_IMMEDIATELY == 1
    /* 
     * determine startup behaviour (direct / wait for start msg)
     * fw-10-05
     */
    if (RunningAfterPowerUpReset) {

        /* first run */
        #if EXT_MODE == 1
        ExtSetWaitForStartPkt(FALSE);
        #endif

        /* reset flag */
        RunningAfterPowerUpReset = 0;

    } else {

        /* all subsequent runs */
        
        /* this is only reached if the user has clicked 'stop' */
        #if EXT_MODE == 1
        ExtSetWaitForStartPkt(TRUE);
        #endif

    }
    #endif


    #if EXT_MODE == 1
    /*
     * Pause until receive model start message.
     */

    PRINT_DEBUG_MSG_LVL1("Waiting for START_PACKAGE...");
    PRINT_DEBUG_MSG_NL1;

    rtExtModeWaitForStartPkt(rtmGetRTWExtModeInfo(S),
                             rtmGetNumSampleTimes(S),
                             (boolean_T *)&rtmGetStopRequested(S));
    #endif


    #ifdef HOSTALIVECHECK
    /* first handshake done, initialize circBuf buffer control variable 'HostIsAlive' (TRUE) */
    HostIsAlive = TRUE;
    #endif


    PRINT_DEBUG_MSG_LVL1("START_PACKAGE received. Starting Model...");
    PRINT_DEBUG_MSG_NL1;
    MdlStart();

}  /* end model_init */



/*
 *********************************************************************************************************
 * Function      : model_clean()
 *
 * Description   : clean up and shut down External Mode interface
 * Arguments     : none
 * Return values : none
 * Comment       : -
 *********************************************************************************************************
 */

#if EXT_MODE == 1
static tVOID model_clean(tVOID) {

    /*
     * Cleanup and exit
     */

    rtExtModeShutdown(rtmGetNumSampleTimes(S));

    if (rtmGetErrorStatus(S) != NULL) {

        abort_LED(98);

    }

    /* usually empty... */
    MdlTerminate();
    
}  /* end model_clean */
#endif



/*
 *********************************************************************************************************
 * Function      : model_run()
 *
 * Description   : call upon rt_OneStep (see above) to run the model code for one step
 * Arguments     : none
 * Return values : none
 * Comment       : called by the base rate task / core timer ISR
 *********************************************************************************************************
 */

static tVOID model_run(tVOID) {

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("model_run")


    PRINT_DEBUG_MSG_LVL1_Raw("<ISR");

    /* modification of grt_main  (FW-02-03) */
    if ((rtmGetStopRequested(S) == FALSE) && 
        ((rtmGetTFinal(S) == RUN_FOREVER) || 
        (rtmGetTFinal(S) - rtmGetT(S) > rtmGetT(S) * DBL_EPSILON))) {

        rt_OneStep();

    } else {

        /* 
         * stop execution of RT model code,
         * keep core timer running (comms timeouts, etc.)
         */
        CoreTimer_ClrPldFnc;
        //CoreTimer_Stop;  

        // now conditional... fw-02-03
        if (!rtmGetStopRequested(S)) {

            /* Execute model last time step */
            rt_OneStep();

        }

        #if EXT_MODE == 1
        /* 
         *  reset flag 'startModel' to exit from while loop in main() 
         *  and to prevent the ISR from re-enabling itself  --  fw-07-07
         */
        startModel = FALSE;
        #endif /* EXT_MODE */

        /* indicate that model shutdown phase is complete */
        //mdlShutDwnComplete = true;

        PRINT_DEBUG_MSG_LVL1("RT processes stopped ---------------------------------");
        PRINT_DEBUG_MSG_NL1;
        PRINT_DEBUG_MSG_LVL1("Flag 'startModel' reset to FALSE");
        PRINT_DEBUG_MSG_NL1;

    }

    PRINT_DEBUG_MSG_LVL1_Raw(">");

}


/*
 *********************************************************************************************************
 * Function      : init_micro()
 *
 * Description   : initialize PLL, a few ports (LEDs) and SCI0 for debugging (if used)
 * Arguments     : none
 * Return values : none
 * Comment       : -
 *********************************************************************************************************
 */

static tVOID init_micro(tVOID) {

    /* set system clock to nominal operating frequency (24 MHz) */
    PLL_Init();

    /* enable all LEDs on the Dragon 12 rapid prototyping board */
    #if ((TARGET_BOARD == BSP_DRAGON12PLUS) || (TARGET_BOARD == BSP_DRAGON12))
    /* Dragon-12plus and Dragon-12 */
    DDRB  = 0xff;              /* set PORTB as output (LEDs) */
    PORTB = 0x00;              /* all LEDs off  */
    #endif

    /* enable 7-segment display on the BSP_MINIDRAGONPLUS+ rapid prototyping board */
    #if ((TARGET_BOARD == BSP_MINIDRAGONPLUS) | (TARGET_BOARD == BSP_MINIDRAGONPLUS2))
    /* BSP_MINIDRAGONPLUS+ */
    DDRH = 0xff;               /* set port H as output (7-segment display) */
    PTH  = 0x00;               /* all segments off  */
    #endif

    /* enable display of communications state variables on port T   --   fw-07-07 */
    #if COMMSTATE_ON_PTT == 1
    DDRT = 0xff;   
    PTT  = 0x00;   
    #endif

    /* make timing signal pin an output */
    #ifdef TIMING
    setCycTiPinOutput;
    #endif

    /* if errors are to be displayed on the LCD display... */
    #if LCDUSE4ERRORS == 1
    LCD_init();
    #endif

    // debug target in RT -> debug log through the vacant SCI0 (release mode)
    #if (DEBUG_MSG_LVL > 0)
    SCI0_Init(BAUDRATE);
    #endif

    /* say hello...       */
    blinky(10000);


    /*======================*
     * Development stage... *
     *======================*/

    #ifdef CHECKDATATYPES
    /* development stage: find out about data type sizes on the micro...
     * stop optimizer from eliminating these global variables
     */

    myChar++;
    myInt++;
    myLong++;
    myFloat++;
    myDouble++;

    myChar_T++;
    myInt_T++;
    myLong_T++;
    myReal_T++;

    #endif /* CHECKDATATYPES */

}


/*
 *********************************************************************************************************
 * Function      : dispOnLDC()
 *
 * Description   : display a line of text on the LCD display - the text can be at most 16 characters long
 * Arguments     : pointer to the line of text to be displayed, line number (0 or 1)
 * Return values : none
 * Comment       : -
 *********************************************************************************************************
 */

#if LCDUSE4ERRORS == 1
static tVOID dispOnLDC(const char_T *zeLine, int_T zeLineNb) {

uint_T    i;

    /* copy up to 16 characters to the LCD display buffer */
    i = 0;
    while (zeLine[i] != 0 && i < 16) {

        /* copy current character to display buffer */
        myLCDtxt[i] = zeLine[i];
        
        /* next character */
        i++;

    }

    /* display line on LCD line 'lineNb' */
    writeLine(myLCDtxt, zeLineNb);

}
#endif


/*
 *********************************************************************************************************
 *    PUBLIC FUNCTIONS
 *********************************************************************************************************
 */


/*
 *********************************************************************************************************
 * Function      : coreTiPldFnc
 *
 * Description   : Payload function of core timer 
 * Arguments     : none
 * Return values : none
 * Error memory  : none
 *********************************************************************************************************
 */

tVOID coreTiPldFnc(tVOID) {
  
    /* user code to be run by the core timer ISR */
    
    /* only run the actual model code once 'startModel' has been set */
    #if EXT_MODE == 1
    if (startModel == TRUE) {
    #endif

        /* set cyctime_pin high (timing -> scope) */
        #ifdef TIMING
        setCycTiPin;
        #endif

        /* run model code */
        model_run();

        /* reset cyctime_pin (timing -> scope) */
        #ifdef TIMING
        clrCycTiPin;
        #endif
        
    #if EXT_MODE == 1
    }  /* startModel */
    #endif

}


/*
 *********************************************************************************************************
 * Function      : Init_ComVars()
 *
 * Description   : Initialise the communication variables used by the FreePort communication system
 *                 as well as the radio communication system
 * Arguments     : none
 * Return values : none
 * Comment       : -
 *********************************************************************************************************
 */

static tVOID Init_ComVars(tVOID) {

    int_T i;


    /* FreePort comms: reset pointers to all freecom buffers */
    for (i = 0; i < MAX_FREECOM_CHANNELS; i++) {

        /* initialise user communication buffer pointers, flags, buffer sizes and the txd queue with default values */
        freecomTelBuf[i] = NULL;

    }

    #if (HAS_RFCOMMS > 0)
    /* RF comms: reset pointers to all radiocom buffers */
    for (i = 0; i < MAX_RADIOCOM_CHANNELS; i++) {

        /* initialise RF communication buffer pointers, flags, buffer sizes and the txd queue with default values */
        radiocomTelBuf[i] = NULL;

    }
    #endif

}


/*
 *********************************************************************************************************
 * Function      : AllocateUserBuffer()
 *
 * Description   : Allocate buffers for freeport communication  - called upon from within mdlStart
 *                 as well as from within modules freePortComms_rxd and freePortComms_txd
 * Arguments     : channel        ...to be initialized,
 *                 bufsize        ...bytes are reserved as communication buffer for this channel,
 *                 data_type_len  ...channel data type length: 1, 2, 4 (remains invariant during operation)
 * Return values : pointer to the buffer admin structure of the initialized channel
 * Comment       : -
 *********************************************************************************************************
 */

myUsrBuf *AllocateUserBuffer(uint_T channel, uint16_T bufsize, uint8_T data_type_len) {

uint8_T           *buf;
static myUsrBuf   *admin  = NULL;
int_T              i;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("AllocateUserBuffer")


    /* allocate memory for admin structure of this instance's data buffer */
    PRINT_DEBUG_MSG_LVL3("Allocating memory for the admin structure of the user/freeport buffer");
    PRINT_DEBUG_MSG_NL3;
    if ((admin = (myUsrBuf*)calloc(1, sizeof(myUsrBuf))) == NULL) {

        return NULL;

    }

    /* 
     * allocate memory for the buffer itself (buf_size '+ 4'  ->  telegram size, channel number, '0 0' [reserved])
     * the additional '+3' has been introduced to allow safe byte-swapping -- required on the 9S12...
     * (the order of every group of 4 bytes gets reversed -> uint8_T transmissions might just end up on '+1' -> '+3' makes it dword aligned)
     */
    PRINT_DEBUG_MSG_LVL3("Allocating memory for the actual user/freeport buffer");
    PRINT_DEBUG_MSG_NL3;
    if ((buf = (uint8_T*)calloc(bufsize + 4 + 3, sizeof(uint8_T))) == NULL) {

        return NULL;

    }

    /* clear buffer */
    for (i = 0; i < (bufsize + 4 + 3); i++) {

        buf[i] = 0;

    }

    /* store pointer to buf in the admin structure */
    admin->buf = buf;

    /* store size of the actual data buffer */
    admin->buf_size = bufsize;

    /* initialise the access_count field */
    admin->access_count = 1;

    /* initialise the buffer_full flag */
    admin->buffer_full = 0;


    /* initialise buffer */

    /* set first field of the buffer to the number of bytes per user telegram (remains invariant)... */
    buf[0] = (uint8_T)(bufsize + 4);

    /* set second field of the buffer to the channel number (remains invariant)... */
    buf[1] = (uint8_T)channel;

    /* set third field of the buffer to the channel data type length: 1, 2, 4) (remains invariant)... */
    buf[2] = data_type_len;

    /* ... and clear the reserved byte (buf[3]) as well as the local data buffer */
    (tVOID)memset(&buf[3], 0, bufsize + 1);


    /* return access pointer */
    return admin;

}



/*
 *********************************************************************************************************
 * Function      : main()
 *
 * Description   : called by startup code '_Startup'
 * Arguments     : none
 * Return values : none
 * Comment       : main entry after RESET
 *********************************************************************************************************
 */

tVOID main(tVOID) {

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("main")


    /* initialise some essential registers, install interrupts... */
    /* this also initialized SCI0, if macro DEBUG_MSG_LVL is > 0 */
    init_micro();


    /* display the name of the current model on the LCD display */
    #if LCDUSE4ERRORS == 1
    dispOnLDC(myPtr, LCD_LINE_1);
    #endif    


    /* forever... */
    /* technically no longer necessary... using call to _Startup to perform a software reset  --  fw-07-07 */
    while(1) {

        /* force re-initialization of static memory manager  -  fw-07-07 */
        reInitMemory = 1;

        /* initialise user communication variables (ExtMode / FreePort) */
        Init_ComVars();

        #if ((HAS_TIMERBLOCKS > 0) | (HAS_RFCOMMS > 0))
        /* initialize ECT timer unit (base period defined by macro TIMER_BASEPERIOD) */
        /* this needs to be done before model_init  (fw-09-06)                       */
        ECT_Init();
        ECT_Start();
        #endif

        #if EXT_MODE == 1
        #if LCDUSE4ERRORS == 1
        dispOnLDC("-> not connected", LCD_LINE_2);
        #endif    
        #endif    


        /*
         * initialize core timer (timer T7 / RTI)
         *
         * - stop core timer (just in case)
         * - remove user payload function (just in case)
         * - initialize core timer, default 'sampleTime' (each tick)
         * - start timer (SCIx timeout mechanism active)
         *
         * note: The payload function (model code) is not yet enabled.
         */
        PRINT_DEBUG_MSG_LVL1("Initializing core timer -------------------------------");
        PRINT_DEBUG_MSG_NL1;
        CoreTimer_Stop;
        CoreTimer_ClrPldFnc;
        CoreTimer_Init(0);
        CoreTimer_Start;


        /* allow interrupts, so comms can take place */
        CPL_ENABLE_IRQS


        /* initialize model & enable IRQs (to allow comms via SCIx) */
        PRINT_DEBUG_MSG_LVL1("Initializing model ------------------------------------");
        PRINT_DEBUG_MSG_NL1;
        model_init();
        
        
        /* 
         * configure core timer to elapse at 'sampleTime' seconds
         * ... can only be done after 'model_init'
         */
        CoreTimer_SetSmplTime(rtmGetStepSize(S));


        /* 
         * install core timer payload function - model code running
         */
        PRINT_DEBUG_MSG_LVL1("Starting RT processes ---------------------------------");
        PRINT_DEBUG_MSG_NL1;
        CoreTimer_SetPldFnc(coreTiPldFnc);


        /* indicate... model running */
        blinky(10000);

        #if LCDUSE4ERRORS == 1
        dispOnLDC("-> model running", LCD_LINE_2);
        #endif    


        #if EXT_MODE == 1

            /*
             * 'background task'
             */
            while (startModel) {

                /* run packet server (command handling) and upload server (data upload) */
                rtExtModeOneStep(              rtmGetRTWExtModeInfo(S), 
                                               rtmGetNumSampleTimes(S), 
                                  (boolean_T*)&rtmGetStopRequested(S)   );

            }


            /* 
             * system shut down 
             * (external mode, model)
             */
            model_clean();


            /* stop ECT (if used) */
            #if HAS_TIMERBLOCKS > 0
            ECT_Stop();
            #endif

            
            /* all done - ready to reboot */
            blinky(100000);
            
            /* wait for shutdown to complete */
            //while (mdlShutDwnComplete == false);

            /* software reset... */
            _Startup();
            

        #else  /* EXT_MODE */
        

            /*
             * 'background task' (empty)
             */
            while(1);


        #endif  /* EXT_MODE */

    } /* end : forever... */

}  /* end : main */
