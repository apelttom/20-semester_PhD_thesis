\chapter{Background and State-of-the-Art}
\label{chap.stateoftheart}
% This chapter, if desired, can be split into two chapters
% - Theoretical Background
% - Previous Results and Related Work

In the last decade we have seen a dramatic decrease in the cost of certain computation technologies and such phenomenon gave a birth of a new family of embedded control systems that are much better prepared for fluent, realistic interaction with the continuous physical world around them. For systems that combine physical world around us with the world of cybernetics, we use a term cyber-physical system. Although certain forms of CPS have been in industril use since 1980s, only recently has the technology for processors, wireless communication, and sensors matured to allow the production of components with impressive capabilities at a low cost.[Rajeev Alur Principles of CPS] 

Advance in the field of Cyber-physical systems will bring us closer to usage of high-speed, low-cost, and real-time embedded computers in technologies like electric networks that employ advanced monitoring [Smart Grids: A Cyber–Physical Systems Perspective, By Xinghuo Yu and Yusheng Xue], networked autonomous vehicles [E. A. Lee, "Cyber Physical Systems: Design Challenges," 978-0-7695-3132-8] or prosthesis like neural controlled artificial leg [On Design and Implementation of Neural-Machine Interface for Artificial Legs, Xiaorong Zhang, Yuhong Liu]. CPS are a research priority for both, government agencies (National Science foundation) and industry (automotive, avionics, medical devices).

\section{Cyber-Physical Systems}

The concept of a cyber-physical system is a generalization of embedded systems.[Rajeev Alur Principles of CPS] An embedded system consists of hardware and software integrated within a mechanical or and electrical system designed for a specific purpose. CPS consist of a computational unit, sensors, actuators and a physical world which it must observe and react on it. In a CPS the controller consists of discrete software concurrent components, operating in multiple modes of operation, interacting with the continuosly evolving physical environment. Examples of on-board sensors include a global positioning system (GPS) receiver, a camera or an infrared thermal sensor.[Rajeev Alur Principles of CPS] CPS are reactive systems which interact with its environment in an ongoing manner. There is an endless loop of data collection and input evaluation throughout the time.

TODO Chart of CPS

In comparison to the traditional software development architecture, the creation of CPS differs in the emphasis on the security, confidence, reliability and performance of the system. CPS are often used in areas with many safety requirements (medicine [cite S-TaLiRo insulin pump], automotive [cite EMB paper], civil engineering [cite some smarthome papers], avionics, etc.). Apart from embedded systems, CPS will not be operating in a controlled environments and must be robust to unexpected conditions and adaptable to subsystem failures. [E. A. Lee, Cyber Physical Systems: Design Challenges, 2008,978-0-7695-3132-8]. An example of such systems is an autopilot system used on Airbus aircraft. It is a device used to guide an aircraft without direct assistance from the pilot. Modern autopilots are capable of controlling every part of the flight from just after take-off to landing and are normally integrated with the flight management system.

\subsection{Reactive Computation}

CPS are intended to seamlessly interact with the physical world around in an infinite feedback loop. Such real-time computing can be very challenging, because it usually consist of processing huge amount of inputs and delivering immediate reactions. The traditional computing device process an input and produces an output. An example is a program that process an unsorted list of numbers and returns a sorted list (based on given criteria, e.g. in an ascending order).

A reactive system, in contrast, interacts with its environment in an ongoing manner via inputs and outputs. As a typical example of reactive computation consider a program for a cruise controller in a car. CPS are reactive systems.[Rajeev Alur Principles of CPS]

The design of a complex cyber-physical system — especially one with heterogeneous subsystems distributed across networks — is a demanding task. Commonly employed design techniques are sophisticated and include mathematical modeling of physical systems, formal models of computation, simulation of heterogeneous systems, software synthesis, verification, validation, and testing.[J. C. Jensen, D. H. Chang and E. A. Lee, A model-based design methodology for cyber-physical systems,978-1-4244-9538-2].

Embedded system is usually constructed from the physical plant and the controller module. The controller contains specific algorithm, designed for capabilities and resources of given embedded system. In industry production area a Model-driven development paradigm has been deployed and successfully tested for development of embedded systems. Unfortunately when we move from simple programs to more complex software systems and particularly to cyber-physical systems, former design techniques and tools are no longer applicable.

During the process of creation and implementation of an autopilot system, we expect a high level of assurance in the correct behavior of the system. If it would be the other way around, any error can lead to unacceptable consequences such as losses of lifes. Systems where safety requirements have higher priority than other design objectives such as performance and developement cost are called safety-critical. CPS generally fit into this cathegory. That is why ensurance of a system's corectness during design is of utmost importance and sometimes even mandatory because of goverment regulations.


Former approach of system developement is divided into several phases: design, implementation, testing and validation. More suitable and practial approach is to write mathematically precise requirements of the desired system, design models od system components and using analysis tools check if the system meets the requirements. Usage of formal models and verification is fitting for the area of safety-critical applications. 

And that is why a different paradigm for developing CPS was created. It is called Model-Based Design and it is increasingly adopted by industry.[J. C. Jensen, D. H. Chang and E. A. Lee, A model-based design methodology for cyber-physical systems,978-1-4244-9538-2]

\section{Model-Based Design}

The goal of modeling in system design is to provide mathematical abstractions to manage the complexity of design. In the context of reactive systems, the basic unit of modeling is a component that interacts with its environment via inputs and outputs.[Rajeev Alur Principles of CPS] What exactly is a model? A model is defined as a small object, usually built to scale, that represents in detail another, often larger object. A schematic description of a system, theory, or phenomenon that accounts for its known or inferrend properties and may be used for further study of its characteristics. [American Heritage Dictionary]

In their work Jensen et al. 2011  [J. C. Jensen, D. H. Chang and E. A. Lee, A model-based design methodology for cyber-physical systems,978-1-4244-9538-2] propose a 10-step methodology for developing cyber-physical systems:

\begin{enumerate}
	\item State the problem
	\item Model physical processes
	\item Characterize the problem
	\item Derive a control algorithm
	\item Select models of computation
	\item Specify hardware
	\item Simulate
	\item Construct
	\item Synthesize software
	\item Verify, validate and test
\end{enumerate}

This approach helps designers break enormous task of creation of CPS into manageable iterations, which can be repeated if needed. Main goal is to identify any bugs or errors as soon as possible and preferably before the construction phase. For example we would like to design new experimental electro-mechanical braking system (EMBS) . Such system consists of an electric engine, a brake caliper, a brake disc and a wheel. TODO add figure The brake disc is connected to the wheel, so that contact between caliper and disc will result in vehicle deceleration. [Strathmann and Oehlerking in Verifying properties of an electro-mechanical braking system]. According to traditional design process, we would propose a system design, implement it in real life, test it manually or randomly and then launch pilot project. In case of such complicated device as EMBS conventional approach is unsatisfactory. How can we be sure whether the manually or randomly generated scenarios capture the worst-case conditions for the system under test? An alternative approach is to utilizea Model Based Development (MBD) framework and use the models to simulate the system and intelligently search for corner cases. [Tuncali, Fainekos, Functional Gradient Descent optimization for automatic test case generation for vehicle controllers] This way we use search-based methods to detect corner cases that violate the safety requirements. We refer to such process as falsification because these methods strive to generate counterexamples that disprove or falsify safety requirements. In case of our EMBS, an example of a safety reqirement could be formulated as: As soon as braking is requested, the contact between caliper and disc should occur within 23 ms.[Strathmann and Oehlerking in Verifying properties of an electro-mechanical braking system]

\section{Model-Based Testing}

Is it really so important to test and verify CPS? We can present a few examples when perfunctory testing led to a catastrophic failure:

\begin{enumerate}
	\item The Ariane 5 rocket exploded 36 seconds after the lift-of; the amount lost was of half a billion dollars. The failure was caused by an uncaught exception [https://esamultimedia.esa.int/docs/esa-x-1819eng.pdf]
	\item An error in the software of the baggage handling system delayed of 9 months the opening of the Denver airport, with a loss of 1.1 million dollars per day [http://www.eis.mdx.ac.uk/research/SFC/Reports/TR2002-01.pdf]
	\item Intel lost 475 million dollars for replacing Pentium II processors that had a faulty floting-point division unit [Khan, M. A., Ansari, A. Q. (2012). Handbook of Research on Industrial Informatics and Manufacturing Intelligence: Innovations and Solutions (pp. 1-662). Hershey, PA: IGI Global. doi:10.4018/978-1-4666-0294-6]
	\item Toyota recalled some vehicles in 2010 for a bug in the anti-lock brake software [https://instituteforpr.org/wp-content/uploads/JFGRA-InfoTrend-case-study-ver-2.pdf]
	\item Because of an error in the radiation therapy machine Therac-25, some patients were exposed to an overdose of radiation and six of them died [http://sunnyday.mit.edu/papers/therac.pdf]
\end{enumerate}

Generally software testing requires up to 50\% of software development costs and in case of safety-critical applications these costs are even higher. This can be reduced by automatization of test execution or test generation. An exhaustive testing is not feasible in practice and the input domain may be infinite (e.g. avionic system fed with input sequences). Since exhaustive testing is not feasible, we have to select a subset of inputs and that is why a test generation process for CPS is an active topic in an academic environment. [TODO citation]

White box testing considers the inner structure of a testing subject. The internal structure/design/implementation of the item being tested is known to the tester. This tecnique is widely used in software testing where the tester chooses inputs to exercise paths through the code and determines the appropriate outputs. Programming know-how and the implementation knowledge is essential. This method is named so because the software program, in the eyes of the tester, is like a white/transparent box; inside which one clearly sees.

Black box testing does not use information of the internal structure. It observes the testing item only through its interface and considers only the requirements of the system. Tests are only derived from the requirements. Model-Based testing (MBT) is a kind of black box testing. Inputs are applied to the testing item and the output is observed. The corectness of the output is checked with respect to the given expected output. When we are speaking about the safety requirements that describe the expected output, we refer to it as falsification. As stated above these methods attemp to generate counterexamples that disprove or falsify safety requirements, thus disprove the expected output.

We can identify the following families of modeling notations:

\subsubsection{Transition-based notations}

They describe transitions between states of the system. E.g. Finite-State Machine (FSM), Unified Modeling Language (UML) state machines, Statecharts, Labeled Transition Systems, etc.

\subsubsection{Input-domain notations}

They describe the inputs and their constraints. E.g. combinatorial testing, feature modeling.

\subsubsection{Pre/post notations}

They describe the system by means of some variables and operations. The models specify pre-conditions that must be satisfied before an operation and post-conditions that must be guaranteed after the operation execution. E.g. Java Modeling Language, Spec\#, etc.

\subsubsection{History-based notations}

They describe the allowable traces of the system behavior over time. They are good for describing the interactions among components. E.g. message-sequence charts, UML sequence diagrams, temporal logics.

\subsubsection{Functional notations}

They describe the model as a set of mathematical functions.

\subsubsection{Operational notations}

They describe system as a set of executing processes. E.g. process algebras, Petri nets, ASMs.

\subsubsection{Stochastic notations}

They describe a probabilistic model of the inputs of the system.

\subsubsection{Data-flow notations}

They model the flow of data (rather than control flow)

The model itself could contain errors. Test generation depends on the notation used. Some approaches are based on:

\begin{enumerate}
	\item exploration (simulation) of the model
	\item logical solvers (Boolean satisfiability (SAT) problem solvers)
	\item model checkers (SPIN, NuSMV, etc.) which check more complicated temporal properties
\end{enumerate}

\subsection{Model checking}

Model checking is an automated formal verification technique. It aims to discover whether an abstract description $\mathcal{M}$ of a system satisfies a property $\varphi$, i.e.,

\begin{equation}
	\mathcal{M} \models \varphi
\end{equation}

The technique explores the state space of $\mathcal{M}$ to check whether property $\varphi$ holds. State-of-the-art model checkers can handle state spaces of about $10^8$ to $10^9$ states with explicit state-space enumeration. Using clever algorithms and tailored data structures, larger state spaces ($10^20$ up to even $10^476$ states) can be handled for specific problems. [Christel Baier and Joost-Pieter Katoen. 2008. Principles of Model Checking (Representation and Mind Series). The MIT Press.]

TODO: figure of model checking

For modeling the system, we usually use higher level notations like FSM, UML statecharts, Simulink models, etc. If we are to use a model checking software, we must provide a translation from these higher level notations to the notation of the model checker. If a property $\varphi$ does not hold, the model checker returns a counterexample acting as witness of the violation.

\section{Safety requirements}

Test requirements can be generated from formal models. TODO collect all the examples of the requirements plus from the course at Matfyz the requirements collection and specification and all engineering process around the ccreation of a new model of a system.

\section{Metric Temporal Logic}

Temporal logics permit to describe properties refarding the evolution of the system over time. We can specify different kinds of properties:

\begin{itemize}
	\item Reachability (e.g. there exists a state in our EMBS in which the car decelerate)
	\item Safety (e.g. there exists no state in which the car brakes and after a certain period of time the car still moves)
	\item Liveness (e.g. if the car is stopped and accelerates and does not brake, it will eventually increase the speed)
\end{itemize}

Most popular temporal logics are Linear temporal logic (LTL) and Computation tree logic (CTL). Another....  Metric temporal logic

\section{Verification process}

The evaluation of whether or not a product, service or system complies with a regulation, requirement, specification, or imposed condition. [Barry W. Boehm (Ed.). 1989. Software Risk Management. IEEE Press, Piscataway, NJ, USA.]

%ij
\section{Previous Results and Related Work}
%