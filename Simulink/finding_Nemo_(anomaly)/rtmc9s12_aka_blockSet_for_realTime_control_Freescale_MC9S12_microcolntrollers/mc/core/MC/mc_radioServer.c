/**
 * Code to manage the server's radio transceiver.
 * See main.c for a simple example of a server application.
 *
 * Use at own risk, etc. Feel free to modify and distribute.
 *
 * @author Stephen Craig, 07/08/2006
 */

/* Model dependent constants -- generated by 'gen_mc_defines_h.m' */
#include "mc_defines.h"

/* HAS_RFCOMMS:  '0' : no RF communications, '1' : server, '2' : client, '3' : 'both' */
#if ((HAS_RFCOMMS == 1) | (HAS_RFCOMMS == 3))

/* ensure that SPI support is enabled */
#ifndef HAS_SPI
#define HAS_SPI    1
#endif


#include "mc_radioServer.h"        /* various macros etc */




//#include "bsp_sci0.h"             /* support for SCI0 */
#include "mc_spi.h"                /* support for SPI */
#include "bsp_sci.h"               /* low-level support for SCI0 */
#include "mc_rb.h"                 /* ring buffer implementation */


/* define a macro to set the current module state */
#define setState(s) tickCounter = 0, moduleState = s

 /* RF baud rate macro.
    Include the macro for 1 MBits (may be necessary for large ranges)
    Remove macro for 2 MBits */
    
// #define SLOW_RF_BAUD_RATE 

#define CE              PTM_PTM7   /* chip enable */
#define CE_DDR          DDRM_DDRM7 /* chip enable data direction */

/* macro used to print out some debug info */
// #define TO_DEBUG
// #define TO_DEBUG_ERROR_CONDITIONS

#ifdef TO_DEBUG
  #define TO_DEBUG_ERROR_CONDITIONS
#endif

#ifdef TO_DEBUG

/* when debugging, make the whole thing run as slow as possible */
#define TICK_PRESCALAR              0xffff
#define WAIT_FOR_ACK_TICK_COUNT     17

#else
#ifdef SLOW_RF_BAUD_RATE 
/* For 1MBits, nominal time between T~ and ACK is given by
    128 + 5 + 128 + 5 + 2*(33 + 33 + 4*(5 + 2 + PAYLOAD_LEN)) = 710us */
  #define TICK_PRESCALAR   (24*712/TIMER_PRESCALER)

/* If every packet fails, then MAX_RT will occur in
    (250*1 + 8*(5+2+PAYLOAD_LEN) + 138.5)*16 = 12712us = 16 ticks
   Make it 17 to be conservative */
  #define WAIT_FOR_ACK_TICK_COUNT     (17)

#else
/* For 2MBits, nominal time between T~ and ACK is given by
    128 + 5 + 128 + 5 + 1*(33 + 33 + 4*(5 + 2 + PAYLOAD_LEN)) = 488us */
  #define TICK_PRESCALAR   (24*490/TIMER_PRESCALER)

/* If every packet fails, then MAX_RT will occur in
    (250*1 + 4*(5+2+PAYLOAD_LEN) + 138.5)*16 = 8712us = 18 ticks
    Make it 19 to be conservative */ 
  #define WAIT_FOR_ACK_TICK_COUNT     (19)
#endif
#endif

/* To ensure the server has timed out, need to wait an extra two ticks.
   this is because the server's ticks could potentially be aligned to
   just miss the interrupt, and then just miss again on the other end. */
#define TIME_OUT_TICK_COUNT         (WAIT_FOR_ACK_TICK_COUNT + 2)

#define TICK_REGISTER   TC0
#define TICK_ENABLE     TIE_C0I     /* changed to timer channel 0, interrupt enable  -  fw-09-06 */
#define TICK_INTERRUPT  TFLG1_C0F
// RadioServer_OnTick

/* a delay is required for the client to enter receive mode */
#define WAIT_FOR_CLIENT_TICK_COUNT     1

#define ADDRESS_LENGTH       5  /* Address length (should be 5) */

/* define useful mnemonics */
/* these are all reads */
#define R_CONFIG          0x00     // Configuration Register
#define R_EN_AA           0x01     // Enable Auto Acknowledge
#define R_EN_RXADDR       0x02     // Enable RX Addresses
#define R_SETUP_AW        0x03     // Setup of Address Widths
#define R_SETUP_RETR      0x04     // Setup of Automatic Retransmission
#define R_RF_CH           0x05     // RF Channel
#define R_RF_SETUP        0x06     // RF Setup
#define R_STATUS          0x07     // Status
#define R_OBSERVE_TX      0x08     // Transmit Observe register
#define R_CD              0x09     // Carrier Detect
#define R_RX_ADDR_P0      0x0a     // Receive address data pipe 0
#define R_RX_ADDR_P1      0x0b     // Receive address data pipe 1
#define R_RX_ADDR_P2      0x0c     // Receive address data pipe 2
#define R_RX_ADDR_P3      0x0d     // Receive address data pipe 3
#define R_RX_ADDR_P4      0x0e     // Receive address data pipe 4
#define R_RX_ADDR_P5      0x0f     // Receive address data pipe 5
#define R_TX_ADDR         0x10     // Transmit address
#define R_RX_PW_0         0x11     // Number of bytes in RX payload for pipe 0
#define R_RX_PW_1         0x12     // Number of bytes in RX payload for pipe 1
#define R_RX_PW_2         0x13     // Number of bytes in RX payload for pipe 2
#define R_RX_PW_3         0x14     // Number of bytes in RX payload for pipe 3
#define R_RW_PW_4         0x15     // Number of bytes in RX payload for pipe 4
#define R_RW_PW_5         0x16     // Number of bytes in RX payload for pipe 5
#define R_FIFO_STATUS     0x17     // FIFO Status register

/* these are all writes */
#define W_CONFIG          0x20     // Configuration Register
#define W_EN_AA           0x21     // Enable Auto Acknowledge
#define W_EN_RXADDR       0x22     // Enable RX Addresses
#define W_SETUP_AW        0x23     // Setup of Address Widths
#define W_SETUP_RETR      0x24     // Setup of Automatic Retransmission
#define W_RF_CH           0x25     // RF Channel
#define W_RF_SETUP        0x26     // RF Setup
#define W_STATUS          0x27     // Status
#define W_OBSERVE_TX      0x28     // Transmit Observe register
#define W_RX_ADDR_P0      0x2a     // Receive address data pipe 0
#define W_RX_ADDR_P1      0x2b     // Receive address data pipe 1
#define W_RX_ADDR_P2      0x2c     // Receive address data pipe 2
#define W_RX_ADDR_P3      0x2d     // Receive address data pipe 3
#define W_RX_ADDR_P4      0x2e     // Receive address data pipe 4
#define W_RX_ADDR_P5      0x2f     // Receive address data pipe 5
#define W_TX_ADDR         0x30     // Transmit address
#define W_RX_PW_0         0x31     // Number of bytes in RX payload for pipe 0
#define W_RX_PW_1         0x32     // Number of bytes in RX payload for pipe 1
#define W_RX_PW_2         0x33     // Number of bytes in RX payload for pipe 2
#define W_RX_PW_3         0x34     // Number of bytes in RX payload for pipe 3
#define W_RX_PW_4         0x35     // Number of bytes in RX payload for pipe 4
#define W_RX_PW_5         0x36     // Number of bytes in RX payload for pipe 5

#define R_RX_PAYLOAD      0x61     // Read RX-payload
#define W_TX_PAYLOAD      0xa0     // Write TX-payload

#define FLUSH_TX          0xe1     // Flush transmit buffer
#define FLUSH_RX          0xe2     // Flush receive buffer
#define REUSE_TX_PL       0xe3     // Reuse last transmission
#define NOP               0xff     // No operation

/* Flags in STATUS */
#define RX_DR_MASK        0x40     /* Data Ready RX FIFO interrupt */
#define TX_DS_MASK        0x20     /* Data Sent TX FIFO interrupt */
#define MAX_RT_MASK       0x10     /* Max number of TX retries interrupt */
#define RX_P_NO_MASK      0x0e     /* Mask to retrieve the data pipe number */

#define RX_EMPTY_MASK     0x01     /* Flag in FIFO_STATUS register */

#define RF_CH_MASK        0x7f     /* To ensure 0 < rf_ch < 127 */

/* used to escape the characters matching the EOT token and ESCAPE */
#define RADIO_ESCAPE_CHAR           0xfe

/* end of transmission token */
#define RADIO_EOT_CHAR              0xfd

/* define states */
#define STATE_WAIT_FOR_EOT             0
#define STATE_WAIT_FOR_RECEIVE         1
#define STATE_WAIT_FOR_CLIENT          2

/* First byte of every message is a header byte */

/* This flag is set if the client (or server) has been reset. */
#define HEADER_RESET_MASK           0x80
/* This flag is set if the client (or server) acknowledges reset. */
#define HEADER_ACK_RESET_MASK       0x40
/* This bit is set in the header byte if the header is to be
   interpretted as EOT */
#define HEADER_EOT_MASK             0x10

/* some macros to make some function calls a little more readable */
#define UPDATE_PRIM_RX                 1
#define MAINTAIN_PRIM_RX               0

#define UPDATE_ADDRESS                 1
#define MAINTAIN_ADDRESS               0

#define CLIENT_MODIFIED                1
#define CLIENT_UNMODIFIED              0

/* Last byte of client 0's address, etc 
   Must match the address specified in radioClient.c */
#define CLIENT_TAIL_0               0xc2
#define CLIENT_TAIL_1               0xc3
#define CLIENT_TAIL_2               0xc4
#define CLIENT_TAIL_3               0xc5
#define CLIENT_TAIL_4               0xc6

const tINT8U clientAddrTail[CLIENT_COUNT_MAX] = {
  CLIENT_TAIL_0, CLIENT_TAIL_1, CLIENT_TAIL_2,
  CLIENT_TAIL_3, CLIENT_TAIL_4 
};

/* declare space for rx and tx addresses */
tINT8U rx1_address_array[ADDRESS_LENGTH];
tINT8U tx_address_array[ADDRESS_LENGTH];

#define RB_TX_FULL(b) \
  ( ((tINT8U)((b)->out - (b)->in) <= PAYLOAD_LEN - 3) \
   && ((b)->in != (b)->out) \
  )

#define RB_TX_PUSH(b, v) \
    (RB_TX_FULL(b) ? 1 : \
     ((b)->start[(b)->in++] = (v), (b)->nElements++, 0) \
    )

typedef struct {
  /* the index of the state in the commStates array */
  tINT8U id;

  /* memory for outgoing data, has to be 256 bytes */
  tINT8U outBuf[256];

  /* memory for incoming data, has to be 256 bytes */
  tINT8U inBuf[256];

  /* declare pointers to rb data structures */
  rbType outRB;
  rbType inRB;

  /* store the last tID sent here */
  tINT8U lastTID;

  /* flags to store reset status */
  tINT8U reset;
  
  tINT16U failureCount;

} commStateType;

commStateType commStates[CLIENT_COUNT];
commStateType *cc = NULL;

/* store the current state */
tINT8U moduleState;

/* used by the server to determine which clients are active */
tINT8U clientFlags;

/* incremented every time there is a tick */
tINT8U tickCounter;

/* Determines the next client to poll.
   Returns true if the cc was modified. */
tINT8U RadioServer_NextClient() {

  // determine the next client flag set after the cc
  switch(cc->id) {
  case 0:
    if(clientFlags & CLIENT_FLAG_1) {
      cc = &commStates[1];
    } else if(clientFlags & CLIENT_FLAG_2) {
      cc = &commStates[2];    
    } else if(clientFlags & CLIENT_FLAG_3) {
      cc = &commStates[3];    
    } else if(clientFlags & CLIENT_FLAG_4) {
      cc = &commStates[4];    
    } else {
      return CLIENT_UNMODIFIED;
    }
    
    return CLIENT_MODIFIED;
    
  case 1:
    if(clientFlags & CLIENT_FLAG_2) {
      cc = &commStates[2];
    } else if(clientFlags & CLIENT_FLAG_3) {
      cc = &commStates[3];
    } else if(clientFlags & CLIENT_FLAG_4) {
      cc = &commStates[4];
    } else if(clientFlags & CLIENT_FLAG_0) {
      cc = &commStates[0];
    } else {
      return CLIENT_UNMODIFIED;
    }
    return CLIENT_MODIFIED;
    
  case 2:
    if(clientFlags & CLIENT_FLAG_3) {
      cc = &commStates[3];
    } else if(clientFlags & CLIENT_FLAG_4) {
      cc = &commStates[4];
    } else if(clientFlags & CLIENT_FLAG_0) {
      cc = &commStates[0];
    } else if(clientFlags & CLIENT_FLAG_1) {
      cc = &commStates[1];
    } else {
      return CLIENT_UNMODIFIED;
    }
    return CLIENT_MODIFIED;
    
  case 3:
    if(clientFlags & CLIENT_FLAG_4) {
      cc = &commStates[4];
    } else if(clientFlags & CLIENT_FLAG_0) {
      cc = &commStates[0];
    } else if(clientFlags & CLIENT_FLAG_1) {
      cc = &commStates[1];
    } else if(clientFlags & CLIENT_FLAG_2) {
      cc = &commStates[2];
    } else {
      return CLIENT_UNMODIFIED;
    }
    return CLIENT_MODIFIED;
    
  case 4:
    if(clientFlags & CLIENT_FLAG_0) {
      cc = &commStates[0];
    } else if(clientFlags & CLIENT_FLAG_1) {
      cc = &commStates[1];
    } else if(clientFlags & CLIENT_FLAG_2) {
      cc = &commStates[2];
    } else if(clientFlags & CLIENT_FLAG_3) {
      cc = &commStates[3];
    } else {
      cc = &commStates[4];
      return CLIENT_UNMODIFIED;
    }

    return CLIENT_MODIFIED;
  }
  return CLIENT_UNMODIFIED;
}

/*
  Transmit() is a private procedure that is only called when the
  server is in possession of the EOT token, or the EOT needs to
  be regenerated.
*/
tVOID RadioServer_Transmit(tINT8U updateAddresses) {
tINT8U i, haveSentEOT, header, data;
  
#ifdef TO_DEBUG
  SCI0_OutString("T\r\n"); /* enter Transmit */
#endif
  
  /* can only re-configure if in stand-by mode */
  CE = 0;

  /* a good idea to clear all interrupts and flush buffers first */
  SPI_OutChar(FLUSH_TX);
  SPI_OutChar(FLUSH_RX);
  
  /* clears all interrupts */
  SPI_OutChar2(W_STATUS, RX_DR_MASK | TX_DS_MASK | MAX_RT_MASK);

  /*
    bit  CONFIG Register
      7  0  Reserved
      6  1  MASK_RX_DR  : Don't reflect RX_DR on IRQ pin
      5  1  MASK_TX_DS  : Don't reflect TX_DS on IRQ pin
      4  1  MASK_MAX_RT : Don't reflect MAX_RT on IRQ pin
      3  1  EN_CRC      : Enable CRC
      2  1  CRCO        : 2 byte CRC
      1  1  PWR_UP      : Power Up
      0  0  PRIM_RX     : PTX
      
      Enter transmit mode
  */
  SPI_OutChar2(W_CONFIG, 0x7e);

  if(updateAddresses) {

    /* Append the tail of the current client address to
       clientAddressHeader */
    tx_address_array[0] = clientAddrTail[cc->id];

    /*
      RX_ADDR_P0 Register
      Receive address for current client (for ACK).
    */
    SPI_OutChar3(W_RX_ADDR_P0, tx_address_array, ADDRESS_LENGTH);

    /*
      TX_ADDR Register
      Transmit address for current client.
    */
    SPI_OutChar3(W_TX_ADDR, tx_address_array, ADDRESS_LENGTH);
  }

  /* download the next segment */

  while(SPI0SR_SPTEF == 0) {}

  /* begin SPI segment */
  CSN = 0;

  /* output the write transmit buffer command */
  SPI0DR = W_TX_PAYLOAD;
  SPI_Pause();

  /* Determine what the header byte should be */
  header = cc->reset;
  
  if(header & HEADER_RESET_MASK) {
    /* if we've reset recently, make sure we start transmitting
       from the start of the transmit buffer */
    RB_SET_OUT(&cc->outRB, 0); 
    header |= HEADER_EOT_MASK;
  }

  /* determine whether we should send EOT in header byte */
  if(RB_EMPTY(&cc->outRB)) {
    header |= HEADER_EOT_MASK;
  }
  
  /* output the header byte */
  while(SPI0SR_SPTEF == 0) {}
  SPI0DR = header;
  SPI_Pause();

  /* work out if EOT was set in header */
  haveSentEOT = (header & HEADER_EOT_MASK) != 0;

  /* output the rID */
  while(SPI0SR_SPTEF == 0) {}
  SPI0DR = cc->inRB.in;
  SPI_Pause();

  /* output the tID */
  while(SPI0SR_SPTEF == 0) {}
  SPI0DR = cc->outRB.out;
  SPI_Pause();

  /* store what the last tID sent was */
  cc->lastTID = cc->outRB.out;
  
  /* fill the remaining bytes */
  for(i=3; i<PAYLOAD_LEN; i++) {

    while(SPI0SR_SPTEF == 0) {}
  
      if(haveSentEOT == 0) {

        if(RB_EMPTY(&cc->outRB)) {
          /* if there's no more data to be sent, then EOT */

          SPI0DR = RADIO_EOT_CHAR;
          haveSentEOT = 1;

        } else {
        
          /* check what the next byte is to send */
          RB_PEEK(&cc->outRB, &data);

          if(data != RADIO_ESCAPE_CHAR
             && data != RADIO_EOT_CHAR) {

            /* the byte is not a special token, transmit it */
            RB_POP(&cc->outRB, &SPI0DR);
            
          } else {
            /* the data to be sent matches a special token, need to
               escape the data to be sent so it doesn't get
               misinterpretted */
            if(i == PAYLOAD_LEN - 1) {
              /* there's not enough space for the ESCAPE token and
                 the escaped char in this segment,
                 => EOT, send the character next time */
              SPI0DR = RADIO_EOT_CHAR;
              haveSentEOT = 1;
              
            } else {
              /* there is space for the ESCAPE token and the escaped
                 char */
              SPI0DR = RADIO_ESCAPE_CHAR;
              SPI_Pause();
              
              while(SPI0SR_SPTEF == 0) {}
              RB_POP(&cc->outRB, &SPI0DR);
              
              i++;
            }
          }
        }
      } else {
        /* we have sent EOT, but still need to fill tx_payload */
        /* fill the rest of the transmit buffer with \0 */
        SPI0DR = 0x00;
      }

    SPI_Pause();
  }
  
  /* end SPI packet */
  CSN = 1;

#ifdef TO_DEBUG  
  SCI0_OutString("T~\r\n"); /* exit Transmit() */
#endif

  // Pulse CE to start transmission (must be > 10us)
  CE = 1;
}

/* 
  EnterReceive is a private procedure to configure the module for
  receive mode.
  Must be in a standby-mode to call this method.
*/
tVOID RadioServer_EnterReceive() {

  /* a good idea to clear all interrupts and flush buffers first */
  SPI_OutChar(FLUSH_TX);
  SPI_OutChar(FLUSH_RX);
  SPI_OutChar2(W_STATUS, RX_DR_MASK | TX_DS_MASK | MAX_RT_MASK);

  /*
    bit  CONFIG Register
      7  0  Reserved
      6  1  MASK_RX_DR  : Don't reflect RX_DR on IRQ pin
      5  1  MASK_TX_DS  : Don't reflect TX_DS on IRQ pin
      4  1  MASK_MAX_RT : Don't reflect MAX_RT on IRQ pin
      3  1  EN_CRC      : Enable CRC
      2  1  CRCO        : 2 byte CRC
      1  1  PWR_UP      : Power Up
      0  1  PRIM_RX     : PRX
      
      Enter receive mode
  */
  SPI_OutChar2(W_CONFIG, 0x7f);
 
  CE = 1;
}

/* 
  OnReceive() is a private procedure which is called when the
  RX_DR flag is set in the STATUS register.
  Returns 1 if have received EOT, otherwise returns 0
*/
tVOID RadioServer_OnReceive() {
tINT8U header, rID, tID, in, i, toEscape, haveReceivedEOT, trustData;

#ifdef TO_DEBUG
  SCI0_OutString("R\r\n"); /* enter onReceive() */
#endif                                                            

  /* use in as a dummy */
  in = SPI0SR;
  in = SPI0DR;  // clear SPIF

  toEscape = haveReceivedEOT = 0;

  while(SPI0SR_SPTEF == 0) {}

  CSN = 0;
  
  /* send the read command */
  SPI0DR = R_RX_PAYLOAD;
  SPI_Pause();
  in = SPI_InChar(); // discard the status byte

  while(SPI0SR_SPTEF == 0) {}
  SPI0DR = NOP;      // output a dummy value to generate SCK
  SPI_Pause();

  /* read in header byte */
  header = SPI_InChar();

  while(SPI0SR_SPTEF == 0) {}
  SPI0DR = NOP;      // output a dummy value to generate SCK
  SPI_Pause();

  /* read in rID */
  rID = SPI_InChar();

  while(SPI0SR_SPTEF == 0) {}
  SPI0DR = NOP;      // output a dummy value to generate SCK
  SPI_Pause();

  /* read in tID */
  tID = SPI_InChar();

  if(tID == cc->inRB.in) {
    /* client's tID matches expected rID, i.e. the client's sending
       requested byte next, so can probably trust */
    trustData = 1;

  } else {

    /* the client is sending a byte out of order, probably cannot
       trust */
    trustData = 0;
    
#ifdef TO_DEBUG_ERROR_CONDITIONS
    SCI0_OutString("Invalid tID: ");
    SCI0_OutUDec(tID);
    SCI0_OutString(", expected ");
    SCI0_OutUDec(cc->inRB.in);
    SCI0_OutString("\r\n");
#endif
  }

  /* may be able to trust the data if the server has been reset
     recently */
  if(cc->reset & HEADER_RESET_MASK) {
    /* server has been reset recently */

    if(header & HEADER_ACK_RESET_MASK) {
      /* client has acknowledged server reset */
      cc->reset &= ~HEADER_RESET_MASK;
      
      /* what follows must be valid, since the client has ack'd
         reset */
      trustData = 1;

#ifdef TO_DEBUG
      SCI0_OutString("ACK'd reset\r\n");
#endif
    
    } else {

      /* client has not acknowledged reset, cannot trust data,
         even if had a "valid" tID */
      trustData = 0;

#ifdef TO_DEBUG_ERROR_CONDITIONS
      SCI0_OutString("Not ACK'd reset\r\n");
#endif
    }
  }
  
  /* if the client itself has been reset, we can trust the data */
  if(header & HEADER_RESET_MASK) {
    /* Client has been reset!
       This can be bad if there's still data in the buffer,
       may get data queued from another session => clean them */
    RadioServer_CleanOut(cc->id);
    RadioServer_CleanIn(cc->id);
  
    /* acknowledge to client that the reset has been a success */
    cc->reset |= HEADER_ACK_RESET_MASK;
    
    cc->failureCount = 0;

    /* what follows is a new byte (it's byte 0) */
    trustData = 1;
#ifdef TO_DEBUG
    SCI0_OutString("Client reset\r\n");
#endif
  } else {
    /* if client hasn't reset, clear ACK_RESET flag */
    cc->reset &= ~HEADER_ACK_RESET_MASK;
  }
  
#ifdef TO_DEBUG_ERROR_CONDITIONS
  if(!trustData) {
    SCI0_OutString("Discard data\r\n");
  }
#endif

  haveReceivedEOT = (header & HEADER_EOT_MASK) != 0;

  for(i=3; i<PAYLOAD_LEN; i++) {

    while(SPI0SR_SPTEF == 0) {}
    SPI0DR = NOP;      // output a dummy value to generate SCK
    SPI_Pause();

    in = SPI_InChar(); // read in potentially valid byte

    if(trustData && (haveReceivedEOT == 0)) {
      if(toEscape == 0) {    // last character in wasn't the ESCAPE char
        switch(in) {
        case RADIO_ESCAPE_CHAR:
          toEscape = 1;
          break;
          
        case RADIO_EOT_CHAR:
          /* have received EOT */
          haveReceivedEOT = 1;
          break;
          
        default:
          if(RB_PUSH(&cc->inRB, in)) {
#ifdef TO_DEBUG_ERROR_CONDITIONS
            SCI0_OutString("Dropped char: ");
            SCI0_OutUHex(in);
            SCI0_OutString("\r\n");
#endif
          }
          break;
        }
      } else {
        if(RB_PUSH(&cc->inRB, in)) {
#ifdef TO_DEBUG_ERROR_CONDITIONS
          SCI0_OutString("Dropped char: ");
          SCI0_OutUHex(in);
          SCI0_OutString("\r\n");
#endif
        }
        toEscape = 0;
      }
    }
  }
  
  CSN = 1;
  
#ifdef TO_DEBUG_ERROR_CONDITIONS
  if(cc->outRB.out != rID) {
    SCI0_OutString("Invalid rID: ");
    SCI0_OutUDec(rID);
    SCI0_OutString(", expected ");
    SCI0_OutUDec(outRB.out);
    SCI0_OutString("\r\n");
  }
#endif

  RB_SET_OUT(&cc->outRB, rID);

#ifdef TO_DEBUG
  SCI0_OutString("R~"); /* exit onReceive() */
#endif
}

/*
  Setup timer.
*/
tVOID RadioServer_RestartTick() {
  TICK_ENABLE = 1;
  TICK_REGISTER = TICK_PRESCALAR + TCNT;
  TICK_INTERRUPT = 1;
}




/* beginning of the interrupt service routine =================================  */

/**
 * Called regularly.
 */

#define CPL_PRAGMA_ISR_START
#include "cpl_pragma.h"

CPL_INTERRUPT tVOID RadioServer_OnTick(tVOID) {

tINT8U status;

  /* first deal with the timer flags */
  TICK_ENABLE = 0;
  TICK_INTERRUPT = 1;

  /* re-enable all interrupts (to allow servicing of RxD interrupt) */
  asm cli                // re-enable interrupts to allow this one to be interrupted
  
  /* always increment the tick counter */
  tickCounter++;

#ifdef TO_DEBUG
  SCI0_OutChar('`');
#endif

  switch(moduleState) {
  
  case STATE_WAIT_FOR_EOT:

#ifdef TO_DEBUG
    SCI0_OutChar('@');
#endif

    /* read status (one byte long) */
    SPI_Read(R_STATUS, &status, 1);

    if(status & TX_DS_MASK) {
      
      /* successfully transmitted PAYLOAD_LEN bytes */
      
#ifdef TO_DEBUG
      SCI0_OutString("T'd\r\n");
#endif

      /* clear interrupt */
      SPI_OutChar2(W_STATUS, TX_DS_MASK);

      /* Since EOT was transmitted, client is about to send,
         => enter RX */

      RadioServer_EnterReceive();

      setState(STATE_WAIT_FOR_RECEIVE);
      
    } else if(status & MAX_RT_MASK) {

      /* module has informed us there's been a timeout */

#ifdef TO_DEBUG_ERROR_CONDITIONS
      SCI0_OutString("F'd\r\n");
#endif

      /* clear interrupt */

      SPI_OutChar2(W_STATUS, MAX_RT_MASK);

      RB_SET_OUT(&cc->outRB, cc->lastTID);

      cc->failureCount++;

      /* try to transmit to the next client */
      RadioServer_Transmit(RadioServer_NextClient());
      setState(STATE_WAIT_FOR_EOT);

    } else if(tickCounter >= WAIT_FOR_ACK_TICK_COUNT) {

#ifdef TO_DEBUG_ERROR_CONDITIONS
      SCI0_OutString("Q'd\r\n");
#endif

      /* this is a very bizarre state to get into, treat it similarly
         to as though we had explicitly received a timeout */

      RB_SET_OUT(&cc->outRB, cc->lastTID);

      cc->failureCount++;

      /* transmit to the next client */
      RadioServer_Transmit(RadioServer_NextClient());
      setState(STATE_WAIT_FOR_EOT);
    }
    
    break;

  case STATE_WAIT_FOR_RECEIVE:


#ifdef TO_DEBUG
    SCI0_OutChar('r');
#endif

    /* read status (one byte long) */
    SPI_Read(R_STATUS, &status, 1);

    if(status & RX_DR_MASK) {
#ifdef TO_DEBUG
      SCI0_OutString("R'd");
#endif

      /* to be pedantic, should ensure that the RX_P_NO matches
         cc */
      if((((status & RX_P_NO_MASK) >> 1) - 1) == cc->id) {
        RadioServer_OnReceive();
        /* have received EOT */
        if(RadioServer_NextClient()) {
          /* new client */
          RadioServer_Transmit(UPDATE_ADDRESS);
          /* have sent EOT */
          setState(STATE_WAIT_FOR_EOT);
        } else {
          /* retransmitting to same client, need to wait for client
             to enter RX mode */
          setState(STATE_WAIT_FOR_CLIENT);
        }
      } else {
#ifdef TO_DEBUG_ERROR_CONDITIONS
        SCI0_OutString("Wrong pipe number!");
        SCI0_OutUHex((status & RX_P_NO_MASK) >> 1);
#endif
        RadioServer_EnterReceive();
        setState(STATE_WAIT_FOR_RECEIVE);

      }
    } else if(tickCounter >= TIME_OUT_TICK_COUNT) {

      /* client has timed out */
#ifdef TO_DEBUG_ERROR_CONDITIONS
      SCI0_OutString("Timeout");
#endif      

      cc->failureCount++;

      RadioServer_Transmit(RadioServer_NextClient());
      /* have sent EOT */
      setState(STATE_WAIT_FOR_EOT);
    }
    
    break;
  
  case STATE_WAIT_FOR_CLIENT:

#ifdef TO_DEBUG
    SCI0_OutChar('C');
#endif

    /* client is now in receive mode */
    if(tickCounter >= WAIT_FOR_CLIENT_TICK_COUNT) {
      /* transmitting back to the same client that just EOT'd */
      RadioServer_Transmit(MAINTAIN_ADDRESS);
      /* have sent EOT */
      setState(STATE_WAIT_FOR_EOT);
    }
    break;
  }
 
  /* restart the timer */
  RadioServer_RestartTick();
  
}

#define CPL_PRAGMA_ISR_STOP
#include "cpl_pragma.h"

/* end of the interrupt service routine =================================  */


tINT8U RadioServer_Init(tINT8U baudRate,
                               tINT8U rfChannel,
                               tINT32U serverAddressHeader,
                               tINT32U clientAddressHeader,
                               tINT8U cFlags) {
tINT8U i;

// space to test the first the receive address was correctly written
tINT8U test[ADDRESS_LENGTH];

  /* configure CE pin as an output */
  CE_DDR = 1;

  /* Enter Standby-I Mode */
  CE = 0;

  /* store the clientFlags */
  clientFlags = cFlags;

  /* initialise the SPI */
  SPI_Init(baudRate);
  
  for(i=0; i<CLIENT_COUNT; i++) {
    commStates[i].id = i;

    /* init the transmit ring buffers */
    RB_INIT(&commStates[i].outRB, commStates[i].outBuf);

    /* init the receive ring buffers */
    RB_INIT(&commStates[i].inRB, commStates[i].inBuf);
    
    /* lastTID is 0x00 */
    commStates[i].lastTID = 0x00;
    
    /* notify clients that the server has been reset */
    commStates[i].reset = HEADER_RESET_MASK;
    
    commStates[i].failureCount = 0;
  }

  /* Select the first flagged client as the current client, and 
     simultaneously check for the no client flag set error.
     If a client's flag is not set, it will not be polled. */
  if(clientFlags & CLIENT_FLAG_0) {
    cc = &commStates[0];
  } else if(clientFlags & CLIENT_FLAG_1) {
    cc = &commStates[1];
  } else if(clientFlags & CLIENT_FLAG_2) {
    cc = &commStates[2];
  } else if(clientFlags & CLIENT_FLAG_3) {
    cc = &commStates[3];
  } else if(clientFlags & CLIENT_FLAG_4) {
    cc = &commStates[4];
  } else {
     // no clients are active, return error
     return INIT_ERROR_NO_CLIENTS_SET;
  }

  /* set the first four bytes of the receive address of pipe 1
     as serverAddress */
  rx1_address_array[1] = serverAddressHeader & 0xff;
  rx1_address_array[2] = (serverAddressHeader >> 8) & 0xff;
  rx1_address_array[3] = (serverAddressHeader >> 16) & 0xff;
  rx1_address_array[4] = (serverAddressHeader >> 24) & 0xff;
  
  /* now append the tail of the client 0 address */
  rx1_address_array[0] = CLIENT_TAIL_0;

  /* set the first four of the client transmit bytes */
  tx_address_array[1] = clientAddressHeader & 0xff;
  tx_address_array[2] = (clientAddressHeader >> 8) & 0xff;
  tx_address_array[3] = (clientAddressHeader >> 16) & 0xff;
  tx_address_array[4] = (clientAddressHeader >> 24) & 0xff;

  /* seems to be required? May be an artifact of original buggy SPI code... */
  SPI_OutChar(NOP);

  /*
    bit  EN_AA Register
    7:6  00 Reserved    : Must be zero
      5   1             : Enable auto-ACK on data pipe 5
      4   1             : Enable auto-ACK on data pipe 4
      3   1             : Enable auto-ACK on data pipe 3
      2   1             : Enable auto-ACK on data pipe 2
      1   1             : Enable auto-ACK on data pipe 1
      0   1             : Enable auto-ACK on data pipe 0
     */
  SPI_OutChar2(W_EN_AA, 0x3f);

  /*
    bit  EN_RXADDR Register
    7:6  0  Reserved    : Must be zero
      5  X  ERX_P5      : Client 4 enable
      4  X  ERX_P4      : Client 3 enable
      3  X  ERX_P3      : Client 2 enable
      2  X  ERX_P2      : Client 1 enable
      1  X  ERX_P1      : Client 0 enable
      0  1  ERX_P0      : Reserved for ACKs
  */
  SPI_OutChar2(W_EN_RXADDR, clientFlags | 0x01);
  
  /*
    bit  SETUP_AW Register
    7:2  0  Reserved    : Must be zero
    1:0  11 AW          : RX/TA Address field width = 5
  */
  SPI_OutChar2(W_SETUP_AW, 0x03);

  /*
    bit  SETUP_RETR Register
    7:4  01  ARD (Auto re-transmit delay)
    3:1  15  ARC (Auto re-transmit count)
  */
  SPI_OutChar2(W_SETUP_RETR, 0x0f);
  
  /*
    Set the RF_CH, which RF channel to receive/transmit on
  */
  SPI_OutChar2(W_RF_CH, (rfChannel & RF_CH_MASK));

  /*
    bit  RF_SETUP Register
    7:5  0  Reserved
      4  0  PLL_LOCK    : Use Default
      3  X  RF_DR       : RF baud rate, depends on RF_BAUD_RATE
    2:1  11 RF_PWR      : 0dBm output power in TX mode (max)
      0  1  LNA_HCURR   : Setup LNA gain
  */
  
#ifdef SLOW_RF_BAUD_RATE

  SPI_OutChar2(W_RF_SETUP, 0x07);

#else // FAST_RF_BAUD_RATE

  SPI_OutChar2(W_RF_SETUP, 0x0f);

#endif  

  /*
    RX_ADDR_P1 Register
    Receive address for client 0.
  */
  SPI_OutChar3(W_RX_ADDR_P1, rx1_address_array, ADDRESS_LENGTH);

  /*
    Perform a simple read to make sure that memory is being
    correctly written.
  */
  SPI_Read(R_RX_ADDR_P1, test, ADDRESS_LENGTH);

  /*
    Will return NO_POWER if the read RX1 address does not match
    the address written, meaning that there's no power to the
    module.
  */
  if(test[0] != rx1_address_array[0]
  || test[1] != rx1_address_array[1]
  || test[2] != rx1_address_array[2]
  || test[3] != rx1_address_array[3]
  || test[4] != rx1_address_array[4]) {
    return INIT_ERROR_NO_POWER;
  }

  /*
    RX_ADDR_P2 Register
    LSB of receive address for client 1.
  */
  SPI_OutChar2(W_RX_ADDR_P2, CLIENT_TAIL_1);

  /*
    RX_ADDR_P3 Register
    LSB of receive address for client 2.
  */
  SPI_OutChar2(W_RX_ADDR_P3, CLIENT_TAIL_2);

  /*
    RX_ADDR_P4 Register
    LSB of receive address for client 3.
  */
  SPI_OutChar2(W_RX_ADDR_P4, CLIENT_TAIL_3);

  /*
    RX_ADDR_P5 Register
    LSB of receive address for client 4.
  */
  SPI_OutChar2(W_RX_ADDR_P5, CLIENT_TAIL_4);

  /*
    RW_PW_0 Register
    Set the width of data pipe 0 (Reserved for ACKs)
  */
  SPI_OutChar2(W_RX_PW_0, 0);

  /*
    RW_PW_1 Register
    Set the width of the RX payload on pipe 1
  */
  SPI_OutChar2(W_RX_PW_1, PAYLOAD_LEN);
  
  /*
    RW_PW_2 Register
    Set the width of the RX payload on pipe 2
  */
  SPI_OutChar2(W_RX_PW_2, PAYLOAD_LEN);

  /*
    RW_PW_3 Register
    Set the width of the RX payload on pipe 3
  */
  SPI_OutChar2(W_RX_PW_3, PAYLOAD_LEN);

  /*
    RW_PW_4 Register
    Set the width of the RX payload on pipe 4
  */
  SPI_OutChar2(W_RX_PW_4, PAYLOAD_LEN);

  /*
    RW_PW_5 Register
    Set the width of the RX payload on pipe 5
  */
  SPI_OutChar2(W_RX_PW_5, PAYLOAD_LEN);

  /* clear all previous interrupts */
  SPI_OutChar2(W_STATUS, 0x70);

  /* flush buffers */
  SPI_OutChar(FLUSH_TX);
  SPI_OutChar(FLUSH_RX);

  /* start polling clients */
  RadioServer_Transmit(UPDATE_ADDRESS);
  setState(STATE_WAIT_FOR_EOT);
  
  /* start the ticker */
  RadioServer_RestartTick();

  return 0;
}

/*
  Diagnostic to check for carriers (jammed signal). Infinite loop.
  Cycle through all 128 channels. If Carrier is detected on a channel,
  increment its corresponding element in the carrier_detect array.
  See radioServer.h for more info.
*/
tVOID RadioServer_CheckCarrier(tVOID) {
tINT8U i,j,k,cd;
tINT16U carrier_detect[128];

  while(1) {
    for(i = 127; i != 0; i++) {

      CE = 0;

      /*
        bit  CONFIG Register
          7  0  Reserved
          6  1  MASK_RX_DR  : Don't reflect RX_DR on IRQ pin
          5  1  MASK_TX_DS  : Don't reflect TX_DS on IRQ pin
          4  1  MASK_MAX_RT : Don't reflect MAX_RT on IRQ pin
          3  1  EN_CRC      : Enable CRC
          2  1  CRCO        : 2 byte CRC
          1  1  PWR_UP      : Power Up
          0  1  PRIM_RX     : PRX
          
          Enter receive mode
      */
      SPI_OutChar2(W_CONFIG, 0x7f);
      
      /* select a new RF channel */
      SPI_OutChar2(W_RF_CH, i);
      
      CE = 1;
      
      for(j=255; j!=0; j--) {
        for(k=255; k!=0; k--) {
          /* Specification seems to imply 258us delay is required here.
             This will delay for quite a bit longer than that. */
        }
      }

      /* read the one byte long CD register */
      SPI_Read(R_CD, &cd, 1);
      
      /* if carrier is detected, increment carrier_detect[i] */
      if(cd) {
        /* protect against overflow */
        if(carrier_detect[i] != 0xffff) {
          carrier_detect[i]++; 
        }
      }
    }
    
    /*
      Each time all channels have been tested, output the results to date.
      The longer this is left to run, a better average of the results should
      be obtained.
     */
      
#if (DEBUG_MSG_LVL > 0)
    for(i = 127; i != 0; i--) {
      SCI0_OutUDec(i);
      SCI0_OutString(", ");
      SCI0_OutUDec(carrier_detect[i]);
      SCI0_OutChar(CR);
      SCI0_OutChar(LF); 
    }
#endif /* DEBUG_MSG_LVL */
  }
}

tVOID RadioServer_AddClient(tINT8U client) {
  switch(client) {
    case 0:
      clientFlags |= CLIENT_FLAG_0;
      break;
    case 1:
      clientFlags |= CLIENT_FLAG_1;
      break;
    case 2:
      clientFlags |= CLIENT_FLAG_2;
      break;
    case 3:
      clientFlags |= CLIENT_FLAG_3;
      break;
    case 4:
      clientFlags |= CLIENT_FLAG_4;
      break;
  }
  
  commStates[client].failureCount = 0;
}

tVOID RadioServer_RemoveClient(tINT8U client) {
  switch(client) {
    case 0:
      clientFlags &= ~CLIENT_FLAG_0;
      break;
    case 1:
      clientFlags &= ~CLIENT_FLAG_1;
      break;
    case 2:
      clientFlags &= ~CLIENT_FLAG_2;
      break;
    case 3:
      clientFlags &= ~CLIENT_FLAG_3;
      break;
    case 4:
      clientFlags &= ~CLIENT_FLAG_4;
      break;
  }

  commStates[client].failureCount = 0;
}

tINT8U RadioServer_OutChar(tINT8U client,
                                  tINT8U val) {
  return RB_TX_PUSH(&commStates[client].outRB, val);
}

tVOID RadioServer_OutCharArray(tINT8U client,
                              tINT8U *pt,
                              tINT8U len) {
tINT8U i;
  for(i=0; i<len; i++) {
    while(RadioServer_OutChar(client, pt[i]));
  }
}

tVOID RadioServer_OutString(tINT8U client,
                           tINT8U *pt) {
  while(*pt) {
    while(RadioServer_OutChar(client, *pt++));
    while(RadioServer_OutChar(client, 0x00));
  }
}

tINT8U RadioServer_IsOutFull(tINT8U client) {
  return RB_TX_FULL(&commStates[client].outRB);
}

tINT8U RadioServer_IsOutEmpty(tINT8U client) {
  return RB_EMPTY(&commStates[client].outRB);
}

tINT8U RadioServer_IsInFull(tINT8U client) {
  return RB_FULL(&commStates[client].inRB);
}

tINT8U RadioServer_IsInEmpty(tINT8U client) {
  return RB_EMPTY(&commStates[client].inRB);
}

tINT8U RadioServer_HasElements(tINT8U client) {
  return RB_ELEMENTS(&commStates[client].inRB);
}

tVOID RadioServer_CleanIn(tINT8U client) {
  RB_CLEAN(&commStates[client].inRB);
}

tVOID RadioServer_CleanOut(tINT8U client) {
  RB_CLEAN(&commStates[client].outRB);
}

tINT8U RadioServer_InChar(tINT8U client) {
tINT8U toReturn;
  while(RB_POP(&commStates[client].inRB, &toReturn));
  return toReturn;
}

tVOID RadioServer_InCharArray(tINT8U client,
                             tINT8U *charArray,
                             tINT8U len) {
tINT8U i;
  for(i = 0; i<len; i++) {
    while(RB_POP(&commStates[client].inRB, &charArray[i]));
  }
}

tINT16U RadioServer_GetFailureCount(tINT8U client) {
  return commStates[client].failureCount;
}

tVOID RadioServer_OutStatusClient(tINT8U client) {
#if (DEBUG_MSG_LVL > 0)
  SCI0_OutString("Client ");
  SCI0_OutUDec(client);
  SCI0_OutString(", Status: ");
  
  switch(client) {
  case 0:
    if(clientFlags & CLIENT_FLAG_0) {
      SCI0_OutString("Active");
    } else {
      SCI0_OutString("Inactive");
    }
    break;

  case 1:
    if(clientFlags & CLIENT_FLAG_1) {
      SCI0_OutString("Active");
    } else {
      SCI0_OutString("Inactive");
    }
    break;

  case 2:
    if(clientFlags & CLIENT_FLAG_2) {
      SCI0_OutString("Active");
    } else {
      SCI0_OutString("Inactive");
    }
    break;

  case 3:
    if(clientFlags & CLIENT_FLAG_3) {
      SCI0_OutString("Active");
    } else {
      SCI0_OutString("Inactive");
    }
    break;

  case 4:
    if(clientFlags & CLIENT_FLAG_4) {
      SCI0_OutString("Active");
    } else {
      SCI0_OutString("Inactive");
    }
    break;
  }

  SCI0_OutString(", Failure Count: ");
  SCI0_OutUDec(commStates[client].failureCount);
#endif /* DEBUG_MSG_LVL */
}

#endif /* HAS_RFCOMMS */
