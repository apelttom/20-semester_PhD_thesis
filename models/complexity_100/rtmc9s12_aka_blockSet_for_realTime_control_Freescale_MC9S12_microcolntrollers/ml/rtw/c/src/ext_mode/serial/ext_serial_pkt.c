/*
 * Copyright 1994-2003 The MathWorks, Inc.
 *
 * File: ext_serial_pkt.c     $Revision: 1.1.6.4 $
 *
 * Abstract:
 *  The External Mode Serial Packet is a container object for the serial data
 *  to be transitted or received and the serial communication overhead (such as
 *  headers, tailers, etc.).  The external mode code writes data to be
 *  transmitted into an External Mode Serial Packet and lets the packet object
 *  handle all of the details involved in sending the data.  Conversely, data to
 *  be received by the external mode code is stored in an External Mode Serial
 *  Packet that handles all of the details in receiving that data.  In this
 *  way, the External Mode Serial Packet provides a clean interface for sending
 *  and receiving data to a serial port without worrying about the details
 *  involved with transmitting and receiving the data.
 *
 *     ----------------------------------
 *     | Host/Target external mode code |
 *     ----------------------------------
 *         / \                 / \
 *        /| |\               /| |\
 *         | |                 | |
 *         | | Connect         | |   Write
 *         | | Disconnect     \| |/  Read
 *         | | Pending         \ /
 *         | |          -----------------
 *         | |          | External Mode |
 *         | |          | Serial Packet |
 *         | |          -----------------
 *         | |                 / \
 *         | |                /| |\  Send
 *         | |                 | |   Receive
 *         | |                 | | 
 *        \| |/               \| |/
 *         \ /                 \ /
 *     ----------------------------------
 *     | External Mode Serial Port      |
 *     ----------------------------------
 *                   / \
 *                  /| |\
 *                   | |
 *                   | |
 *                  \| |/
 *                   \ /
 *     ----------------------------------
 *     | HW/OS/Physical serial port     |
 *     ----------------------------------
 *
 *  See also ext_serial_<TRANSPORT>_port.c.
 *
 * Adapted for rtmc9s12-Target, fw-05-10
 */

#include <stdlib.h>
#include <string.h>

#include "tmwtypes.h"

#include "ext_types.h"
#include "ext_share.h"
#include "ext_serial_port.h"
#include "ext_serial_pkt.h"

/* debugging support */
#ifndef MATLAB_MEX_FILE

  /* TARGET ONLY ------------------- */

  /* Model dependent constants -- generated by 'gen_mc_defines_h.m' */
  #include "mc_defines.h"

  /* macros PRINT_DEBUG_MSG_LVL1 to PRINT_DEBUG_MSG_LVL1,  fw-06-07 */
  #include "mc_debugMsgs.h"

  /* abort_LED */
  #include "mc_signal.h"

#else

  /* HOST ONLY --------------------- */
  
  /* macros PRINT_DEBUG_MSG_LVL1 to PRINT_DEBUG_MSG_LVL1,  fw-06-07 */
  #include "debugMsgs_host.h"

  #define abort_LED(err)    /* nothing */
  
#endif  /* MATLAB_MEX_FILE */




/*
 *********************************************************************************************************
 *    STATIC GLOBAL VARIABLES
 *********************************************************************************************************
 */

PRIVATE uint16_T           peekNilAtts    = 0;                  /* stored number of (unsuccessful) calls to CheckExtSerialPacket  */
PRIVATE uint16_T           peekCounterOld = 0;                  /* stored previous counter when peeking into RX ring buffer       */
PRIVATE uint16_T           peekCounter    = 0;                  /* stored counter when peeking into RX ring buffer                */
PRIVATE uint_T             peekTailOffset = 0;                  /* stored tail offset when peeking into RX ring buffer            */
PRIVATE int_T              peekState      = ESP_NoPacket;       /* stored state when peeking into RX ring buffer                  */
PRIVATE uint32_T           peekDataSize   = 0;                  /* stored payload data size when peeking into RX ring buffer      */
PRIVATE uint16_T           peekPacketSize = MIN_PACKET_SIZE;    /* minimum required packet size                                   */




/*
 *********************************************************************************************************
 *    LOCAL FUNCTIONS
 *********************************************************************************************************
 */

/* Function: IsEscapeChar ======================================================
 * Abstract:
 *  Returns true if the uint8_T belongs to the escape sequence, false otherwise.
 */
PRIVATE boolean_T IsEscapeChar(uint8_T c) {

    if ((c == packet_head) ||
        (c == packet_tail) ||
        (c == escape_character)) {
        
        return true;
        
    }

    return false;

} /* end IsEscapeChar */


/* Function: Filter ============================================================
 * Abstract:
 *  Filter the outgoing message to translate any bytes that conflict with
 *  escape chars.  If a byte does conflict, the byte is replaced with two
 *  bytes:  The first is the escape character and the second is the conflicted
 *  byte exclusive or'd with the mask character.  If a byte does not conflict,
 *  it is unchanged.  Returns the new size of the buffer after filtering.
 *
 * Note: In the worst case where every uint8_T is an escape uint8_T, the
 *       destination buffer will be 2 times the size of the source buffer.
 */
PRIVATE uint32_T Filter(uint8_T *dest, uint8_T *src, uint32_T bytes) {

    uint32_T    i;
    uint32_T    newSize = bytes;
    uint8_T    *pDest   = dest;
    uint8_T    *pSrc    = src;

    for (i = 0 ; i < bytes ; i++, pSrc++) {

        if (IsEscapeChar(*pSrc)) {
        
           *pDest = escape_character;
            pDest++;
           *pDest = (uint8_T)((*pSrc) ^ mask_character);
            pDest++;
            newSize++;
            
        } else {
        
           *pDest = *pSrc;
            pDest++;
            
        }

    }

    return newSize;

} /* end Filter */


/* Function: Num2String ========================================================
 * Abstract:
 *  Translates unsigned long values into strings and returns the size of the
 *  string.
 */
PRIVATE uint32_T Num2String(uint8_T   *dest,
                            uint32_T   value,
                            boolean_T  doFilter,
                            boolean_T  endianess) {
                            
    // local function name... debugging only
    DEFINE_DEBUG_FNAME("Num2String")

    uint8_T   c[sizeof(uint32_T)];
    int_T     i;
    int_T     j;
    numString temp;
    
    temp.num = value;

    /* data already in the desired "little endian" format? */
    if (!endianess) {
    
        /* 
         * nope - this function is being run on a big endian platform 
         *
         * -> need to reverse byte order prior to sending data as it is 
         *    assumed that the line carries "little endian" data only.
         */
        PRINT_DEBUG_MSG_LVL4("Running on big endian platform  -->  reversing byte order");
        PRINT_DEBUG_MSG_NL4;

        i = sizeof(uint32_T);
        j = 0;
        
        while (j < sizeof(uint32_T)) {
        
            c[j] = temp.string[i-1];
            j++;
            i--;
            
        }
        
        memcpy(temp.string, c, sizeof(uint32_T));
        
    }

    /* 
     * at this stage the (outgoing) data is in the desired "little endian" format.
     * -> do we need to filter the data to escape special characters?
     */
    if (doFilter) {
    
        /* 
         * yes -> escape special characters 
         *        converted data size: 4 to 8 bytes
         */
        return Filter(dest, temp.string, sizeof(uint32_T));
    
    } else {
    
        /* nope -> do not escape any characters */
        memcpy(dest, temp.string, sizeof(uint32_T));
        
        /* converted data size: 4 bytes */
        return sizeof(uint32_T);
        
    }
    
} /* end Num2String */


/* Function: String2Num ========================================================
 * Abstract:
 *  Translates strings into unsigned long values and returns the size of the
 *  value of the number.
 */
PRIVATE uint32_T String2Num(uint8_T *source, boolean_T endianess) {

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("String2Num")

    numString temp;
    numString temp2;

    int_T i;
    int_T j;

    temp.num  = 0; /* For compilation warning using lcc. */
    temp2.num = 0; /* For compilation warning using lcc. */

    memcpy(temp.string, source, 4);

    /* data already in the desired "little endian" format? */
    if (!endianess) {
    
        /* 
         * nope - this function is being run on a big endian platform 
         *
         * -> need to reverse byte order of received data as it is 
         *    assumed that the line carries "little endian" data only.
         */
        PRINT_DEBUG_MSG_LVL4("Running on big endian platform  -->  reversing byte order");
        PRINT_DEBUG_MSG_NL4;

        i = sizeof(uint32_T);
        j = 0;
        temp2.num = 0ul;

        while (j < 4) {
        
            temp2.string[i-1] = temp.string[j];
            j++;
            i--;
        
        }
        
        return temp2.num;
        
    } else {
    
        /* yes - platform is little endian  -->  no byte swapping is required */
        return temp.num;
        
    }
    
} /* end String2Num */


/* Function: SetExtSerialPacket ================================================
 * Abstract:
 *  Sets (sends) the contents of an ExtSerialPacket on the comm line.  This
 *  includes the packet's buffer as well as all serial communication overhead
 *  associated with the packet.
 *
 *  EXT_NO_ERROR is returned on success, EXT_ERROR on failure.
 */
PUBLIC boolean_T SetExtSerialPacket(ExtSerialPacket *pkt, ExtSerialPort *portDev) {

    uint_T    i;
    uint32_T  numAct       = 0; /* Num bytes actually sent.   */
    uint32_T  numExp       = 0; /* Num bytes ordered to send. */
    uint32_T  newByteCnt   = 0; /* Num bytes after filtering. */
    uint32_T  bytesWritten = 0; /* Num bytes written by send. */
    boolean_T error        = EXT_NO_ERROR;

    uint8_T   Buffer[sizeof(uint32_T)*2]; /* Local buffer for converting escape chars. */

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("SetExtSerialPacket")

    PRINT_DEBUG_MSG_LVL3("IN");
    PRINT_DEBUG_MSG_NL3;

    /* If not connected, return immediately. */
    if (!portDev->fConnected) return false;

    /* Initialize some fileds of the packet. */
    pkt->head[0]      = packet_head;
    pkt->head[1]      = packet_head;
    pkt->tail[0]      = packet_tail;
    pkt->tail[1]      = packet_tail;
    pkt->state        = ESP_NoPacket;
    pkt->cursor       = 0;
    pkt->DataCount    = 0;
    pkt->inQuote      = false;

    /* Debug messages: Send the packet header. */
    PRINT_DEBUG_MSG_LVL4("State -> ESP_InHead");
    PRINT_DEBUG_MSG_NL4;

    /* Send the packet header. */
    error = ExtSerialPortSetData(portDev, pkt->head, HEAD_SIZE, &bytesWritten);
    if (error != EXT_NO_ERROR) goto EXIT_POINT;
    numAct = bytesWritten;
    numExp = HEAD_SIZE;

    /* Debug messages: Send the packet type. */
    PRINT_DEBUG_MSG_LVL4("State -> ESP_InType");
    #if DEBUG_MSG_LVL >= 4
    if (pkt->PacketType == UNDEFINED_PACKET) {

        PRINT_DEBUG_MSG_LVL4_Raw(" (UNDEFINED_PACKET)");

    }
    if (pkt->PacketType == EXTMODE_PACKET) {

        PRINT_DEBUG_MSG_LVL4_Raw(" (EXTMODE_PACKET)");

    }
    if (pkt->PacketType == ACK_PACKET) {

        PRINT_DEBUG_MSG_LVL4_Raw(" (ACK_PACKET)");

    }
    #endif
    PRINT_DEBUG_MSG_NL4;

    /* Send the packet type. */
    newByteCnt = Filter(Buffer, &(pkt->PacketType), PACKET_TYPE_SIZE);
    error = ExtSerialPortSetData(portDev, Buffer, newByteCnt, &bytesWritten);
    if (error != EXT_NO_ERROR) goto EXIT_POINT;
    numAct += bytesWritten;
    numExp += newByteCnt;

    /* Debug messages: Send the size of the packet buffer. */
    PRINT_DEBUG_MSG_LVL4("State -> ESP_InSize (");
    PRINT_DEBUG_MSG_LVL4_UDec((uint16_T)pkt->size);
    PRINT_DEBUG_MSG_LVL4_Raw(" bytes)");
    PRINT_DEBUG_MSG_NL4;

    {
        /* additional debug message */
        uint8_T  *buf = (uint8_T *)&(pkt->size);
        
        PRINT_DEBUG_MSG_LVL5(">>> size info bytes stored in pkt->size: [ ");
        for (i = 0; i < sizeof(pkt->size); i++) {

            PRINT_DEBUG_MSG_LVL5_UHex((uint16_T)buf[i]);
            PRINT_DEBUG_MSG_LVL5_Raw(" ");

        }

        PRINT_DEBUG_MSG_LVL5_Raw(" ]");
        PRINT_DEBUG_MSG_NL5;

    }

    /* Convert the size of the packet buffer. */
    newByteCnt = Num2String(Buffer, pkt->size, true, portDev->isLittleEndian);

    {
        /* additional debug message */
        uint8_T  *buf = (uint8_T *)&(Buffer);
        
        PRINT_DEBUG_MSG_LVL5(">>> size info bytes in 'little endian' line format: [ ");
        for (i = 0; i < newByteCnt; i++) {

            PRINT_DEBUG_MSG_LVL5_UHex((uint16_T)buf[i]);
            PRINT_DEBUG_MSG_LVL5_Raw(" ");

        }

        PRINT_DEBUG_MSG_LVL5_Raw(" ]");
        PRINT_DEBUG_MSG_NL5;

    }

    /* Send the size of the packet buffer. */
    error = ExtSerialPortSetData(portDev, Buffer, newByteCnt, &bytesWritten);
    if (error != EXT_NO_ERROR) goto EXIT_POINT;
    numAct += bytesWritten;
    numExp += newByteCnt;


    /* Send the variable-sized packet buffer data. */
    PRINT_DEBUG_MSG_LVL4("State -> ESP_InPayload");
    PRINT_DEBUG_MSG_NL4;
    for(i = 0; i < pkt->size; i++) {

        #ifdef MATLAB_MEX_FILE
        PRINT_DEBUG_MSG_LVL5("Data element ");
        PRINT_DEBUG_MSG_LVL5_UDec(i + 1);
        PRINT_DEBUG_MSG_LVL5_Raw("/");
        PRINT_DEBUG_MSG_LVL5_UDec(pkt->size);
        PRINT_DEBUG_MSG_LVL5_Raw(": ");
        PRINT_DEBUG_MSG_LVL5_UHex(pkt->Buffer[i]);
        PRINT_DEBUG_MSG_NL5;
        #endif /* MATLAB_MEX_FILE */

        /* Filter packet data */
        newByteCnt = Filter(Buffer, &(pkt->Buffer[i]), 1);

        #ifdef MATLAB_MEX_FILE
        PRINT_DEBUG_MSG_LVL5("Converted data element ");
        PRINT_DEBUG_MSG_LVL5_UDec(i + 1);
        PRINT_DEBUG_MSG_LVL5_Raw("/");
        PRINT_DEBUG_MSG_LVL5_UDec(pkt->size);
        PRINT_DEBUG_MSG_LVL5_Raw(": ");
        #if DEBUG_MSG_LVL >= 5
        {
            int_T  kk;
            
            for(kk = 0; kk < newByteCnt; kk++) {

                PRINT_DEBUG_MSG_LVL5_UHex((uint16_T)Buffer[kk]);
                PRINT_DEBUG_MSG_LVL5_Raw(" ");

            }
        }
        #endif
        PRINT_DEBUG_MSG_NL5;
        #endif /* MATLAB_MEX_FILE */

        /* Send next byte */
        error = ExtSerialPortSetData(portDev, Buffer, newByteCnt, &bytesWritten);
        
        if (error != EXT_NO_ERROR) goto EXIT_POINT;
        numAct += bytesWritten;
        numExp += newByteCnt;
        
    }


    /* Debugging messages: Send the packet tail. */
    PRINT_DEBUG_MSG_LVL4("State -> ESP_InTail");
    PRINT_DEBUG_MSG_NL4;

    /* Send the packet tail. */
    error = ExtSerialPortSetData(portDev, pkt->tail, TAIL_SIZE, &bytesWritten);
    if (error != EXT_NO_ERROR) goto EXIT_POINT;
    numAct += bytesWritten;
    numExp += TAIL_SIZE;
 
    /*
     * Return false if actual number of bytes sent does not equal the expected
     * number of bytes.  Otherwise, return true.
     */
    if (numAct != numExp) {
        error = EXT_ERROR;
        goto EXIT_POINT;
    }

EXIT_POINT:

    PRINT_DEBUG_MSG_LVL3("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL3_UDec(error);
    PRINT_DEBUG_MSG_NL3;

    return error;

} /* end SetExtSerialPacket */


/* Function: GetExtSerialPacket ================================================
 * Abstract:
 *  Examines incoming bytes for a packet header and discards any chars that do
 *  not fit into a packet header.  After receiving a packet header, records
 *  incoming bytes into a packet buffer until a packet tail is read.  Compares
 *  incoming bytes with the escape character and handles any escaped chars
 *  appropriately (escape char is discarded and next char is exclusive or'd
 *  with the mask character).
 *
 *  EXT_NO_ERROR is returned on success, EXT_ERROR on failure.
 */
PUBLIC boolean_T GetExtSerialPacket(ExtSerialPacket *pkt, ExtSerialPort *portDev) {

    uint_T    i;
    uint8_T   char1        = 0;
    uint32_T  numCharRecvd = 0;
    boolean_T doFilter     = false;
    boolean_T PacketError  = false;
    boolean_T error        = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("GetExtSerialPacket")

    PRINT_DEBUG_MSG_LVL3("IN");
    PRINT_DEBUG_MSG_NL3;

    /* If not connected, return immediately. */
    if (!portDev->fConnected) return EXT_ERROR;

    /* Initialize some fields of the packet. */
    pkt->head[0]      = packet_head;
    pkt->head[1]      = packet_head;
    pkt->tail[0]      = packet_tail;
    pkt->tail[1]      = packet_tail;
    pkt->state        = ESP_NoPacket;
    pkt->cursor       = 0;
    pkt->DataCount    = 0;
    pkt->inQuote      = false;


    /* debug messages: waiting for the beginning of the next packet */
    PRINT_DEBUG_MSG_LVL3("State -> ESP_NoPacket");
    PRINT_DEBUG_MSG_NL3;

    while (1) {
    
        /* Get a character from input stream. */
        error = ExtSerialPortGetRawChar(portDev, &char1, &numCharRecvd);
        if (error != EXT_NO_ERROR) goto EXIT_POINT;

        if (numCharRecvd != 1) {
        
            pkt->state  = ESP_NoPacket;
            pkt->cursor = 0;
            error       = EXT_ERROR;
            
            goto EXIT_POINT;
            
        }

        /* Handle quoting and filtering (does not deal with xon/xoff issues). */
        switch (pkt->state) {
        
          case ESP_InType:
          case ESP_InSize:
          case ESP_InPayload:
          
            /* Handle quoted characters in payload. */
            if (pkt->inQuote) {
            
                pkt->inQuote  = false;
                char1        ^= mask_character;
                
            } else {
            
                /*
                 * No characters requiring escaping should be in the input
                 * stream, except for control purposes.
                 */
                switch (char1) {
                
                  case escape_character:
                  
                    //PRINT_DEBUG_MSG_LVL1_Raw("*\n\r");
                    pkt->inQuote = true;
                    
                    /* Need to go get next charater at this point. */
                    break;
                    /*
                     * other special characters should only exist
                     * in payload when quoted.
                     */
                  
                  case packet_head:
                  
                    /*
                     * Error - start handling the packet this header
                     * goes with.
                     */
                    PRINT_DEBUG_MSG_LVL1("Error. Received unexpected packet_head... resetting packet cursor.\n\r");
                    
                    pkt->cursor   = (uint8_T *)&pkt->head;
                   *pkt->cursor++ = char1;
                    pkt->DataCount++;
                    pkt->state    = ESP_InHead;
                    continue;
                    
                  case packet_tail:
                  
                    /* Error - reset packet handling. */
                    PRINT_DEBUG_MSG_LVL1("Error. Received unexpected packet_tail.\n\r");
                    
                    pkt->cursor = 0;
                    pkt->state  = ESP_NoPacket;
                    PacketError = false;
                    break;
                    
                  default:
                  
                    break;
                    
                }  /* switch(char1) */
                
            }
            
            break;

          /* No quoting in non-payload portions. */
          case ESP_NoPacket:
          case ESP_InHead:
          case ESP_InTail:
          case ESP_Complete:
          default:
          
            break;
            
        }  /* switch (pkt->state)   ... handling of quoted characters */


        #ifdef ERASE
        PRINT_DEBUG_MSG_LVL1_Raw("0x");
        PRINT_DEBUG_MSG_LVL1_UHex((uint16_T)char1);
        PRINT_DEBUG_MSG_LVL1_Raw("\n\r");
        #endif


        /* handle reception of 'unquoted' data*/
        if (!pkt->inQuote) {
        
            /* process unquoted character */
            switch (pkt->state) {

              case ESP_NoPacket:

                PRINT_DEBUG_MSG_LVL4("State -> ESP_NoPacket");
                PRINT_DEBUG_MSG_NL4;

                if (char1 == packet_head) {

                    /*
                     * When a byte matches a packet header tag byte,
                     * save it and change state.
                     */
                    pkt->cursor   = (uint8_T *)&pkt->head;
                   *pkt->cursor++ = char1;
                    pkt->DataCount++;
                    pkt->state    = ESP_InHead;
                }
                
                break;
                
              case ESP_InHead:
              
                PRINT_DEBUG_MSG_LVL4("State -> ESP_InHead");
                PRINT_DEBUG_MSG_NL4;

                if (char1 == packet_head) {
                
                    /*
                     * In this state, the only acceptable input is a packet header
                     * tag byte which will cause packet processing to progress to
                     * the next state.
                     */
                   *pkt->cursor++  = char1;
                    pkt->DataCount = 0;
                    pkt->state     = ESP_InType;
                    pkt->cursor    = (uint8_T *)&pkt->PacketType;
                    
                } else {
                
                    PacketError = true; 
                    
                }
                
                break;
                
              case ESP_InType:
              
                PRINT_DEBUG_MSG_LVL4("State -> ESP_InType");
                #if DEBUG_MSG_LVL >= 4
                if (char1 == UNDEFINED_PACKET) {

                    PRINT_DEBUG_MSG_LVL4_Raw(" (UNDEFINED_PACKET)");

                }
                if (char1 == EXTMODE_PACKET) {

                    PRINT_DEBUG_MSG_LVL4_Raw(" (EXTMODE_PACKET)");

                }
                if (char1 == ACK_PACKET) {

                    PRINT_DEBUG_MSG_LVL4_Raw(" (ACK_PACKET)");

                }
                #endif
                PRINT_DEBUG_MSG_NL4;

                if (pkt->DataCount < sizeof(pkt->PacketType)) {
                
                    /*
                     * In this state, the byte count determines where this
                     * state stands.
                     */
                   *pkt->cursor++ = char1;
                    pkt->DataCount++;
                    
                    if (pkt->DataCount == sizeof(pkt->PacketType)) {
                    
                        pkt->state     = ESP_InSize;
                        pkt->cursor    = (uint8_T *)&pkt->size;
                        pkt->DataCount = 0;
                        
                    }
                    
                } else {
                
                    PacketError = true; 
                    
                }
                
                break;
                
              case ESP_InSize:
              
                #if DEBUG_MSG_LVL > 0
                if (pkt->DataCount == 0) {
                
                    PRINT_DEBUG_MSG_LVL4("State -> ESP_InSize");
                    PRINT_DEBUG_MSG_NL4;
                    PRINT_DEBUG_MSG_LVL5(">>> size info bytes in 'little endian' line format (RX buffer): [ ");
                    
                }
                #endif

                if (pkt->DataCount < sizeof(pkt->size)) {
                
                    PRINT_DEBUG_MSG_LVL5_UHex((uint16_T)char1);
                    PRINT_DEBUG_MSG_LVL5_Raw(" ");
                    
                    /*
                     * In this state, the byte count determines where this
                     * state stands.
                     */
                   *pkt->cursor++ = char1;
                    pkt->DataCount++;
                    
                    if (pkt->DataCount == sizeof(pkt->size)) {
                    
                        PRINT_DEBUG_MSG_LVL5_Raw(" ]");
                        PRINT_DEBUG_MSG_NL5;

                        pkt->size = String2Num((uint8_T *)&pkt->size, portDev->isLittleEndian);
                        
                        {
                            /* additional debug message */
                            uint8_T  *buf = (uint8_T *)&(pkt->size);
                            
                            PRINT_DEBUG_MSG_LVL5(">>> size info bytes stored in pkt->size: [ ");
                            for (i = 0; i < sizeof(pkt->size); i++) {

                                PRINT_DEBUG_MSG_LVL5_UHex((uint16_T)buf[i]);
                                PRINT_DEBUG_MSG_LVL5_Raw(" ");

                            }

                            PRINT_DEBUG_MSG_LVL5_Raw(" ]");
                            PRINT_DEBUG_MSG_NL5;

                        }

                        PRINT_DEBUG_MSG_LVL4("Number of data bytes in message: ");
                        PRINT_DEBUG_MSG_LVL4_UDec((uint16_T)pkt->size);
                        PRINT_DEBUG_MSG_NL4;

                        pkt->DataCount = 0;
                        if (pkt->size != 0) {
                        
                            pkt->state  = ESP_InPayload;
                            pkt->cursor = (uint8_T *)pkt->Buffer;
                            
                        } else {
                        
                            pkt->state  = ESP_InTail;
                            pkt->cursor = (uint8_T *)&pkt->tail;
                            
                        }
                        
                    }
                    
                } else {
                
                    PacketError = true; 
                    
                }
                
                break;
                
              case ESP_InPayload:
              
                if (pkt->DataCount < pkt->size) {
                
                    /*
                     * In this state, the byte count determines where this
                     * state stands.
                     */
                   *pkt->cursor++ = char1;
                    pkt->DataCount++;
                    
                    PRINT_DEBUG_MSG_LVL4("State -> ESP_InPayload [");
                    PRINT_DEBUG_MSG_LVL4_UDec(pkt->DataCount);
                    PRINT_DEBUG_MSG_LVL4_Raw("/");
                    PRINT_DEBUG_MSG_LVL4_UDec(pkt->size);
                    PRINT_DEBUG_MSG_LVL4_Raw("]: ");
                    PRINT_DEBUG_MSG_LVL4_UHex((uint8_T)char1);
                    PRINT_DEBUG_MSG_NL4;

                    if (pkt->DataCount == pkt->size) {
                    
                        pkt->state     = ESP_InTail;
                        pkt->cursor    = (uint8_T *)&pkt->tail;
                        pkt->DataCount = 0;
                        
                    }
                    
                } else {
                
                    PacketError = true; 
                    
                }
                
                break;
                
              case ESP_InTail:
              
                PRINT_DEBUG_MSG_LVL4("State -> ESP_InTail");
                PRINT_DEBUG_MSG_NL4;

                if (pkt->DataCount < sizeof(pkt->tail)) {
                
                    if (char1 == packet_tail) {
                    
                        /*
                         * In this state, the only acceptable input is a packet
                         * tail tag byte.
                         */
                       *pkt->cursor++ = char1;
                        pkt->DataCount++;
                        
                        if (pkt->DataCount == sizeof(pkt->tail)) {
                        
                            pkt->state     = ESP_Complete;
                            pkt->cursor    = NULL;
                            pkt->DataCount = 0;
                            
                            if (pkt->state != ESP_Complete) error = EXT_ERROR;
                            
                            goto EXIT_POINT;
                            
                        }
                        
                    } else {
                    
                        PacketError = true; 
                        
                    }
                    
                } else {
                
                    PacketError = true; 
                    
                }
                
                break;
                
              case ESP_Complete:
              
                PRINT_DEBUG_MSG_LVL4("State -> ESP_Complete");
                PRINT_DEBUG_MSG_NL4;

                break;
                
              default:
              
                break;
                
            }  /* switch (pkt->state)   ... reception of 'unquoted' data */


            /* handle all errors centrally (= here) */
            if (PacketError) {
            
                PRINT_DEBUG_MSG_LVL4("Packet error. New state -> ESP_NoPacket");
                PRINT_DEBUG_MSG_NL4;

                pkt->cursor = 0;
                pkt->state  = ESP_NoPacket;
                PacketError = false;
                
            }
            
        }  /* if (!inQuote) */
        
    } /* end-of-while */


EXIT_POINT:

    PRINT_DEBUG_MSG_LVL3("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL3_UDec(error);
    PRINT_DEBUG_MSG_NL3;

    return error;

} /* end GetExtSerialPacket */



/* Function: CheckExtSerialPacket =================================================
 * Abstract:
 *  Checks RX ring buffer to determine if at least one full packet has been received.
 *
 *  TRUE is returned if at least one packet is available, FALSE if not.
 *
 */
boolean_T CheckExtSerialPacket(ExtSerialPort *portDev) {

    uint16_T       i                 = peekCounter;          /* retrieve current peek counter from previously stored value           */
    uint_T         currTailOffset    = peekTailOffset;       /* retrieve current peek tail offset from previously stored value       */
    int_T          currState         = peekState;            /* retrieve current peek state from previously stored value             */
    uint32_T       currSize          = peekDataSize;         /* retrieve current peek payload data size from previously stored value */
    
    uint8_T        char1;
    uint16_T       totalNumBytes;
    int32_T        totalBytesPending;

    /* packet handling... */
    uint8_T       *currSizePtr       = (uint8_T *)&(currSize);
    uint32_T       DataCount         = 0;
    boolean_T      inQuote           = false;
    boolean_T      PacketError       = false;
    boolean_T      packetAvailable   = false;


    // local function name... debugging only
    DEFINE_DEBUG_FNAME("CheckExtSerialPacket")

    PRINT_DEBUG_MSG_LVL4("IN");
    PRINT_DEBUG_MSG_NL4;

    
    /* fetch current number of pending bytes */
    ExtSerialPortDataPending(portDev, &totalBytesPending);
    
    /* set initial while-loop limit */
    totalNumBytes = (uint16_T)totalBytesPending;

    /* enough data in the RB reception buffer -> need to check for valid packet... */
    #if DEBUG_MSG_LVL >= 3
    if (i > peekCounterOld) {

        /* adjust peekCounterOld */
        peekCounterOld = i;
        
        /* feedback (only displayed once) */
        PRINT_DEBUG_MSG_LVL3("Number of bytes in the RX/COM buffer: ");
        PRINT_DEBUG_MSG_LVL3_UDec(totalNumBytes);
        PRINT_DEBUG_MSG_NL3;
        
    }
    #endif

    /* 
     * there need to be at least 'peekPacketSize' bytes in the ring buffer, 
     * if not -> return right away
     */
    if (totalNumBytes < peekPacketSize) {

        /* not enough data for even the smallest possible packet */
        
        /* debug message control */
        #if DEBUG_MSG_LVL > 0
        {
            
            uint16_T  kk;
            int32_T   currBytesPending;

            /* new data in buffer? */
            if (i == peekCounterOld) {
            
                /* nope - nothing new for a while? */
                if (peekNilAtts++ > 60000) {
                    
                    /* giving up... display the current buffer contents */
                    PRINT_DEBUG_MSG_LVL3("Communitcation stuck? Displaying current RX buffer contents...");
                    PRINT_DEBUG_MSG_NL3;
                    
                    /* fetch number of bytes in RX buffer */
                    ExtSerialPortDataPending(portDev, &currBytesPending);
                    currBytesPending = ((uint16_T)currBytesPending > i) ? currBytesPending : i;
                    
                    PRINT_DEBUG_MSG_LVL3("Looking for ");
                    PRINT_DEBUG_MSG_LVL3_UDec(peekPacketSize);
                    PRINT_DEBUG_MSG_LVL3_Raw(" bytes.");
                    PRINT_DEBUG_MSG_NL3;
                    PRINT_DEBUG_MSG_LVL3("Processed the first ");
                    PRINT_DEBUG_MSG_LVL3_UDec(i);
                    PRINT_DEBUG_MSG_LVL3_Raw(" bytes.");
                    PRINT_DEBUG_MSG_NL3;
                    PRINT_DEBUG_MSG_LVL3("Total number of bytes pending: ");
                    PRINT_DEBUG_MSG_LVL3_UDec((uint16_T)currBytesPending);
                    PRINT_DEBUG_MSG_NL3;

                    /* display current contents of RX buffer */
                    for (kk = 0; kk < (uint16_T)currBytesPending; kk++) {
                    
                        /* get a copy of the next character on the ring buffer */
                        ExtSerialPortPeekRawChar(portDev, &char1, &currTailOffset);
                        
                        PRINT_DEBUG_MSG_LVL3("[");
                        PRINT_DEBUG_MSG_LVL3_UDec(kk + 1);
                        PRINT_DEBUG_MSG_LVL3_Raw("/");
                        PRINT_DEBUG_MSG_LVL3_UDec((uint16_T)currBytesPending);
                        PRINT_DEBUG_MSG_LVL3_Raw("]: ");
                        PRINT_DEBUG_MSG_LVL3_UHex((uint16_T)char1);
                        PRINT_DEBUG_MSG_LVL3_Raw(" (currTailOffset: ");
                        PRINT_DEBUG_MSG_LVL3_UDec(currTailOffset);
                        PRINT_DEBUG_MSG_LVL3_Raw(")");
                        PRINT_DEBUG_MSG_NL3;
                        
                    }  /* for kk */
                    
                    /* reset peekNilAtts counter */
                    peekNilAtts = 0;
                    
                }  /* peekNilAtts > 60000 */
                
            }  /* i == peekCounterOld */
            
        }
        #endif  /* DEBUG_MSG_LVL */
        
        /* return */
        goto EXIT_POINT;
        
    } else {
        
        /* 
         * at least 'peekPacketSize' bytes in the ring buffer
         * -> limit search to 'peekPacketSize' (just in case...)
         */
        totalNumBytes = peekPacketSize;
        
        /* enough data for a new packet -> reset peekAttempt counter and peekCounterOld */
        peekNilAtts    = 0;
        peekCounterOld = 0;
        
    }

    /* ... display saved context */
    #if DEBUG_MSG_LVL >= 5
    {

        PRINT_DEBUG_MSG_LVL5("Restoring peeking index: ");
        PRINT_DEBUG_MSG_LVL5_UDec(peekCounter);
        PRINT_DEBUG_MSG_NL5;
        
        PRINT_DEBUG_MSG_LVL5("Restoring peeking state: ");
        switch (peekState) {
            
            case ESP_NoPacket:
                PRINT_DEBUG_MSG_LVL5_Raw("ESP_NoPacket.");
                break;
            case ESP_InHead:
                PRINT_DEBUG_MSG_LVL5_Raw("ESP_InHead.");
                break;
            case ESP_InType:
                PRINT_DEBUG_MSG_LVL5_Raw("ESP_InType.");
                break;
            case ESP_InSize:
                PRINT_DEBUG_MSG_LVL5_Raw("ESP_InSize.");
                break;
            case ESP_InPayload:
                PRINT_DEBUG_MSG_LVL5_Raw("ESP_InPayload.");
                break;
            case ESP_InTail:
                PRINT_DEBUG_MSG_LVL5_Raw("ESP_InTail.");
                break;
            case ESP_Complete:
                PRINT_DEBUG_MSG_LVL5_Raw("ESP_Complete.");
                break;
            default:
                PRINT_DEBUG_MSG_LVL5_Raw("ESP_Unknown.");
                break;
            break;
        }
        PRINT_DEBUG_MSG_NL5;

        PRINT_DEBUG_MSG_LVL5("Restoring peeking tailOffset: ");
        PRINT_DEBUG_MSG_LVL5_UDec(peekTailOffset);
        PRINT_DEBUG_MSG_NL5;
        
        PRINT_DEBUG_MSG_LVL5("Restoring peeking payload data size: ");
        PRINT_DEBUG_MSG_LVL5_UDec(peekDataSize);
        PRINT_DEBUG_MSG_NL5;
        
    }
    #endif  /* DEBUG_MSG_LVL >= 5 */    

    /* cycle through all available data... */
    while (i < totalNumBytes) {
    
        /* get a copy of the next character on the ring buffer */
        ExtSerialPortPeekRawChar(portDev, &char1, &currTailOffset);
        
        PRINT_DEBUG_MSG_LVL4("[");
        PRINT_DEBUG_MSG_LVL4_UDec(i + 1);
        PRINT_DEBUG_MSG_LVL4_Raw("/");
        PRINT_DEBUG_MSG_LVL4_UDec(totalNumBytes);
        PRINT_DEBUG_MSG_LVL4_Raw("]: ");
        PRINT_DEBUG_MSG_LVL4_UHex((uint16_T)char1);
        PRINT_DEBUG_MSG_LVL4_Raw(" (currTailOffset: ");
        PRINT_DEBUG_MSG_LVL4_UDec(currTailOffset);
        PRINT_DEBUG_MSG_LVL4_Raw(")");
        PRINT_DEBUG_MSG_NL4;
      
        /* Handle quoting and filtering (does not deal with xon/xoff issues). */
        switch (currState) {
        
          case ESP_InType:
          case ESP_InSize:
          case ESP_InPayload:
          
            /* Handle quoted characters in payload. */
            if (inQuote) {
            
                inQuote   = false;
                char1    ^= mask_character;
                
            } else {
            
                /*
                 * No characters requiring escaping should be in the input
                 * stream, except for control purposes.
                 */
                switch (char1) {
                
                  case escape_character:
                  
                    //PRINT_DEBUG_MSG_LVL1_Raw("*\n\r");
                    inQuote = true;
                    
                    /* Need to go get next charater at this point. */
                    break;
                    /*
                     * other special characters should only exist
                     * in payload when quoted.
                     */
                  
                  case packet_head:
                  
                    /*
                     * Error - start handling the packet this header
                     * goes with.
                     */
                    PRINT_DEBUG_MSG_LVL1("Error. Received unexpected packet_head...\n\r");

                    #if DEBUG_MSG_LVL > 0
                    {
                        /* additional debug information */
                        PRINT_DEBUG_MSG_LVL1("Error. Detected unexpected packet_head (");
                        PRINT_DEBUG_MSG_LVL1_UHex((uint16_T)char1);
                        #ifndef MATLAB_MEX_FILE
                        PRINT_DEBUG_MSG_LVL1_Raw("). Buffer contents:");
                        PRINT_DEBUG_MSG_NL1;
                        PRINT_DEBUG_MSG_LVL1_Raw("[");
                        /* display up to FIFOBUFSIZE bytes... */
                        ExtSerialPortPeekRB(FIFOBUFSIZE);
                        PRINT_DEBUG_MSG_LVL1_Raw(" ]");
                        #else
                        /* debugging on the host... currently only display variable 'currState' and continue */
                        PRINT_DEBUG_MSG_LVL1("Restored (= current) state: ");
                        //switch (peekState) {
                        switch (currState) {
                            
                            case ESP_NoPacket:
                                PRINT_DEBUG_MSG_LVL1_Raw("ESP_NoPacket.");
                                break;
                            case ESP_InHead:
                                PRINT_DEBUG_MSG_LVL1_Raw("ESP_InHead.");
                                break;
                            case ESP_InType:
                                PRINT_DEBUG_MSG_LVL1_Raw("ESP_InType.");
                                break;
                            case ESP_InSize:
                                PRINT_DEBUG_MSG_LVL1_Raw("ESP_InSize.");
                                break;
                            case ESP_InPayload:
                                PRINT_DEBUG_MSG_LVL1_Raw("ESP_InPayload.");
                                break;
                            case ESP_InTail:
                                PRINT_DEBUG_MSG_LVL1_Raw("ESP_InTail.");
                                break;
                            case ESP_Complete:
                                PRINT_DEBUG_MSG_LVL1_Raw("ESP_Complete.");
                                break;
                            default:
                                PRINT_DEBUG_MSG_LVL1_Raw("ESP_Unknown.");
                                break;
                            break;
                        }
                        PRINT_DEBUG_MSG_NL1;
                        #endif
                        PRINT_DEBUG_MSG_NL1;
                    }
                    #endif

                    /* currently no recovery implemented (fw-05-10) */
                    abort_LED(71);

                    goto EXIT_POINT;
                    
                  case packet_tail:
                  
                    /* Error - reset packet handling. */
                    PRINT_DEBUG_MSG_LVL1("Error. Received unexpected packet_tail.\n\r");

                    #if DEBUG_MSG_LVL > 0
                    {
                        /* additional debug information */
                        PRINT_DEBUG_MSG_LVL1("Error. Detected unexpected packet_tail (");
                        PRINT_DEBUG_MSG_LVL1_UHex((uint16_T)char1);
                        PRINT_DEBUG_MSG_LVL1_Raw("). Buffer contents:");
                        PRINT_DEBUG_MSG_NL1;
                        #ifndef MATLAB_MEX_FILE
                        PRINT_DEBUG_MSG_LVL1_Raw("[");
                        /* display up to FIFOBUFSIZE bytes... */
                        ExtSerialPortPeekRB(FIFOBUFSIZE);
                        PRINT_DEBUG_MSG_LVL1_Raw(" ]");
                        PRINT_DEBUG_MSG_NL1;
                        #endif
                    }
                    #endif

                    /* currently no recovery implemented (fw-05-10) */
                    abort_LED(72);

                    /* display state of communications variables on port T */
                    #if COMMSTATE_ON_PTT == 1
                    PTT |=  0x08;    /* indicate the detection of an erroneous packet */
                    #endif

                    goto EXIT_POINT;
                    
                  default:
                  
                    break;
                    
                }  /* switch(char1) */
                
            }
            
            break;

          /* No quoting in non-payload portions. */
          case ESP_NoPacket:
          case ESP_InHead:
          case ESP_InTail:
          case ESP_Complete:
          default:
          
            break;
            
        }  /* switch (currState)   ... handling of quoted characters */


        /* handle reception of 'unquoted' data*/
        if (!inQuote) {
        
            /* process unquoted character */
            switch (currState) {

              case ESP_NoPacket:

                if (char1 == packet_head) {

                    PRINT_DEBUG_MSG_LVL4("ESP_InHead");
                    PRINT_DEBUG_MSG_NL4;

                    /*
                     * When a byte matches a packet header tag byte,
                     * save it and change state.
                     */
                    currState = ESP_InHead;
                    
                }
                
                break;
                
              case ESP_InHead:
              
                PRINT_DEBUG_MSG_LVL4("ESP_InHead");
                PRINT_DEBUG_MSG_NL4;

                if (char1 == packet_head) {
                
                    /*
                     * In this state, the only acceptable input is a packet header
                     * tag byte which will cause packet processing to progress to
                     * the next state.
                     */
                    currState = ESP_InType;
                    
                } else {
                
                    PacketError = true; 
                    
                }
                
                break;
                
              case ESP_InType:
              
                PRINT_DEBUG_MSG_LVL4("ESP_InType");
                PRINT_DEBUG_MSG_NL4;

                DataCount = 0;
                currState = ESP_InSize;
                
                break;
                
              case ESP_InSize:
              
                PRINT_DEBUG_MSG_LVL4("ESP_InSize");
                PRINT_DEBUG_MSG_NL4;

                PRINT_DEBUG_MSG_LVL4("DataCount: ");
                PRINT_DEBUG_MSG_LVL4_UDec((uint16_T)DataCount);
                PRINT_DEBUG_MSG_LVL4_Raw(" (< ");
                PRINT_DEBUG_MSG_LVL4_UDec((uint16_T)sizeof(currSize));
                PRINT_DEBUG_MSG_LVL4_Raw(")");
                PRINT_DEBUG_MSG_NL4;

                if (DataCount < sizeof(currSize)) {
                
                    /* read size (uint32_T)
                     *
                     * assumes that all data on the line is 'little endian' (LSB first, always the case)
                     * and that the target can be either 'little endian' or 'big endian' (-> byte order reversal necessary)
                     */
                    if (portDev->isLittleEndian) {
                        
                        /* little endian -> no byte order reversal */
                        currSizePtr[DataCount++]     = char1;
                        
                    } else {
                        
                        /* bit endian -> byte order reversal */
                        currSizePtr[3 - DataCount++] = char1;
                        
                    }
                    
                }
                
                /* have all 4 'size' bytes been processed yet? */
                if (DataCount == sizeof(currSize)) {
                
                    PRINT_DEBUG_MSG_LVL3("Payload size: ");
                    PRINT_DEBUG_MSG_LVL3_UHex((uint16_T)currSize);
                    PRINT_DEBUG_MSG_NL3;

                    /* yep -> switch state */
                    if(currSize != 0) {
                    
                        currState = ESP_InPayload;
                        
                    } else {
                        
                        currState = ESP_InTail;
                        
                    }
                    
                    /* prepare next state */
                    DataCount = 0;
                    
                    // TODO:  checksum to ensure that the size info is valid  (fw-05-10)
                    // TODO:  checksum to ensure that the size info is valid  (fw-05-10)
                    // TODO:  checksum to ensure that the size info is valid  (fw-05-10)
                    // TODO:  checksum to ensure that the size info is valid  (fw-05-10)

                    /* 
                     * size is valid -> set 'required packet size' (module global)
                     * -> packet size = current index (i + 1) + number of data bytes (currSize) + 2 (tail)
                     */
                    peekPacketSize = i + 1 + (uint16_T)currSize + 2;
                    
                    PRINT_DEBUG_MSG_LVL3("Setting peekPacketSize to ");
                    PRINT_DEBUG_MSG_LVL3_UDec(peekPacketSize);
                    PRINT_DEBUG_MSG_LVL3_Raw(" bytes.");
                    PRINT_DEBUG_MSG_NL3;

                    /* re-adjust the current limit of this while loop */
                    ExtSerialPortDataPending(portDev, &totalBytesPending);
                    totalNumBytes = (uint16_T)totalBytesPending;

                    /* check if we have already received enough bytes to process this packet */
                    if (peekPacketSize > totalNumBytes) {
                    
                        /* not enough bytes available */
                        
                        PRINT_DEBUG_MSG_LVL2("Suspending processing until there are ");
                        PRINT_DEBUG_MSG_LVL2_UDec(peekPacketSize);
                        PRINT_DEBUG_MSG_LVL2_Raw(" bytes in the comms line buffer / RX ring buffer.");
                        PRINT_DEBUG_MSG_NL2;
                        
                        /* next index... */
                        i++;

                        /* store 'peek context' */
                        peekCounter     = i;
                        peekTailOffset  = currTailOffset;
                        peekState       = currState;
                        peekDataSize    = currSize;
                        
                        /* ... display saved context */
                        #if DEBUG_MSG_LVL >= 5
                        {

                            PRINT_DEBUG_MSG_LVL5("Storing peeking index: ");
                            PRINT_DEBUG_MSG_LVL5_UDec(peekCounter);
                            PRINT_DEBUG_MSG_NL5;
                            
                            PRINT_DEBUG_MSG_LVL5("Storing peeking state: ");
                            switch (peekState) {
                                
                                case ESP_NoPacket:
                                    PRINT_DEBUG_MSG_LVL5_Raw("ESP_NoPacket.");
                                    break;
                                case ESP_InHead:
                                    PRINT_DEBUG_MSG_LVL5_Raw("ESP_InHead.");
                                    break;
                                case ESP_InType:
                                    PRINT_DEBUG_MSG_LVL5_Raw("ESP_InType.");
                                    break;
                                case ESP_InSize:
                                    PRINT_DEBUG_MSG_LVL5_Raw("ESP_InSize.");
                                    break;
                                case ESP_InPayload:
                                    PRINT_DEBUG_MSG_LVL5_Raw("ESP_InPayload.");
                                    break;
                                case ESP_InTail:
                                    PRINT_DEBUG_MSG_LVL5_Raw("ESP_InTail.");
                                    break;
                                case ESP_Complete:
                                    PRINT_DEBUG_MSG_LVL5_Raw("ESP_Complete.");
                                    break;
                                default:
                                    PRINT_DEBUG_MSG_LVL5_Raw("ESP_Unknown.");
                                    break;
                                break;
                            }
                            PRINT_DEBUG_MSG_NL5;

                            PRINT_DEBUG_MSG_LVL5("Storing peeking tailOffset: ");
                            PRINT_DEBUG_MSG_LVL5_UDec(peekTailOffset);
                            PRINT_DEBUG_MSG_NL5;
                            
                            PRINT_DEBUG_MSG_LVL5("Storing peeking payload data size: ");
                            PRINT_DEBUG_MSG_LVL5_UDec(peekDataSize);
                            PRINT_DEBUG_MSG_NL5;
                            
                        }
                        #endif  /* DEBUG_MSG_LVL >= 5 */

                        /* return */
                        goto EXIT_POINT;
                        
                    } else {
                        
                        /* limit search to 'peekPacketSize' (just in case...) */
                        totalNumBytes = peekPacketSize;
                        
                    }
                    
                }
                
                break;
                
              case ESP_InPayload:
              
                PRINT_DEBUG_MSG_LVL4("ESP_InPayload");
                PRINT_DEBUG_MSG_NL4;

                if (DataCount < currSize) {
                
                    /* all data bytes received? */
                    if (++DataCount == currSize) {
                        
                        /* yep -> switch state */
                        currState = ESP_InTail;
                        DataCount = 0;

                    }
                    
                } else {
                
                    PacketError = true; 
                    
                }
                
                break;
                
              case ESP_InTail:
              
                PRINT_DEBUG_MSG_LVL4("ESP_InTail");
                PRINT_DEBUG_MSG_NL4;

                if (DataCount < 2) {

                    /* in this state all bytes need to be 'packet_tail' */
                    if (char1 == packet_tail) {

                        if (++DataCount == 2) {
                        
                            /* SUCCESS SUCCESS SUCCESS */

                            /* display state of communications variables on port T */
                            #if COMMSTATE_ON_PTT == 1
                            PTT &= ~0x10;       /* indicate the no-timeout condition */
                            #endif
                                
                            /* reset stored peekCounter, peekDataSize, peekTailOffset and peekState */
                            peekCounter     = 0;
                            peekDataSize    = 0;
                            peekTailOffset  = 0;
                            peekState       = ESP_NoPacket;

                            /* reset 'peekPacketSize' to minimum required packet size */
                            peekPacketSize  = MIN_PACKET_SIZE;
                            
                            /* inidicate successful detection of complete packet */
                            packetAvailable = true;
                            
                            /* done with this packet -> leave while loop */
                            goto EXIT_POINT;
                            
                        }

                    } else {
                    
                        /* byte is not 'packet_tail' */
                        PacketError = true; 
                        
                    }
                    
                } else {
                
                    /* should never be reached... */
                    PacketError = true; 
                    
                }
                
                break;
                
              default:
              
                /* unknown state - should never happen */
                break;
                
            }  /* switch (currState)   ... reception of 'unquoted' data */


            /* handle all errors centrally (= here) */
            if (PacketError) {
            
                #if DEBUG_MSG_LVL > 0
                {
                    /* additional debug information */
                    PRINT_DEBUG_MSG_LVL1("Packet error. Resetting packet counter...");
                    PRINT_DEBUG_MSG_NL1;
                    PRINT_DEBUG_MSG_LVL1("Packet error at byte position ");
                    PRINT_DEBUG_MSG_LVL1_UDec((uint16_T)(i + 1));
                    #ifndef MATLAB_MEX_FILE
                    PRINT_DEBUG_MSG_LVL1_Raw(". Buffer contents:");
                    PRINT_DEBUG_MSG_NL1;
                    PRINT_DEBUG_MSG_LVL1_Raw("[");
                    /* display up to FIFOBUFSIZE bytes... */
                    ExtSerialPortPeekRB(FIFOBUFSIZE);
                    PRINT_DEBUG_MSG_LVL1_Raw(" ]");
                    #endif
                    PRINT_DEBUG_MSG_NL1;
                }
                #endif

                #ifndef MATLAB_MEX_FILE
                PRINT_DEBUG_MSG_LVL1("Removing erroneous packet.");
                PRINT_DEBUG_MSG_NL1;
                
                /* adjust tail offset */
                currTailOffset--;
                
                /* remove packet from RX ring buffer */
                ExtSerialPortMoveRBTail(currTailOffset);

                #if DEBUG_MSG_LVL > 0
                {
                    /* additional debug information */
                    PRINT_DEBUG_MSG_LVL1_Raw("New buffer contents:");
                    PRINT_DEBUG_MSG_NL1;
                    #ifndef MATLAB_MEX_FILE
                    PRINT_DEBUG_MSG_LVL1_Raw("[");
                    /* display up to FIFOBUFSIZE bytes... */
                    ExtSerialPortPeekRB(FIFOBUFSIZE);
                    PRINT_DEBUG_MSG_LVL1_Raw(" ]");
                    PRINT_DEBUG_MSG_NL1;
                    #endif
                }
                #endif  /* DEBUG_MSG_LVL */
                
                #endif  /* MATLAB_MEX_FILE */

                /* start over... */
                currState   = ESP_NoPacket;
                PacketError = false;
                
            }  /* if (PacketError) */
            
        }  /* if (!inQuote) */
        
        
        /* scanned all available data? */
        if (++i == totalNumBytes) {
        
            /* yep -> try re-adjusting the limit of this while loop */
            ExtSerialPortDataPending(portDev, &totalBytesPending);
            totalNumBytes = (uint16_T)totalBytesPending;
            
        }
        
    }  /* while (i < totalNumBytes) */


EXIT_POINT:

    PRINT_DEBUG_MSG_LVL4("OUT");
    PRINT_DEBUG_MSG_NL4;

    return packetAvailable;
    
}  /* fullPacketAvailable */


/* [EOF] ext_serial_pkt.c */
