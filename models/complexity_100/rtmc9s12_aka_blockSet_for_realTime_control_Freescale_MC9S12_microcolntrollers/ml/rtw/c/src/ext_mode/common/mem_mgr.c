/*
 * Copyright 1994-2008 The MathWorks, Inc.
 *
 * File: mem_mgr.c     $Revision.2 $
 *
 * Abstract:
 */

/* 
 * Adapted for rtmc9s12-Target, fw-09-7
 */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

/* Model dependent constants -- generated by 'gen_mc_defines_h.m' */
#include "mc_defines.h"

#include "rtwtypes.h"

#include "updown_util.h"
#include "ext_types.h"
#include "ext_share.h"

#include "mem_mgr.h"

#include "mc_main.h"             /* reInitMemory */
#include "mc_signal.h"           /* abort_LED */
#include "mc_debugMsgs.h"        /* macros PRINT_DEBUG_MSG_LVL3 to PRINT_DEBUG_MSG_LVL5,  fw-06-07 */


PRIVATE char_T     MemoryBuffer[EXTMODE_STATIC_SIZE];
PRIVATE MemBufHdr *FreeQueue  = NULL;
PRIVATE MemBufHdr  InUseQueue = { NULL, NULL, NULL, 0 };

#if DEBUG_MSG_LVL > 0
static uint32_T   numBytesAllocated  = 0;
static uint32_T   numBytesFree       = EXTMODE_STATIC_SIZE;
#endif

PRIVATE void insertMemBufRight(MemBufHdr *buf, MemBufHdr *queue) {

    assert(queue != NULL);
    assert(buf != NULL);

    buf->memBufPrev = queue;
    buf->memBufNext = queue->memBufNext;

    if (buf->memBufNext != NULL) {

    buf->memBufNext->memBufPrev = buf;

    }

    queue->memBufNext = buf;

}


PRIVATE void removeMemBuf(MemBufHdr *buf) {

MemBufHdr *rightMemBuf;
MemBufHdr *leftMemBuf;

    assert(buf != NULL);

    rightMemBuf = buf->memBufNext;
    leftMemBuf  = buf->memBufPrev;

    if (rightMemBuf != NULL) {
    
        rightMemBuf->memBufPrev = leftMemBuf;
        
    }
    
    if (leftMemBuf != NULL) {
    
        leftMemBuf->memBufNext = rightMemBuf;
        
    }

    buf->memBufNext = NULL;
    buf->memBufPrev = NULL;
    
}


PRIVATE boolean_T moveRight(MemBufHdr *buf) {

MemBufHdr *buf2;

    assert(buf != NULL);

    if (buf->memBufNext == NULL) {
    
        return false;
        
    } else {
    
        buf2 = buf->memBufNext;
        removeMemBuf(buf);
        insertMemBufRight(buf,buf2);
        
    }
    
    return true;
    
}

PRIVATE boolean_T sortRight(MemBufHdr *buf) {

    assert(buf != NULL);

    if ((buf->memBufNext != NULL) && (buf > buf->memBufNext)) {
    
        return moveRight(buf);
        
    }
    
    return false;
    
}


PRIVATE boolean_T sortLeft(MemBufHdr *buf) {

    assert(buf != NULL);

    if ((buf->memBufPrev != NULL) && (buf < buf->memBufPrev)) {
    
        return moveRight(buf->memBufPrev);
        
    }
    
    return false;
    
}


PRIVATE boolean_T mergeWithMemBufOnRight(MemBufHdr *buf) {

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("mergeWithMemBufOnRight")

    assert(buf != NULL);

    /*
     * If this memory buffer is adjacent to a free memory buffer to its right,
     * merge the two memory buffers into one contiguous free memory buffer.
     */
    if (buf->memBufNext != NULL) {
    
        MemBufHdr *leftMemBuf   = buf;
        MemBufHdr *rightMemBuf  = buf->memBufNext;
    
        /* Assumes data portion of mem buf is contiguous with mem buf header. */
        char_T *pointer1 = ((char_T *)leftMemBuf + sizeof(MemBufHdr) + leftMemBuf->size);
        char_T *pointer2 = (char_T *)leftMemBuf->memBufNext;

        if (pointer1 == pointer2) {

            removeMemBuf(rightMemBuf);
            
            leftMemBuf->size += rightMemBuf->size + sizeof(MemBufHdr);

            PRINT_DEBUG_MSG_LVL2("Largest free buffer size: ");
            PRINT_DEBUG_MSG_LVL2_UDec((uint16_T)leftMemBuf->size);
            PRINT_DEBUG_MSG_LVL2_Raw(" bytes");
            PRINT_DEBUG_MSG_NL2;

            return true;

      }
    }
    return false;
}

PRIVATE boolean_T mergeMemBuf(MemBufHdr *buf) {

    boolean_T statusRight = false;
    boolean_T statusLeft  = false;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("mergeMemBuf")

    assert(buf != NULL);

    PRINT_DEBUG_MSG_LVL2("IN");
    PRINT_DEBUG_MSG_NL2;
   
    statusRight = mergeWithMemBufOnRight(buf);

    if (buf->memBufPrev != NULL) {
    
        statusLeft = mergeWithMemBufOnRight(buf->memBufPrev);
        
    }

    PRINT_DEBUG_MSG_LVL2("OUT");
    PRINT_DEBUG_MSG_NL2;
   
    return (statusRight | statusLeft);
    
}


PRIVATE MemBufHdr * inUseQueueFindMemBufHdr(void *mem) {

MemBufHdr *LocalBuf;

    assert(mem != NULL);

    LocalBuf = &InUseQueue;

   if (LocalBuf->MemBuf == mem) {

      return LocalBuf;

   }
   
    while (LocalBuf->memBufNext != NULL) {
    
        LocalBuf = LocalBuf->memBufNext;
        
        if (LocalBuf->MemBuf == mem) {

            return LocalBuf;

        }

   }
   
    return NULL;
    
}


PRIVATE void inUseQueueInsert(MemBufHdr *buf) {

    MemBufHdr *LocalBuf;

    assert(buf != NULL);

    LocalBuf = &InUseQueue;

    while (LocalBuf->memBufNext != NULL) {

        LocalBuf = LocalBuf->memBufNext;
        continue;

    }

    insertMemBufRight(buf, LocalBuf);

}


PRIVATE void sortQueue(MemBufHdr *buf) {

int_T count = 1;

    assert(buf != NULL);

    /* Bi-directional bubble sort...
     *
     * Whatever packet given, move it left until the packet to the
     * left belongs there, or there is no packet to the left.
     *
     * If there is a packet to the left, move it to the left as
     * above. 
     *
     * If there is no packet to the left, reverse direction moving
     * packets to the right.
     *
     * Repeat this until no packets are moved.
     */

    /* While something moves... */
    while (count > 0) {

        count = 0;

        /* Bubble left. */
        while (1) {
        
            /* Move the current packet as far left as it will go. */
            if (sortLeft(buf)) {
            
                count++;
                continue;

            } else {

                /* Try to merge the packet with its neighbor to the right. */
                mergeMemBuf(buf);

                /* Move the MemBufHdr to the left, if possible, and
                 * continue bubbling left.
                 */ 
                if (buf->memBufPrev != NULL) {

                    buf = buf->memBufPrev;
                    continue;

                } else {
                
                    break;
                
                }
            
            }
        
        }  /* while(1) */


        /* All done bubbling to the left. Now bubble to the right. */


        /* Bubble right. */
        while (1) {

            /* Move the current packet as far right as it will go. */
            if (sortRight(buf)) {

                count++;
                continue;

            } else {

                /* Try to merge the packet with its neighbor to the right. */
                mergeMemBuf(buf);

                /* Move the MemBufHdr to the right, if possible, and
                 * continue bubbling right.
                 */ 
                if (buf->memBufNext != NULL) {
                    
                    buf = buf->memBufNext;
                    continue;
                    
                } else {
                
                    break;
                
                }
            
            }
        
        }  /* while(1) */
    
    }  /* while (count > 0) */
    
}


PRIVATE void initFreeQueue(void) {

MemBufHdr   *initialFreeMemBuf = NULL;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("initFreeQueue")

    #if DEBUG_MSG_LVL > 0
    /* There is always at least one header allocated from the buffer. */
    numBytesAllocated = sizeof(MemBufHdr);
    numBytesFree = EXTMODE_STATIC_SIZE - numBytesAllocated;

    PRINT_DEBUG_MSG_LVL2("Bytes allocated: ");
    PRINT_DEBUG_MSG_LVL2_UDec((uint16_T)(numBytesAllocated));
    PRINT_DEBUG_MSG_LVL2_Raw(", bytes free: ");
    PRINT_DEBUG_MSG_LVL2_UDec((uint16_T)numBytesFree);
    PRINT_DEBUG_MSG_NL2;
    #endif

    /* initialize memory queues (can't no longer rely on the static initialization above... fw-07-07) */
    InUseQueue.memBufNext=NULL;
    InUseQueue.memBufPrev=NULL;
    InUseQueue.MemBuf=NULL;
    InUseQueue.size=0;

    /* The FreeQueue is a pointer to a "free" buffer. */
    FreeQueue = (MemBufHdr *)MemoryBuffer;

    /*
     * The first free packet describes blocks of free space in the free queue
     * buffer (initially the whole buffer) and, as space becomes fragmented, is
     * linked to other "free" buffers.
     */
    initialFreeMemBuf = FreeQueue;

    /*
     * The location and size of the initial free buffer describes the whole
     * memory buffer.
     */
    initialFreeMemBuf->MemBuf = (char_T *)initialFreeMemBuf + sizeof(MemBufHdr);
    initialFreeMemBuf->size   = sizeof(MemoryBuffer) - sizeof(MemBufHdr);

    /*
     * When there is only one, contiguous memory buffer, the initial free
     * buffer is linked to no other free buffers. When there are more than
     * one, or discontiguous free buffers, these links tie together all free
     * buffers.
     */
    initialFreeMemBuf->memBufPrev = NULL;
    initialFreeMemBuf->memBufNext = NULL;

    /* indicate that the re-initialization of static memory manager is now complete */
    reInitMemory = 0;

}


PRIVATE MemBufHdr * findFirstFreeMemBuf(const int_T bufSize) {

    /* Get the first free packet. */
    MemBufHdr *buf = FreeQueue;

    /*
     * Loop until we find a free packet big enough for our request or we
     * run out of free packets.
     */
    while (buf != NULL) {
    
        /* Take the first free packet that fits. */
        if (buf->size >= bufSize) {
        
            /* Got it. Break out to continue. */
            break;
            
        }
        
        /* Get the next free packet. */
        buf = buf->memBufNext;
        
    }

    return buf;
    
}


PUBLIC void ExtModeFree(void *mem) {

    MemBufHdr *buf = NULL;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ExtModeFree")

    if (mem == NULL) {

        return;

    }
   
    /* Find the header associated with the memory pointer. */
    buf = inUseQueueFindMemBufHdr(mem);
    assert(buf != NULL);

    #if DEBUG_MSG_LVL > 0
    numBytesAllocated -= (buf->size + sizeof(MemBufHdr));
    numBytesFree = EXTMODE_STATIC_SIZE - numBytesAllocated;

    PRINT_DEBUG_MSG_LVL2("Bytes allocated: ");
    PRINT_DEBUG_MSG_LVL2_UDec((uint16_T)numBytesAllocated);
    PRINT_DEBUG_MSG_LVL2_Raw(", bytes free: ");
    PRINT_DEBUG_MSG_LVL2_UDec((uint16_T)numBytesFree);
    PRINT_DEBUG_MSG_NL2;
    #endif

    /* Remove the buffer from the linked list. */
    removeMemBuf(buf);

    /* Put the buffer back in the free queue. */
    insertMemBufRight(buf, FreeQueue);
    mergeMemBuf(buf);
    
}


PUBLIC void * ExtModeCalloc(uint32_T number, uint32_T size) {

uint32_T numBytes = number * size;
void     *mem     = ExtModeMalloc(numBytes);

    if (mem == NULL) {

        goto EXIT_POINT;

    }
    memset(mem, 0, (int_T)numBytes);


EXIT_POINT:

    return mem;
    
}


PUBLIC void * ExtModeMalloc(uint32_T size) {

boolean_T   doneTrying = false;

MemBufHdr  *LocalMemBuf;   /* Requested buffer (NULL if none available). */
MemBufHdr  *FreeMemBuf;    /* First free buffer big enough for request. */

/*
 * Must allocate enough space for the requested number of bytes plus the
 * size of the memory buffer header.
 */
int_T      sizeToAlloc = (int_T)(size + sizeof(MemBufHdr));
   
    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ExtModeMalloc")

    PRINT_DEBUG_MSG_LVL2("Current request: ");
    PRINT_DEBUG_MSG_LVL2_UDec((uint16_T)sizeToAlloc);
    PRINT_DEBUG_MSG_LVL2_Raw(" bytes");
    PRINT_DEBUG_MSG_NL2;

    while (!doneTrying) {

        doneTrying = true;

        LocalMemBuf = NULL;
        FreeMemBuf  = NULL;

        /* Initialize the free queue. */
        //if (FreeQueue == NULL) initFreeQueue();
        
        /* replaced by global control variable 'reInitMemory' (mc_main.c)  --  fw-07-07*/
        if (reInitMemory == 1) {

            initFreeQueue();

        }

        /* Find first free packet big enough for our request. */
        FreeMemBuf=findFirstFreeMemBuf(sizeToAlloc);

        if (FreeMemBuf == NULL) {

            PRINT_DEBUG_MSG_LVL1("Couldn't find free packet big enough for current request. Running garbage collection...");
            PRINT_DEBUG_MSG_NL1;
            /* 
             * We couldn't find a free buffer.  Run garbage collection to merge
             * free buffers together and try again.
             */
            sortQueue(FreeQueue);

            FreeMemBuf=findFirstFreeMemBuf(sizeToAlloc);

          }

        /* No free buffers are available which satisfy the request. */
        if (FreeMemBuf == NULL) {

            goto EXIT_POINT;

        }
        
        /*
         * Found a free buffer with enough space.  Carve out the exact buffer size
         * needed from the end of the free buffer.
         */
        LocalMemBuf = (MemBufHdr *)(FreeMemBuf->MemBuf +
                                    FreeMemBuf->size -
                                    sizeToAlloc);

        /*
         * The pointer to the free memory must be longword aligned.  If it
         * is not, adjust the size to allocate and try again.
         */
        {
            int_T alignBytes = (int_T)LocalMemBuf % 4;
            
            if (alignBytes) {

                PRINT_DEBUG_MSG_LVL2("Unaligned allocation address: ");
                PRINT_DEBUG_MSG_LVL2_UHex((uint16_T)(FreeMemBuf->MemBuf+FreeMemBuf->size-sizeToAlloc));
                PRINT_DEBUG_MSG_NL2;
                PRINT_DEBUG_MSG_LVL2("Need ");
                PRINT_DEBUG_MSG_LVL2_UDec((uint16_T)alignBytes);
                PRINT_DEBUG_MSG_LVL2_Raw(" alignment byte(s)");
                PRINT_DEBUG_MSG_NL2;

                /* wrong... fw-07-07 */
                //sizeToAlloc += (4-alignBytes);
                
                /* corrected... fw-07-07 */
                size += alignBytes;
                sizeToAlloc +=alignBytes;

                PRINT_DEBUG_MSG_LVL2("Adjusted size: ");
                PRINT_DEBUG_MSG_LVL2_UDec((uint16_T)sizeToAlloc);
                PRINT_DEBUG_MSG_NL2;

                doneTrying = false;

                PRINT_DEBUG_MSG_LVL2("Aligned allocation address: ");
                PRINT_DEBUG_MSG_LVL2_UHex((uint16_T)(FreeMemBuf->MemBuf+FreeMemBuf->size-sizeToAlloc));
                PRINT_DEBUG_MSG_NL2;
                
            }
            
        }
        
    }

    /* Set up the new packet's info. */
    LocalMemBuf->memBufPrev = NULL;
    LocalMemBuf->memBufNext = NULL;
    LocalMemBuf->MemBuf     = (char_T *)LocalMemBuf + sizeof(MemBufHdr);
    LocalMemBuf->size       = (int_T)size;

    /* Insert the newly created buffer into the InUseQueue. */
    inUseQueueInsert(LocalMemBuf);

    /* Update the free packet's size to reflect giving up a piece. */
    FreeMemBuf->size -= sizeToAlloc;


EXIT_POINT:

    if (LocalMemBuf) {

        #if DEBUG_MSG_LVL > 0
        numBytesAllocated += sizeToAlloc;
        numBytesFree       = EXTMODE_STATIC_SIZE - numBytesAllocated;

        PRINT_DEBUG_MSG_LVL2("Bytes allocated: ");
        PRINT_DEBUG_MSG_LVL2_UDec((uint16_T)numBytesAllocated);
        PRINT_DEBUG_MSG_LVL2_Raw(", bytes free: ");
        PRINT_DEBUG_MSG_LVL2_UDec((uint16_T)numBytesFree);
        PRINT_DEBUG_MSG_NL2;
        #endif

        return LocalMemBuf->MemBuf;
        
    }

    #if DEBUG_MSG_LVL > 0
    PRINT_DEBUG_MSG_LVL2("Bytes allocated: ");
    PRINT_DEBUG_MSG_LVL2_UDec((uint16_T)(numBytesAllocated+sizeToAlloc));
    PRINT_DEBUG_MSG_LVL2_Raw(", bytes free: ");
    PRINT_DEBUG_MSG_LVL2_UDec((uint16_T)numBytesFree);
    PRINT_DEBUG_MSG_NL2;
    PRINT_DEBUG_MSG_LVL1("Must increase size of static allocation!");
    PRINT_DEBUG_MSG_NL1;
    #endif
    
    return NULL;
    
}
