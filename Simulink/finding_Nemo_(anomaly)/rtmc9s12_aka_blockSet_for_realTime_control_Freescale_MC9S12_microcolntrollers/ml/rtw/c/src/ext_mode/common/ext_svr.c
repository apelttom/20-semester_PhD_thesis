/*
 * Copyright 1994-2008 The MathWorks, Inc.
 *
 * File: ext_svr.c     $Revision: 1.1.6.14 $
 *
 * Abstract:
 *  External mode server interface (TCPIP example).  Provides functions
 *  that get called by main routine (modelname.c):
 *    o ExtParseArgsAndInitUD:  parse args and create UserData
 *    o ExtWaitForStartPkt:     return true if waiting for host to start
 *    o rt_ExtModeInit:         external mode initialization
 *    o rt_ExtModeSleep:        pause the process
 *    o rt_PktServerWork:       server for setting/getting packets from host
 *    o rt_PktServer:           server dispatcher - for multi-tasking targets
 *    o rt_UploadServerWork:    server for setting data upload packets on host
 *    o rt_UploadServer:        server dispatcher - for multi-tasking targets
 *    o rt_ExtModeShutdown:     external mode termination
 *
 *  Paremter downloading and data uploading supported for single and
 *  multi-tasking targets.
 *
 *
 * Adapted for rtmc9s12-Target, fw-08-09
 */

/*****************
 * Include files *
 *****************/

/* Model dependent constants -- generated by 'gen_mc_defines_h.m' */
#include "mc_defines.h"

#include "mc_signal.h"        /* abort_LED */
#include "mc_debugMsgs.h"     /* macros PRINT_DEBUG_MSG_LVL3 to PRINT_DEBUG_MSG_LVL5,  fw-06-07 */

#if LCDUSE4ERRORS == 1
#include "mc_lcd.h"           /* writeLine() */
#endif


/*ANSI C headers*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if defined(VXWORKS)
/*VxWorks headers*/
# include <selectLib.h>
# include <sockLib.h>
# include <inetLib.h>
# include <ioLib.h>
# include <taskLib.h>
#endif

/*Real Time Workshop headers*/
#include "rtwtypes.h"
#include "rtw_extmode.h"

#include "ext_types.h"
#include "ext_share.h"
#include "ext_test.h"
#include "ext_svr_transport.h"
#include "updown.h"
#include "updown_util.h"      /* assert */
#include "dt_info.h"


/*Uncomment to test 4 byte reals*/
/*#define real_T float*/


#ifndef __LCC__
#define UNUSED_PARAM(p) (void)((p))
#else
#define UNUSED_PARAM(p) /* nothing */
#endif



/*
 * Debug message support
 */
#if DEBUG_MSG_LVL > 0

/* TXactiveControl is defined in ext_share.h (used on host and target)  --  fw-07-07 */
#ifdef TXactiveControl
#define numDebugMsgs    36
#else
#define numDebugMsgs    35
#endif

/* clear text action messages */
static const char_T *debugActionStrings[numDebugMsgs] = {

    /* connection actions */
    "Packet type is EXT_CONNECT",
    "Packet type is EXT_DISCONNECT_REQUEST",
    "Packet type is EXT_DISCONNECT_REQUEST_NO_FINAL_UPLOAD",
    "Packet type is EXT_DISCONNECT_CONFIRMED", 

    /* parameter upload/download actions */ 
    "Packet type is EXT_SETPARAM",
    "Packet type is EXT_GETPARAMS",

    /* data upload actions */
    "Packet type is EXT_SELECT_SIGNALS",
    "Packet type is EXT_SELECT_TRIGGER",
    "Packet type is EXT_ARM_TRIGGER",
    "Packet type is EXT_CANCEL_LOGGING",

    /* model control actions */
    "Packet type is EXT_MODEL_START",
    "Packet type is EXT_MODEL_STOP",
    "Packet type is EXT_MODEL_PAUSE",
    "Packet type is EXT_MODEL_STEP",
    "Packet type is EXT_MODEL_CONTINUE",

    /* data request actions */
    "Packet type is EXT_GET_TIME",

    /*================================
     * Packets/actions from target.
     *==============================*/

    /* responses */
    "Packet type is EXT_CONNECT_RESPONSE",   /* must not be 0! */
    "Packet type is EXT_DISCONNECT_REQUEST_RESPONSE",
    "Packet type is EXT_SETPARAM_RESPONSE",
    "Packet type is EXT_GETPARAMS_RESPONSE",
    "Packet type is EXT_MODEL_SHUTDOWN",
    "Packet type is EXT_GET_TIME_RESPONSE",
    "Packet type is EXT_MODEL_START_RESPONSE",
    "Packet type is EXT_MODEL_PAUSE_RESPONSE",
    "Packet type is EXT_MODEL_STEP_RESPONSE",
    "Packet type is EXT_MODEL_CONTINUE_RESPONSE",
    "Packet type is EXT_UPLOAD_LOGGING_DATA",
    "Packet type is EXT_SELECT_SIGNALS_RESPONSE",
    "Packet type is EXT_SELECT_TRIGGER_RESPONSE",
    "Packet type is EXT_ARM_TRIGGER_RESPONSE",
    "Packet type is EXT_CANCEL_LOGGING_RESPONSE",

    /*
     * This packet is sent from the target to signal the end of a data
     * collection event (e.g., each time that the duration is reached).
     * This packet only applies to normal mode (see
     * EXT_TERMINATE_LOG_SESSION)
     */
    "Packet type is EXT_TERMINATE_LOG_EVENT",     

    /*
     * This packet is sent from the target at the end of each data logging
     * session.  This occurs either at the end of a oneshot or at the end
     * of normal mode (i.e., the last in a series of oneshots).
     */
    "Packet type is EXT_TERMINATE_LOG_SESSION",

    #ifdef TXactiveControl
    /* TXactive control (rtmc9s12-target) --  fw-07-07 */
    "Packet type is EXT_DATA_UPLD_NOACK_REQUEST",
    #endif

    /* used to break assumed deadlock situations --  fw-07-07 */
    "Packet type is EXT_BREAK_DEADLOCK",

    "Packet type is EXTENDED = 255"          /* reserved for extending beyond 254 ID's */

};

/* clear text status messages */
static const char_T  *debugStatusStrings[5]= {

    "TARGET_STATUS_NOT_CONNECTED",
    "TARGET_STATUS_WAITING_TO_START",
    "TARGET_STATUS_STARTING",
    "TARGET_STATUS_RUNNING",
    "TARGET_STATUS_PAUSED"

};

#endif  /* DEBUG_MSG_LVL */



/**********************
 * External Variables *
 **********************/
extern int_T           volatile startModel;
extern TargetSimStatus volatile modelStatus;
#ifdef VXWORKS
extern SEM_ID uploadSem;
#endif



/********************
 * Global Variables *
 ********************/

/*
 * Flags.
 */
PRIVATE boolean_T   connected       = FALSE;
PRIVATE boolean_T   commInitialized = FALSE;

#ifdef TXactiveControl
PRIVATE boolean_T   TXactive        = FALSE;         /* set in rt_PktServerWork upon receipt of an EXT_DATA_UPLD_REQUEST  --  fw-07-07 */
#endif

/*
 * Pointer to opaque user data (defined by ext_svr_transport.c).
 */
PRIVATE ExtUserData *extUD          = NULL;

/*
 * Buffer used to receive packets.
 */
PRIVATE int_T       pktBufSize = 0;
PRIVATE char_T      *pktBuf    = NULL;

  
  
/*******************
 * Local Functions *
 *******************/

/* Function: GrowRecvBufIfNeeded ===============================================
 * Abstract:
 *  Allocate or increase the size of buffer for receiving packets from target.
 */
PRIVATE boolean_T GrowRecvBufIfNeeded(const int_T pktSize) {

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("GrowRecvBufIfNeeded")

    PRINT_DEBUG_MSG_LVL3("IN");
    PRINT_DEBUG_MSG_NL3;

    if (pktSize > pktBufSize) {
    
        if (pktBuf != NULL) {

            //PRINT_DEBUG_MSG_LVL1("Freeing memory of previously allocated packet reception buffer");
            //PRINT_DEBUG_MSG_NL1;
            free(pktBuf);
            pktBufSize = 0;

        }

        //PRINT_DEBUG_MSG_LVL1("Allocating memory for packet to be received next (ext_svr.c, ");
        //PRINT_DEBUG_MSG_LVL1_UDec((uint16_T)pktSize);
        //PRINT_DEBUG_MSG_LVL1_Raw(" bytes)");
        //PRINT_DEBUG_MSG_NL1;
        pktBuf = (char_T *)malloc(pktSize);
        
        if (pktBuf == NULL) {

            //abort_LED(45);
            return EXT_ERROR;

        }
        
        pktBufSize = pktSize;
        
    }

    PRINT_DEBUG_MSG_LVL3("OUT");
    PRINT_DEBUG_MSG_NL1;

   return EXT_NO_ERROR;
} /* end GrowRecvBufIfNeeded */


/* Function: GetPktHdr =========================================================
 * Abstract:
 *  Attempts to retrieve a packet header from the host.  If a header is in 
 *  fact retrieved, the reference arg, 'hdrAvail' will be returned as true.
 *
 *  EXT_NO_ERROR is returned on success, EXT_ERROR is returned on failure.
 *
 * NOTES:
 *  o It is not necessarily an error for 'hdrAvail' to be returned as false.
 *    It typically means that we were polling for packets and none were
 *    available.
 */
PRIVATE boolean_T GetPktHdr(PktHeader *pktHdr, boolean_T *hdrAvail) {

int_T      nGot      = 0; /* assume */
int_T      nGotTotal = 0;
int_T      pktSize   = sizeof(PktHeader);
boolean_T  error     = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("GetPktHdr")


    PRINT_DEBUG_MSG_LVL3("IN");
    PRINT_DEBUG_MSG_NL3;

    /* Get the header. */
    while(nGotTotal < pktSize) {
    
        error = ExtGetHostPkt(extUD,
                              pktSize - nGotTotal,
                              &nGot,
                              (char_T *)((char_T *)pktHdr + nGotTotal) );
                              
        if (error != EXT_NO_ERROR) {

            /* should never happen, errors are caught in ExtGetHostPkt  --  fw-07-07 */
            //abort_LED(46);
            goto EXIT_POINT;

        }
        
        nGotTotal += nGot;

        if (nGotTotal == 0) break;
        
    }
    
    /* make sure we received the expected amount of bytes  --  ineffective on the target */
    assert((nGot == 0) || (nGotTotal == pktSize));


EXIT_POINT:

    *hdrAvail = (boolean_T)(nGot>0);

    PRINT_DEBUG_MSG_LVL3("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL3_UDec(error);
    PRINT_DEBUG_MSG_NL3;

    return error;

}  /* end GetPktHdr */


/* Function: ClearPkt ==========================================================
 * Abstract:
 *  Remove the data from the communication line one byte at a time.  This
 *  function is called when there was not enough memory to receive an entire
 *  packet.  Since the data was never received, it must be discarded so that
 *  other packets can be sent.
 */
PRIVATE void ClearPkt(const int pktSize) {

int_T          nGot;
boolean_T      error     = EXT_NO_ERROR;
int_T          nGotTotal = 0;
static char_T  buffer;

    /* Get and discard the data one char at a time. */
    while(nGotTotal < pktSize) {
    
        error = ExtGetHostPkt(extUD, 1, &nGot, (char_T *)&buffer);
        
        if (error) {
        
            //abort_LED(47);
            //fprintf(stderr,"ExtGetHostPkt() failed.\n");
            goto EXIT_POINT;
            
        }

        nGotTotal += nGot;
        
    }


EXIT_POINT:

    return;

}  /* end ClearPkt */


/* Function: GetPkt ============================================================
 * Abstract:
 *  Receive nBytes from the host.  Return a buffer containing the bytes or
 *  NULL if an error occurs.  Note that the pointer returned is that of the
 *  global pktBuf.  If the buf needs to be grown to accommodate the package,
 *  it is realloc'd.  This function will try to get the requested number
 *  of bytes indefinately - it is assumed that the data is either already there,
 *  or will show up in a "reasonable" amount of time.
 */
PRIVATE const char * GetPkt(const int pktSize) {

int_T     nGot;
boolean_T error     = EXT_NO_ERROR;
int_T     nGotTotal = 0;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("GetPkt")

    PRINT_DEBUG_MSG_LVL2("IN");
    PRINT_DEBUG_MSG_NL2;

    error = GrowRecvBufIfNeeded(pktSize);
    if (error != EXT_NO_ERROR) {

        //abort_LED(48);
 
        //fprintf(stderr,"Previous pkt from host thrown away due to lack of memory.\n");
        ClearPkt(pktSize);
        goto EXIT_POINT;
        
    }
    
    /* Get the data. */
    while(nGotTotal < pktSize) {
    
        error = ExtGetHostPkt(extUD,
                              pktSize - nGotTotal,
                              &nGot,
                              (char_T *)(pktBuf + nGotTotal) );
                              
        if (error) {

            //abort_LED(49);

            //fprintf(stderr,"ExtGetHostPkt() failed.\n");
            goto EXIT_POINT;
            
        }

        nGotTotal += nGot;
        
    }


EXIT_POINT:

    PRINT_DEBUG_MSG_LVL2("OUT");
    PRINT_DEBUG_MSG_NL2;

    return ((error == EXT_NO_ERROR) ? pktBuf : NULL);
    
}  /* end GetPkt */


/* Forward declaration */
void UploadServerWork(int32_T, int_T numSampTimes);

/* Function: DisconnectFromHost ================================================
 * Abstract:
 *  Disconnect from the host.
 */
PRIVATE void DisconnectFromHost(int_T numSampTimes) {

int_T    i;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("DisconnectFromHost")

    for (i = 0; i < NUM_UPINFOS; i++) {
        
            UploadPrepareForFinalFlush(i);
            UploadServerWork(i, numSampTimes);
            UploadLogInfoTerm(i, numSampTimes);
            
    }
    
    connected       = FALSE;
    commInitialized = FALSE;

    //PRINT_DEBUG_MSG_LVL1("connected = FALSE");
    //PRINT_DEBUG_MSG_NL1;
    
    //PRINT_DEBUG_MSG_LVL1("commInitialized = FALSE");
    //PRINT_DEBUG_MSG_NL1;


    ExtCloseConnection(extUD);
    
}  /* end DisconnectFromHost */


/* Function: ForceDisconnectFromHost ===========================================
 * Abstract:
 *  Force a disconnect from the host.  This is not a graceful shutdown and
 *  should only be used when the integrity of the external mode connection
 *  is in question.  To shutdown the connection gracefully, use
 *  DisconnectFromHost().
 */
PRIVATE void ForceDisconnectFromHost(int_T numSampTimes) {

int_T    i;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ForceDisconnectFromHost")

    connected       = FALSE;
    commInitialized = FALSE;

    //PRINT_DEBUG_MSG_LVL1("connected = FALSE");
    //PRINT_DEBUG_MSG_NL1;
    //PRINT_DEBUG_MSG_LVL1("commInitialized = FALSE");
    //PRINT_DEBUG_MSG_NL1;

    for (i = 0; i < NUM_UPINFOS; i++) {
    
        UploadEndLoggingSession(i, numSampTimes);
        
    }

    ExtForceDisconnect(extUD);
    
}  /* end ForceDisconnectFromHost */


/* Function: ProcessConnectPkt =================================================
 * Abstract:
 *  Process the EXT_CONNECT packet and send response to host.
 */
PRIVATE boolean_T ProcessConnectPkt(RTWExtModeInfo *ei) {

int_T                    nSet;
PktHeader                pktHdr;
int_T                    tmpBufSize;
uint32_T                 *tmpBuf    = NULL;
boolean_T                error      = EXT_NO_ERROR;

const DataTypeTransInfo  *dtInfo    = rteiGetModelMappingInfo(ei);
uint_T                   *dtSizes   = dtGetDataTypeSizes(dtInfo);
int_T                    nDataTypes = dtGetNumDataTypes(dtInfo);


    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ProcessConnectPkt")

    assert(connected);
    assert(!comminitialized);

    PRINT_DEBUG_MSG_LVL3("IN");
    PRINT_DEBUG_MSG_NL3;

    /*
     * Send the 1st of two EXT_CONNECT_RESPONSE packets to the host. 
     * The packet consists purely of the pktHeader.  In this special
     * case the pktSize actually contains the number of bits per byte
     * (not always 8 - see TI compiler for C30 and C40).
     */
    pktHdr.type = (uint32_T)EXT_CONNECT_RESPONSE;
    pktHdr.size = (uint32_T)8; /* 8 bits per byte */

    error = ExtSetHostPkt(extUD, sizeof(pktHdr), (char_T *)&pktHdr, &nSet);
    
    if (error || (nSet != sizeof(pktHdr))) {

        //abort_LED(50);
        //fprintf(stderr, "ExtSetHostPkt() failed for 1st EXT_CONNECT_RESPONSE.\n");
        goto EXIT_POINT;
        
    }

    /* Send 2nd EXT_CONNECT_RESPONSE packet containing the following 
     * fields:
     *
     * CS1 - checksum 1 (uint32_T)
     * CS2 - checksum 2 (uint32_T)
     * CS3 - checksum 3 (uint32_T)
     * CS4 - checksum 4 (uint32_T)
     *
     * intCodeOnly   - flag indicating if target is integer only (uint32_T)
     * 
     * MWChunkSize   - multiword data type chunk size on target (uint32_T)
     * 
     * targetStatus  - the status of the target (uint32_T)
     *
     * nDataTypes    - # of data types        (uint32_T)
     * dataTypeSizes - 1 per nDataTypes       (uint32_T[])
     */

    {
        int_T nPktEls  = 4 +                          /* checkSums       */
                         1 +                          /* intCodeOnly     */
                         1 +                          /* MW chunk size   */
                         1 +                          /* targetStatus    */
                         1 +                          /* nDataTypes      */
                         dtGetNumDataTypes(dtInfo);   /* data type sizes */

        tmpBufSize = nPktEls * sizeof(uint32_T);

        PRINT_DEBUG_MSG_LVL3("Allocating memory for temporary buffer for 2nd EXT_CONNECT_RESPONSE (");
        PRINT_DEBUG_MSG_LVL3_UDec((uint16_T)tmpBufSize);
        PRINT_DEBUG_MSG_LVL3_Raw(" bytes)");
        PRINT_DEBUG_MSG_NL3;
        
        tmpBuf = (uint32_T *)malloc(tmpBufSize);
        
        if (tmpBuf == NULL) {

            //abort_LED(51);
            error = EXT_ERROR;
            goto EXIT_POINT;

        }
        
    }

    /* Send packet header. */
    pktHdr.type = EXT_CONNECT_RESPONSE;
    pktHdr.size = tmpBufSize;

    error = ExtSetHostPkt(extUD, sizeof(pktHdr), (char_T *)&pktHdr, &nSet);
    
    if (error || (nSet != sizeof(pktHdr))) {

        //fprintf(stderr, "ExtSetHostPkt() failed for 2nd EXT_CONNECT_RESPONSE.\n");
        goto EXIT_POINT;

    }

    /* Checksums, target status & SL_DOUBLESize. */
    tmpBuf[0] = rteiGetChecksum0(ei);
    tmpBuf[1] = rteiGetChecksum1(ei);
    tmpBuf[2] = rteiGetChecksum2(ei);
    tmpBuf[3] = rteiGetChecksum3(ei);

    #if INTEGER_CODE == 0
    tmpBuf[4] = (uint32_T)0;
    #else
    tmpBuf[4] = (uint32_T)1;
    #endif

    tmpBuf[5] = (uint32_T)sizeof(uchunk_T);
    
    tmpBuf[6] = (uint32_T)modelStatus;

    /* nDataTypes and dataTypeSizes */
    tmpBuf[7] = (uint32_T)nDataTypes;
    
    // the following line implies that the data types are stored as uint32_T
    // (not the case on 16-bit targets such as the 9s12...   fw/06/07
    //
    // (void)memcpy(&tmpBuf[7], dtSizes, sizeof(uint32_T)*nDataTypes);
    {
        int_T  i;

        for(i = 0; i < nDataTypes; i++) {

            tmpBuf[8+i]=(uint32_T)dtSizes[i];

        }
    }
    
    /* Send the packet. */
    error = ExtSetHostPkt(extUD, tmpBufSize, (char_T *)tmpBuf, &nSet);
    
    if (error || (nSet != tmpBufSize)) {

        abort_LED(53);

        //fprintf(stderr, "ExtSetHostPkt() failed.\n");
        goto EXIT_POINT;

    }

    commInitialized = TRUE;
    //PRINT_DEBUG_MSG_LVL1("commInitialized = TRUE");
    //PRINT_DEBUG_MSG_NL1;


EXIT_POINT:

    PRINT_DEBUG_MSG_LVL3("Freeing memory of temporary buffer (2nd EXT_CONNECT_RESPONSE)");
    PRINT_DEBUG_MSG_NL3;
    free(tmpBuf);

    PRINT_DEBUG_MSG_LVL3("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL3_UDec(error);
    PRINT_DEBUG_MSG_NL3;

    return error;

}  /* end ProcessConnectPkt */


/* Function: SendPktHdrToHost ==================================================
 * Abstract:
 *  Send a packet header to the host.
 */
PRIVATE boolean_T SendPktHdrToHost (
    const ExtModeAction action,
    const int_T         size)  /* # of bytes to follow pkt header */
{

int_T      nSet;
PktHeader  pktHdr;
boolean_T  error = EXT_NO_ERROR;

    pktHdr.type = (uint32_T)action;
    pktHdr.size = size;

    error = ExtSetHostPkt(extUD, sizeof(pktHdr), (char_T *)&pktHdr, &nSet);
    
    if (error || (nSet != sizeof(pktHdr))) {

        //abort_LED(54);    /* indicates that 'nSet != sizeof(pktHdr)'  --  fw-07-07 */
        //fprintf(stderr, "ExtSetHostPkt() failed.\n");
        error = EXT_ERROR;
        goto EXIT_POINT;

    }


EXIT_POINT:

    return error;

}  /* end SendPktHdrToHost */


/* Function: SendPktDataToHost =================================================
 * Abstract:
 *  Send packet data to host. You are responsible for sending a header
 *  prior to sending the header.
 */
PRIVATE boolean_T SendPktDataToHost(const char_T *data, const int_T size) {

int_T      nSet;
boolean_T  error = EXT_NO_ERROR;

    error = ExtSetHostPkt(extUD, size, data, &nSet);
    
    if (error || (nSet != size)) {
    
        //fprintf(stderr,"ExtSetHostPkt() failed.\n");
        error = EXT_ERROR;
        goto EXIT_POINT;

    }


EXIT_POINT:

    return error;

}  /* end SendPktDataToHost */


/* Function: SendPktToHost =====================================================
 * Abstract:
 *  Send a packet to the host.  Packets can be of two forms:
 *      o packet header only
 *          the type is used as a flag to notify Simulink of an event
 *          that has taken place on the target (event == action == type)
 *      o pkt header, followed by data
 */
PUBLIC boolean_T SendPktToHost(
    const ExtModeAction action,
    const int_T         size,  /* # of bytes to follow pkt header */
    const char_T        *data)
{

boolean_T   error = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("SendPktToHost")

    PRINT_DEBUG_MSG_LVL2("Sending action ");
    PRINT_DEBUG_MSG_LVL2_Raw(debugActionStrings[(uint_T)action]);
    PRINT_DEBUG_MSG_LVL2_Raw(" (");
    PRINT_DEBUG_MSG_LVL2_UDec((uint16_T)action);
    PRINT_DEBUG_MSG_LVL2_Raw(") with size ");
    PRINT_DEBUG_MSG_LVL2_UDec((uint16_T)size);
    PRINT_DEBUG_MSG_NL2;

    error = SendPktHdrToHost(action, size);
    
    if (error != EXT_NO_ERROR) {

        //abort_LED(56);
        goto EXIT_POINT;

    }
   
    PRINT_DEBUG_MSG_LVL2("... action and size sent.");
    PRINT_DEBUG_MSG_NL2;

    if (data != NULL) {

        PRINT_DEBUG_MSG_LVL2("Sending data...");
        PRINT_DEBUG_MSG_NL2;

        error = SendPktDataToHost(data, size);

        if (error != EXT_NO_ERROR) {

            //abort_LED(57);
            goto EXIT_POINT;

        }
        
        PRINT_DEBUG_MSG_LVL2("... data sent.");
        PRINT_DEBUG_MSG_NL2;
        
    } else {
    
        assert(size == 0);
        
    }


EXIT_POINT:

    return error;

}  /* end SendPktToHost */


/* Function:  SendResponseStatus ===============================================
 *  
 */
PRIVATE boolean_T SendResponseStatus(const ExtModeAction  response,
                                     const ResponseStatus status,
                                     int32_T upInfoIdx)
{

int32_T    msg[2];
boolean_T  error = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("SendResponseStatus")

    PRINT_DEBUG_MSG_LVL2("IN");
    PRINT_DEBUG_MSG_NL2;

    msg[0] = (int32_T)status;
    msg[1] = upInfoIdx;

    PRINT_DEBUG_MSG_LVL2("Response status: ");
    PRINT_DEBUG_MSG_LVL2_UDec((uint16_T)status);
    PRINT_DEBUG_MSG_LVL2_Raw(" (upInfoIdx = ");
    PRINT_DEBUG_MSG_LVL2_UDec((uint16_T)upInfoIdx);
    PRINT_DEBUG_MSG_LVL2_Raw(")");
    PRINT_DEBUG_MSG_NL2;
    PRINT_DEBUG_MSG_NL2;

    error = SendPktToHost(response, 2*sizeof(int32_T), (char_T *)&msg);

    PRINT_DEBUG_MSG_LVL2("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL2_UDec(error);
    PRINT_DEBUG_MSG_NL2;

    return error;

}  /* end SendResponseStatus */


/* Function: ProcessSetParamPkt ================================================
 * Receive and process the EXT_SETPARAM packet.
 */
PRIVATE boolean_T ProcessSetParamPkt(RTWExtModeInfo *ei,
                                     const int pktSize)
{
int32_T      msg;
const char_T *pkt;
boolean_T    error = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ProcessSetParamPkt")

    //PRINT_DEBUG_MSG_LVL1("IN");
    //PRINT_DEBUG_MSG_NL1;

    /*
     * Receive packet and set parameters.
     */
    pkt = GetPkt(pktSize);
    
    if (pkt == NULL) {
    
        msg = (int32_T)NOT_ENOUGH_MEMORY;
        
        SendPktToHost(EXT_SETPARAM_RESPONSE, sizeof(int32_T), (char_T *)&msg);

        //abort_LED(58);
        error = EXT_ERROR;
        goto EXIT_POINT;
        
    }

    //PRINT_DEBUG_MSG_LVL1("after GetPkt");
    //PRINT_DEBUG_MSG_NL1;

    SetParam(ei, pkt);

    msg = (int32_T)STATUS_OK;
    error = SendPktToHost(EXT_SETPARAM_RESPONSE, sizeof(int32_T), (char_T *)&msg);
    
    if (error != EXT_NO_ERROR) {
    
        goto EXIT_POINT;

    }


EXIT_POINT:

    //PRINT_DEBUG_MSG_LVL1("OUT, error status: ");
    //PRINT_DEBUG_MSG_LVL1_UDec(error);
    //PRINT_DEBUG_MSG_NL1;

    return error;
    
}  /* end ProcessSetParamPkt */


/* Function: ProcessGetParamsPkt ===============================================
 *  Respond to the hosts request for the parameters by gathering up all the
 *  params and sending them to the host.
 */
PRIVATE boolean_T ProcessGetParamsPkt(RTWExtModeInfo *ei) {

int_T                          i;
int_T                          nBytesTotal;
boolean_T                      error    = EXT_NO_ERROR;
const DataTypeTransInfo        *dtInfo  = rteiGetModelMappingInfo(ei);
const DataTypeTransitionTable  *dtTable = dtGetParamDataTypeTrans(dtInfo);

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ProcessGetParamsPkt")

    PRINT_DEBUG_MSG_LVL3("IN");
    PRINT_DEBUG_MSG_NL3;

    if (dtTable != NULL) {
    
        /*
         * We've got some params in the model.  Send their values to the
         * host.
         */
        int_T         nTrans   = dtGetNumTransitions(dtTable);
        const uint_T  *dtSizes = dtGetDataTypeSizes(dtInfo);

        /*
         * Take pass 1 through the transitions to figure out how many
         * bytes we're going to send.
         */
        nBytesTotal = 0;
        for (i = 0; i < nTrans; i++) {
        
            int_T tranIsComplex = dtTransGetComplexFlag(dtTable, i);
            int_T dt            = dtTransGetDataType(dtTable, i);
            int_T dtSize        = dtSizes[dt];
            int_T nEls          = dtTransNEls(dtTable, i);   /* complexity accounted for in trans tbl num of els */
            int_T nBytes        = dtSize * nEls;

            nBytesTotal += nBytes;
            
        }

        /*
         * Send the packet header.
         */
        error = SendPktHdrToHost(EXT_GETPARAMS_RESPONSE, nBytesTotal);
        
        if (error != EXT_NO_ERROR) {

            //abort_LED(60);
            goto EXIT_POINT;

        }
        
        /*
         * Take pass 2 through the transitions and send the parameters.
         */
        for (i = 0; i < nTrans; i++) {
        
            char_T *tranAddress  = dtTransGetAddress(dtTable, i);
            int_T  dt            = dtTransGetDataType(dtTable, i);
            int_T  dtSize        = dtSizes[dt];
            int_T  nEls          = dtTransNEls(dtTable, i); /* complexity accounted for in trans tbl num of els */
            int_T  nBytes        = dtSize * nEls;

            error = SendPktDataToHost(tranAddress, nBytes);
            
           if (error!=EXT_NO_ERROR) {

                //abort_LED(61);
                goto EXIT_POINT;

            }

        }
        
    } else {
    
        /*
         * We've got no params in the model.
         */
        error = SendPktHdrToHost(EXT_GETPARAMS_RESPONSE, 0);
        
        if (error != EXT_NO_ERROR) {

            //abort_LED(62);
            goto EXIT_POINT;

        }

   }


EXIT_POINT:

    PRINT_DEBUG_MSG_LVL3("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL3_UDec(error);
    PRINT_DEBUG_MSG_NL3;

    return error;

}  /* end ProcessGetParamsPkt */


/* Function: ProcessArmTriggerPkt ==============================================
 * Receive and process the EXT_ARM_TRIGGER packet.
 */
PRIVATE boolean_T ProcessArmTriggerPkt(const int_T pktSize, int_T numSampTimes) {

const char_T  *pkt;
int32_T       upInfoIdx;
boolean_T     error = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ProcessArmTriggerPkt")

    pkt = GetPkt(pktSize);
    
    if (pkt == NULL) {
    
        SendResponseStatus(EXT_ARM_TRIGGER_RESPONSE,
                           NOT_ENOUGH_MEMORY,
                           -1);

        //abort_LED(63);
        error = EXT_ERROR;
        goto EXIT_POINT;
        
    }

    /* Extract upInfoIdx */
    (void)memcpy(&upInfoIdx, pkt, sizeof(int32_T));

    PRINT_DEBUG_MSG_LVL3("Got EXT_ARM_TRIGGER packet for upInfoIdx ");
    PRINT_DEBUG_MSG_LVL3_UDec((uint16_T)upInfoIdx);
    PRINT_DEBUG_MSG_NL3;

    UploadArmTrigger(upInfoIdx, numSampTimes);

    error = SendResponseStatus(EXT_ARM_TRIGGER_RESPONSE, STATUS_OK, upInfoIdx);
    
    if (error!=EXT_NO_ERROR) {

        //abort_LED(64);
        goto EXIT_POINT;

   }


EXIT_POINT:

    return error;

}  /* end ProcessArmTriggerPkt */


/* Function: ProcessSelectSignalsPkt ===========================================
 * Receive and process the EXT_SELECT_SIGNALS packet.
 */
PRIVATE boolean_T ProcessSelectSignalsPkt(RTWExtModeInfo *ei,
                                          int_T          numSampTimes,
                                          const int_T    pktSize)
{
const char_T  *pkt;
int32_T       upInfoIdx;
boolean_T     error = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ProcessSelectSignalsPkt")

    PRINT_DEBUG_MSG_LVL2("IN");
    PRINT_DEBUG_MSG_NL2;

    pkt = GetPkt(pktSize);

    if (pkt == NULL) {

        SendResponseStatus(EXT_SELECT_SIGNALS_RESPONSE,
                           NOT_ENOUGH_MEMORY,
                           -1);

        //abort_LED(65);
        error = EXT_ERROR;
        goto EXIT_POINT;

    }

    /* Extract upInfoIdx */
    (void)memcpy(&upInfoIdx, pkt, sizeof(int32_T));

    PRINT_DEBUG_MSG_LVL3("Got EXT_SELECT_SIGNALS packet for upInfoIdx ");
    PRINT_DEBUG_MSG_LVL3_UDec((uint16_T)upInfoIdx);
    PRINT_DEBUG_MSG_NL3;

    error = UploadLogInfoInit(ei, numSampTimes, pkt+sizeof(int32_T), upInfoIdx);

    if (error != NO_ERR) {

        SendResponseStatus(EXT_SELECT_SIGNALS_RESPONSE, NOT_ENOUGH_MEMORY, upInfoIdx);

        //abort_LED(66);

        //printf(
        //    "\nError in UploadLogInfoInit(). Most likely a memory\n"
        //    "allocation error or an attempt to re-initialize the\n"
        //    "signal selection during the data logging process\n"
        //    "(i.e., multiple EXT_SELECT_SIGNAL packets were received\n"
        //    "before the logging session terminated or an\n"
        //    "EXT_CANCEL_LOGGING packet was received)\n");
        goto EXIT_POINT;

    }

   error = SendResponseStatus(EXT_SELECT_SIGNALS_RESPONSE, STATUS_OK, upInfoIdx);
   
   if (error != EXT_NO_ERROR) {

        //abort_LED(67);
        goto EXIT_POINT;

   }


EXIT_POINT:

    PRINT_DEBUG_MSG_LVL2("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL2_UDec(error);
    PRINT_DEBUG_MSG_NL2;

    return error;
    
}  /* end ProcessSelectSignalsPkt */


/* Function: ProcessSelectTriggerPkt ===========================================
 * Receive and process the EXT_SELECT_TRIGGER packet.
 */
PRIVATE boolean_T ProcessSelectTriggerPkt(RTWExtModeInfo *ei,
                                          const int pktSize)
{
const char_T  *pkt;
int32_T       upInfoIdx;
boolean_T     error = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ProcessSelectTriggerPkt")

    PRINT_DEBUG_MSG_LVL2("IN");
    PRINT_DEBUG_MSG_NL2;

    pkt = GetPkt(pktSize);
    
    if (pkt == NULL) {
    
        SendResponseStatus(EXT_SELECT_TRIGGER_RESPONSE, NOT_ENOUGH_MEMORY, -1);

        //abort_LED(68);
        error = EXT_ERROR;
        goto EXIT_POINT;
        
    }

    /* Extract upInfoIdx */
    (void)memcpy(&upInfoIdx, pkt, sizeof(int32_T));

    PRINT_DEBUG_MSG_LVL3("Got EXT_SELECT_TRIGGER packet for upInfoIdx ");
    PRINT_DEBUG_MSG_LVL3_UDec((uint16_T)upInfoIdx);
    PRINT_DEBUG_MSG_NL3;

    error = UploadInitTrigger(ei, pkt+sizeof(int32_T), upInfoIdx);
    
    if (error != EXT_NO_ERROR) {

        SendResponseStatus(EXT_SELECT_TRIGGER_RESPONSE, NOT_ENOUGH_MEMORY, upInfoIdx);

        //abort_LED(69);

        //printf(
        //    "\nError in UploadInitTrigger(). Most likely a memory\n"
        //   "allocation error or an attempt to re-initialize the\n"
        //    "trigger selection during the data logging process\n"
        //    "(i.e., multiple EXT_SELECT_TRIGGER packets were received\n"
        //    "before the logging session terminated or an\n"
        //    "EXT_CANCEL_LOGGING packet was received)\n");
        goto EXIT_POINT;
        
    }

   error = SendResponseStatus(EXT_SELECT_TRIGGER_RESPONSE, STATUS_OK, upInfoIdx);
   
   if (error != EXT_NO_ERROR) {

        //abort_LED(70);
        goto EXIT_POINT;

   }


EXIT_POINT:

    PRINT_DEBUG_MSG_LVL2("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL2_UDec(error);
    PRINT_DEBUG_MSG_NL2;

   return error;

}  /* end ProcessSelectTriggerPkt */


/* Function: ProcessCancelLoggingPkt ===========================================
 * Receive and process the EXT_CANCEL_LOGGING packet.
 */
PRIVATE boolean_T ProcessCancelLoggingPkt(const int_T pktSize) {

const char_T  *pkt;
int32_T       upInfoIdx;
boolean_T     error = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ProcessCancelLoggingPkt")

    PRINT_DEBUG_MSG_LVL2("IN");
    PRINT_DEBUG_MSG_NL2;

    pkt = GetPkt(pktSize);
    
    if (pkt == NULL) {
    
        SendResponseStatus(EXT_CANCEL_LOGGING_RESPONSE, NOT_ENOUGH_MEMORY, -1);

        //abort_LED(71);
        error = EXT_ERROR;
        goto EXIT_POINT;
        
    }

    /* Extract upInfoIdx */
    (void)memcpy(&upInfoIdx, pkt, sizeof(int32_T));
            
    PRINT_DEBUG_MSG_LVL3("Got EXT_CANCEL_LOGGING packet for upInfoIdx ");
    PRINT_DEBUG_MSG_LVL3_UDec((uint16_T)upInfoIdx);
    PRINT_DEBUG_MSG_NL3;

    UploadCancelLogging(upInfoIdx);

   error = SendResponseStatus(EXT_CANCEL_LOGGING_RESPONSE, STATUS_OK, upInfoIdx);
   
   if (error != EXT_NO_ERROR) {

        //abort_LED(72);
        goto EXIT_POINT;

   }


EXIT_POINT:

    PRINT_DEBUG_MSG_LVL2("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL2_UDec(error);
    PRINT_DEBUG_MSG_NL2;

    return error;
    
}  /* end ProcessCancelLoggingPkt */


/* Function: ExtInitUD =============================================
 * Abstract:
 *  The external mode UserData is created here  
 */
PRIVATE void ExtInitUD(void) {

   /*
    * Create and initialize the user data   --  fw-04-05
    */
   extUD = ExtUserDataCreate();
   if (extUD == NULL) {

        abort_LED(73);

    }

}  /* end ExtInitUD */



/*********************
 * Visible Functions *
 *********************/

/* Function: ExtSetWaitForStartPkt ============================================
 * Abstract:
 *  Define the target behaviour w/h regard to 'wait for start pkt'  -  fw-06-07
 */
PUBLIC void ExtSetWaitForStartPkt(uint_T w4start) {

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ExtSetWaitForStartPkt")

   if (w4start == TRUE) {

        /* configure for 'wait for start Pkt from host' */
        ExtSetWaitForStartPktFromHost(extUD, TRUE);   // effectively:  extUD->waitForStartPkt = TRUE;
        startModel = FALSE;

        //PRINT_DEBUG_MSG_LVL1("startModel = FALSE");
        //PRINT_DEBUG_MSG_NL1;

   } else {

        /* configure for 'don't wait for start Pkt from host' */
        ExtSetWaitForStartPktFromHost(extUD, FALSE);  // effectively:  extUD->waitForStartPkt = FALSE;
        startModel = TRUE;

        //PRINT_DEBUG_MSG_LVL1("startModel = TRUE");
        //PRINT_DEBUG_MSG_NL1;

    }

}  /* end ExtSetWaitForStartPkt */


#ifdef ERASE
/* Function: ExtParseArgsAndInitUD =============================================
 * Abstract:
 *  Pass remaining arguments (main program should have NULL'ed out any args
 *  that it processed) to external mode.
 *  
 *  The actual, transport-specific parsing routine (implemented in
 *  ext_svr_transport.c) MUST NULL out all entries of argv that it processes.
 *  The main program depends on this in order to determine if any unhandled
 *  command line options were specified (i.e., if the main program detects
 *  any non-null fields after the parse, it throws an error).
 *
 *  Returns an error string on failure, NULL on success.
 *
 * NOTES:
 *  The external mode UserData is created here so that the specified command-
 *  line options can be stored.
 */
PUBLIC const char_T *ExtParseArgsAndInitUD(const int_T  argc,
                                           const char_T *argv[])
{

const char_T  *error = NULL;
    
    /*
     * Create the user data.
     */
    extUD = ExtUserDataCreate();
    
    if (extUD == NULL) {
    
        error = "Could not create external mode user data.  Out of memory.\n";
        goto EXIT_POINT;
        
    }

    /*
     * Parse the transport-specific args.
     */
    error = ExtProcessArgs(extUD, argc, argv);
    
    if (error != NULL) {
    
        goto EXIT_POINT;
        
    }


EXIT_POINT:

    if (error != NULL) {
    
        ExtUserDataDestroy(extUD);
        extUD = NULL;
        
    }
    
    return error;
    
}  /* end ExtParseArgsAndInitUD */
#endif


/* Function: ExtWaitForStartPkt ================================================
 * Abstract:
 *  Return true if waiting for host to tell us when to start.
 */
PUBLIC boolean_T ExtWaitForStartPkt(void) {

    return ExtWaitForStartPktFromHost(extUD);
    
}  /* end ExtWaitForStartPkt */


/* Function: UploadServerWork =================================================
 * Abstract:
 *  Upload model signals to host for a single upInfo.
 */
void UploadServerWork(int32_T upInfoIdx, int_T numSampTimes) {

int_T         i;
ExtBufMemList upList;
boolean_T     error = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("UploadServerWork")

    PRINT_DEBUG_MSG_LVL3("IN");
    PRINT_DEBUG_MSG_NL3;


    #ifdef VXWORKS
    /*
     * Don't spin the CPU unless we've got data to upload.
     * The upload.c/UploadBufAddTimePoint function gives the sem
     * each time that data is added.
     */
    semTake(uploadSem, WAIT_FOREVER);
    #endif

    if (!connected) {
    
        goto EXIT_POINT;
    
    }
    
    UploadBufGetData(&upList, upInfoIdx, numSampTimes);
    
    #ifdef TXactiveControl
    while(upList.nActiveBufs>0 && TXactive) {
    #else
    while(upList.nActiveBufs>0) {
    #endif

        for (i = 0; i < upList.nActiveBufs; i++) {

            const BufMem *bufMem = &upList.bufs[i];

            /*
             * We call SendPktDataToHost() instead of SendPktToHost() because
             * the packet header is combined with packet payload.  We do this
             * to avoid the overhead of making two calls for each upload
             * packet - one for the head and one for the payload.
             */
            error = SendPktDataToHost(bufMem->section1, bufMem->nBytes1);
            
            if (error != EXT_NO_ERROR) {

                //abort_LED(74);
                //fprintf(stderr,"SendPktDataToHost() failed on data upload.\n");
                goto EXIT_POINT;
                
            }
            
            if (bufMem->nBytes2 > 0) {

                error = SendPktDataToHost(bufMem->section2, bufMem->nBytes2);
                
                if (error != EXT_NO_ERROR) {

                    abort_LED(75);
                    //fprintf(stderr,"SendPktDataToHost() failed on data upload.\n");
                    goto EXIT_POINT;
                    
                }
                
            }
            
            /* comfirm that the data was sent */
            UploadBufDataSent(upList.tids[i], upInfoIdx);
            
        }
        
        UploadBufGetData(&upList, upInfoIdx, numSampTimes);
          
        #ifdef TXactiveControl
        /* deactivate TXactive flag (re-activated on demand, by the host)  --  fw-07-07 */
        TXactive = FALSE;
        #endif

    }


EXIT_POINT:

    if (error != EXT_NO_ERROR) {
    
        /* currently never reached -- errors thrown: 24 and 25 (see above)  --  fw-07-07 */
        //abort_LED(76);    // just in case... (debug test)

        /* An error in this function is caused by a physical failure in the
         * external mode connection.  We assume this failure caused the host
         * to disconnect.  The target must be disconnected and returned to a
         * state where it is running and can be re-connected to by the host.
         */
        ForceDisconnectFromHost(numSampTimes);
        
    }

    PRINT_DEBUG_MSG_LVL3("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL3_UDec(error);
    PRINT_DEBUG_MSG_NL3;

}  /* end UploadServerWork */


/* Function: rt_UploadServerWork ===============================================
 * Abstract:
 *  Wrapper function that calls UploadServerWork once for each upInfo
 */
PUBLIC void rt_UploadServerWork(int_T numSampTimes) {

int_T  i;
    
    for (i = 0; i < NUM_UPINFOS; i++) {
    
        UploadServerWork(i, numSampTimes);
        
    }
    
}  /* end rt_UploadServerWork */


/* Function: rt_ExtModeInit ====================================================
 * Abstract:
 *  Called once at program startup to do any initialization related to external
 *  mode. 
 */
PUBLIC boolean_T rt_ExtModeInit(void) {

int_T      i;
boolean_T  error = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("rt_ExtModeInit")

    PRINT_DEBUG_MSG_LVL3("IN");
    PRINT_DEBUG_MSG_NL3;

    /* create and initialize extUD */
    ExtInitUD();

    error = ExtInit(extUD);
    if (error != EXT_NO_ERROR) {

        //abort_LED(77);
        goto EXIT_POINT;

   }

    for (i = 0; i < NUM_UPINFOS; i++) {
    
        UploadLogInfoReset(i);
        
    }

    rtExtModeTestingInit();


EXIT_POINT:

    PRINT_DEBUG_MSG_LVL3("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL3_UDec(error);
    PRINT_DEBUG_MSG_NL3;

    return error;

}  /* end rt_ExtModeInit */


/* Function: rt_ExtModeSleep ===================================================
 * Abstract:
 *  Called by grt_main, ert_main, and grt_malloc_main  to "pause".  It attempts
 *  to do this in a way that does not hog the processor.
 */
#ifndef VXWORKS
PUBLIC void rt_ExtModeSleep(
    long sec,  /* number of seconds to wait       */
    long usec) /* number of micro seconds to wait */
{
    ExtModeSleep(extUD,sec,usec);

} /* end rt_ExtModeSleep */
#endif


/* Function: rt_PktServerWork ==================================================
 * Abstract:
 *  If not connected, establish communication of the packet line and the
 *  data upload line.  If connected, send/receive packets and parameters
 *  on the packet line.
 */
PUBLIC void rt_PktServerWork(RTWExtModeInfo *ei,
                             int_T          numSampTimes,
                             boolean_T      *stopReq)
{

PktHeader  pktHdr;
boolean_T  hdrAvail;
boolean_T  error             = EXT_NO_ERROR;
boolean_T  disconnectOnError = FALSE;
    

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("rt_PktServerWork")

    PRINT_DEBUG_MSG_LVL3("IN");
    PRINT_DEBUG_MSG_NL3;

    /*
     * If not connected, attempt to make connection to host.
     */
    if (!connected) {

        PRINT_DEBUG_MSG_LVL3("not connected");
        PRINT_DEBUG_MSG_NL3;

        rtExtModeTestingKillIfOrphaned(FALSE);

        error = ExtOpenConnection(extUD, &connected);
        
        if (error != EXT_NO_ERROR) {

            //abort_LED(78);
            goto EXIT_POINT;

        }

       PRINT_DEBUG_MSG_LVL3("now connected");
       PRINT_DEBUG_MSG_NL3;

    }
    
    /*
     * If ExtOpenConnection is not blocking and there are no pending
     * requests to open a connection, we'll still be unconnected.
     */
    if (!connected) {
    
        goto EXIT_POINT; /* nothing do do */
        
    }

    //PRINT_DEBUG_MSG_LVL3("rt_PktServerWork: connected");
    //PRINT_DEBUG_MSG_NL3;

    /*
     * Process packets.
     */

    /* Wait for a packet. */
    error = GetPktHdr(&pktHdr, &hdrAvail);
    
    if (error != EXT_NO_ERROR) {

        PRINT_DEBUG_MSG_LVL3("Error occured getting packet header, disconnecting...");
        PRINT_DEBUG_MSG_NL3;

        //abort_LED(79);
        disconnectOnError = TRUE;
        goto EXIT_POINT;

    }

    rtExtModeTestingKillIfOrphaned(hdrAvail);
    
    if (!hdrAvail) {
    
        goto EXIT_POINT; /* nothing to do */
        
    }

    PRINT_DEBUG_MSG_LVL3("Received packet header");
    PRINT_DEBUG_MSG_NL3;

    /*
     * This is the first packet.  Should contain the string:
     * 'ext-mode'.  Its contents are not important to us.
     * It is used as a flag to start the handshaking process.
     */
    if (!commInitialized) {

        #if LCDUSE4ERRORS == 1
        writeLine("-> connecting   ", 1);
        #endif    

        #ifdef TXactiveControl
        
        /* any message header other than EXT_DATA_UPLD_NOACK_REQUEST causes the communication to be reinitialised  --  fw-07-07 */
        if(pktHdr.type != EXT_DATA_UPLD_NOACK_REQUEST) {

            PRINT_DEBUG_MSG_LVL3("Received first packet header (EXT_CONNECT)");
            PRINT_DEBUG_MSG_NL3;
            
            pktHdr.type = EXT_CONNECT;

        }
        
        #else
        
        PRINT_DEBUG_MSG_LVL3("Received first packet header (EXT_CONNECT)");
        PRINT_DEBUG_MSG_NL3;
        
        pktHdr.type = EXT_CONNECT;
        
        #endif

    }
    
    /* 
     * At this point we know that we have a packet: process it.
     */
     
    PRINT_DEBUG_MSG_LVL3((debugActionStrings[(uint_T)pktHdr.type]));
    PRINT_DEBUG_MSG_NL3;

    switch(pktHdr.type) {

        #ifdef TXactiveControl
        /* host driven flow control: log data  --  fw-07-07 */
        case EXT_DATA_UPLD_NOACK_REQUEST:

            PRINT_DEBUG_MSG_LVL2("Got EXT_DATA_UPLD_NOACK_REQUEST packet.");
            PRINT_DEBUG_MSG_NL2;
        
            // enable transmission (for one data telegram only)
            TXactive = TRUE;
            
            break;
        #endif

        /* host tries to break deadlock by sending an empty packet  --  fw-07-07 */
        case EXT_BREAK_DEADLOCK:
        
            //PRINT_DEBUG_MSG_LVL1("Got EXT_BREAK_DEADLOCK packet.\n");
            /* do nothing - the mere arrival of this packet should have broken the deadlock already... */
            break;

        case EXT_GET_TIME:
        {

            /* Skip verbosity print out - we get too many of these */
            /*PRINT_VERBOSE(("got EXT_GET_TIME packet.\n"));*/
            
            time_T  t = rteiGetT(ei);
            
                SWITCH_DYNAMIC_DBG_LVL(1);
                //PRINT_DEBUG_MSG_LVL1("Got EXT_GET_TIME packet.\n");
                
                error = SendPktToHost(EXT_GET_TIME_RESPONSE, sizeof(time_T), (char_T*)&t);
                
                if (error != EXT_NO_ERROR) {

                    //abort_LED(80);
                    goto EXIT_POINT;

                }
                
                break;
                
        }

        case EXT_ARM_TRIGGER:
        {
        
            //PRINT_DEBUG_MSG_LVL1("targetAction = EXT_ARM_TRIGGER");
            //PRINT_DEBUG_MSG_NL1;

            error = ProcessArmTriggerPkt((int_T)pktHdr.size, numSampTimes);
            
            if (error != EXT_NO_ERROR) {

                //abort_LED(81);
                goto EXIT_POINT;

            }

            //PRINT_DEBUG_MSG_LVL1("startModel = ");
            //PRINT_DEBUG_MSG_LVL1_UDec(startModel);
            //PRINT_DEBUG_MSG_NL1;

            #ifdef TXactiveControl
            /* enable log data upload  --  fw-07-07 */
            TXactive = TRUE;
            #endif

            break;
        }

        case EXT_SELECT_SIGNALS:
        {
        
            //PRINT_DEBUG_MSG_LVL1("targetAction = EXT_SELECT_SIGNALS");
            //PRINT_DEBUG_MSG_NL1;

            error = ProcessSelectSignalsPkt(ei, numSampTimes, (int_T)pktHdr.size);
            if (error != EXT_NO_ERROR) {

                //abort_LED(82);
                goto EXIT_POINT;

            }
            
            break;
        }

        case EXT_SELECT_TRIGGER: 
        {
        
            //PRINT_DEBUG_MSG_LVL1("targetAction = EXT_SELECT_TRIGGER");
            //PRINT_DEBUG_MSG_NL1;

            error = ProcessSelectTriggerPkt(ei, (int_T)pktHdr.size);
            if (error != EXT_NO_ERROR) {

                //abort_LED(83);
                goto EXIT_POINT;

            }
            
            break;
        }

        case EXT_CONNECT:
        {
        
            //PRINT_DEBUG_MSG_LVL1("targetAction = EXT_CONNECT");
            //PRINT_DEBUG_MSG_NL1;

            error = ProcessConnectPkt(ei);
            
            if (error != EXT_NO_ERROR) {

                //abort_LED(84);
                goto EXIT_POINT;

            }

            //PRINT_DEBUG_MSG_LVL1("startModel = ");
            //PRINT_DEBUG_MSG_LVL1_UDec(startModel);
            //PRINT_DEBUG_MSG_NL1;

            break;
        }

        case EXT_SETPARAM:
        {
        
            //PRINT_DEBUG_MSG_LVL1("targetAction = EXT_SETPARAM");
            //PRINT_DEBUG_MSG_NL1;

            error = ProcessSetParamPkt(ei, (int_T)pktHdr.size);
            
            if (error != EXT_NO_ERROR) {

                //abort_LED(85);
                goto EXIT_POINT;

            }
            
            //PRINT_DEBUG_MSG_LVL1("end of targetAction = EXT_SETPARAM");
            //PRINT_DEBUG_MSG_NL1;

            break;

        }

        case EXT_GETPARAMS:
        {
        
            //PRINT_DEBUG_MSG_LVL1("targetAction = EXT_GETPARAMS");
            //PRINT_DEBUG_MSG_NL1;

            error = ProcessGetParamsPkt(ei);
            
            if (error != EXT_NO_ERROR) {

                //abort_LED(86);
                goto EXIT_POINT;

            }

            break;

        }

        case EXT_DISCONNECT_REQUEST:
        {
        
            //PRINT_DEBUG_MSG_LVL1("targetAction = EXT_DISCONNECT_REQUEST");
            //PRINT_DEBUG_MSG_NL1;

            /*
             * Note that from the target's point of view this is
             * more a "notify" than a "request".  The host needs to
             * have this acknowledged before it can begin closing
             * the connection.
             */
            error = SendPktToHost(EXT_DISCONNECT_REQUEST_RESPONSE, 0, NULL);
            
            if (error != EXT_NO_ERROR) {

                //abort_LED(87);
                goto EXIT_POINT;

            }

            DisconnectFromHost(numSampTimes);

            #if LCDUSE4ERRORS == 1
            writeLine("-> not connected", 1);
            #endif

            //PRINT_DEBUG_MSG_LVL1("startModel = ");
            //PRINT_DEBUG_MSG_LVL1_UDec(startModel);
            //PRINT_DEBUG_MSG_NL1;

            break;
            
        }

        case EXT_DISCONNECT_REQUEST_NO_FINAL_UPLOAD:
        {
        
            //PRINT_DEBUG_MSG_LVL1("targetAction = EXT_DISCONNECT_REQUEST_NO_FINAL_UPLOAD");
            //PRINT_DEBUG_MSG_NL1;

            /*
             * The target receives this packet when the host is
             * immediately terminating the extmode communication due
             * to some error.  The target should not send back a
             * response or a final upload of data because the host is
             * expecting neither.  The target must be disconnected and
             * returned to a state where it is running and can be
             * re-connected to by the host.
             */
            ForceDisconnectFromHost(numSampTimes);

            #if LCDUSE4ERRORS == 1
            writeLine("-> not connected", 1);
            #endif
            
            //PRINT_DEBUG_MSG_LVL1("startModel = ");
            //PRINT_DEBUG_MSG_LVL1_UDec(startModel);
            //PRINT_DEBUG_MSG_NL1;

            break;

        }

        case EXT_MODEL_START:

            //PRINT_DEBUG_MSG_LVL1("targetAction = EXT_MODEL_START");
            //PRINT_DEBUG_MSG_NL1;

            #ifdef VXWORKS
            {
               extern SEM_ID  startStopSem;
               semGive(startStopSem);
            }
            #endif

            startModel = TRUE;
            error = SendPktToHost(EXT_MODEL_START_RESPONSE, 0, NULL);

            if (error != EXT_NO_ERROR) {

                //abort_LED(88);
                goto EXIT_POINT;

            }

            //PRINT_DEBUG_MSG_LVL1("startModel = ");
            //PRINT_DEBUG_MSG_LVL1_UDec(startModel);
            //PRINT_DEBUG_MSG_NL1;

            break;

        case EXT_MODEL_STOP:
        
            //PRINT_DEBUG_MSG_LVL1("targetAction = EXT_MODEL_STOP");
            //PRINT_DEBUG_MSG_NL1;

            *stopReq = TRUE;

            //PRINT_DEBUG_MSG_LVL1("startModel = ");
            //PRINT_DEBUG_MSG_LVL1_UDec(startModel);
            //PRINT_DEBUG_MSG_NL1;

            break;

        case EXT_MODEL_PAUSE:

            //PRINT_DEBUG_MSG_LVL1("targetAction = EXT_MODEL_PAUSE");
            //PRINT_DEBUG_MSG_NL1;

            modelStatus = TARGET_STATUS_PAUSED;
            startModel  = FALSE;

            error = SendPktToHost(EXT_MODEL_PAUSE_RESPONSE, 0, NULL);

            if (error != EXT_NO_ERROR) {

                //abort_LED(89);
                goto EXIT_POINT;

            }

            //PRINT_DEBUG_MSG_LVL1("modelStatus = ");
            //PRINT_DEBUG_MSG_LVL1_Raw(debugStatusStrings[modelStatus]);
            //PRINT_DEBUG_MSG_LVL1_Raw(", startModel = ");
            //PRINT_DEBUG_MSG_LVL1_UDec(startModel);
            //PRINT_DEBUG_MSG_NL1;

            break;

        case EXT_MODEL_STEP:

            //PRINT_DEBUG_MSG_LVL1("targetAction = EXT_MODEL_STEP");
            //PRINT_DEBUG_MSG_NL1;

            if ((modelStatus == TARGET_STATUS_PAUSED) && !startModel) {

                startModel = TRUE;

            }
            
            error = SendPktToHost(EXT_MODEL_STEP_RESPONSE, 0, NULL);

            if (error != EXT_NO_ERROR) {

                //abort_LED(90);
                goto EXIT_POINT;

            }

            //PRINT_DEBUG_MSG_LVL1("modelStatus = ");
            //PRINT_DEBUG_MSG_LVL1_Raw(debugStatusStrings[modelStatus]);
            //PRINT_DEBUG_MSG_LVL1_Raw(", startModel = ");
            //PRINT_DEBUG_MSG_LVL1_UDec(startModel);
            //PRINT_DEBUG_MSG_NL1;

            break;

        case EXT_MODEL_CONTINUE:

            //PRINT_DEBUG_MSG_LVL1("targetAction = EXT_MODEL_CONTINUE");
            //PRINT_DEBUG_MSG_NL1;

            if (modelStatus == TARGET_STATUS_PAUSED) {

                modelStatus = TARGET_STATUS_RUNNING;
                startModel  = FALSE;

            }
            
            error = SendPktToHost(EXT_MODEL_CONTINUE_RESPONSE, 0, NULL);

            if (error != EXT_NO_ERROR) {

                abort_LED(91);
                goto EXIT_POINT;

            }

            //PRINT_DEBUG_MSG_LVL1("modelStatus = ");
            //PRINT_DEBUG_MSG_LVL1_Raw(debugStatusStrings[modelStatus]);
            //PRINT_DEBUG_MSG_LVL1_Raw(", startModel = ");
            //PRINT_DEBUG_MSG_LVL1_UDec(startModel);
            //PRINT_DEBUG_MSG_NL1;

            break;

        case EXT_CANCEL_LOGGING:
        {

                //PRINT_DEBUG_MSG_LVL1("targetAction = EXT_CANCEL_LOGGING");
                //PRINT_DEBUG_MSG_NL1;

                error = ProcessCancelLoggingPkt((int_T)pktHdr.size);

                if (error != EXT_NO_ERROR) {

                    //abort_LED(92);
                    goto EXIT_POINT;

                }

                //PRINT_DEBUG_MSG_LVL1("startModel = ");
                //PRINT_DEBUG_MSG_LVL1_UDec(startModel);
                //PRINT_DEBUG_MSG_NL1;

                #ifdef TXactiveControl
                /* enable log data upload  --  fw-07-07 */
                TXactive = TRUE;
                #endif

            break;
            
        }

        default:
        
            abort_LED(93);
            //fprintf(stderr,"received invalid packet.\n");

            break;

    }  /* end switch */


EXIT_POINT:

    if (error != EXT_NO_ERROR) {

        if (disconnectOnError) {

            //fprintf(stderr,
            //    "Error occured in rt_PktServerWork.\n"
            //    "Disconnecting from host!\n");

            /* An error in this function which causes disconnectOnError to be
             * set to true is caused by a physical failure in the external mode
             * connection.  We assume this failure caused the host to disconnect.
             * The target must be disconnected and returned to a state
             * where it is running and can be re-connected to by the host.
             */
            ForceDisconnectFromHost(numSampTimes);

        }

    }

    PRINT_DEBUG_MSG_LVL3("OUT, error status: ");
    PRINT_DEBUG_MSG_LVL3_UDec(error);
    PRINT_DEBUG_MSG_NL3;

}  /* end rt_PktServerWork */


/* Function: rt_PktServer ======================================================
 * Abstract:
 *  Call rt_PktServerWork forever.   Used only for RTOS (e.g., Tornado/VxWorks
 *  when running as a low priority task.
 */
#ifdef VXWORKS
PUBLIC void rt_PktServer(RTWExtModeInfo *ei,
                         int_T          numSampTimes,
                         boolean_T      *stopReq)
{
    for(;;) {
        rt_PktServerWork(ei,numSampTimes,stopReq); 
    }
}
#endif


/* Function: rt_UploadServer ===================================================
 * Abstract:
 *  Call rt_UploadServerWork forever.   Used only for RTOS (e.g.,
 *  Tornado/VxWorks when running as a low priority task.
 */
#ifdef VXWORKS
PUBLIC void rt_UploadServer(int_T numSampTimes)
{
    for(;;) {
        rt_UploadServerWork(numSampTimes);
    }
} /* end rt_UploadServer */
#endif


/* Function: rt_SetPortInExtUD =================================================
 * Abstract:
 *  Set the port in the external mode user data structure.
 */
#ifdef VXWORKS
PUBLIC void rt_SetPortInExtUD(const int_T port)
{
    ExtUserDataSetPort(extUD, port);
} /* end rt_SetPortInExtUD */
#endif


/* Function: ExtModeShutdown ==================================================
 * Abstract:
 *  Called when target program terminates to enable cleanup of external 
 *  mode for a given upInfo.
 */
PRIVATE void ExtModeShutdown(int32_T upInfoIdx, int_T numSampTimes) {

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("ExtModeShutdown")

    /*
     * Make sure buffers are flushed so that the final points get to
     * host (this is important for the case of the target reaching tfinal
     * while data uploading is in progress).
     */
    UploadPrepareForFinalFlush(upInfoIdx);
   
    #ifdef TXactiveControl
    /* enable log data upload  --  fw-07-07 */
    TXactive = TRUE;
    #endif
    
    UploadServerWork(upInfoIdx, numSampTimes);

    UploadLogInfoTerm(upInfoIdx, numSampTimes);

    if(pktBuf!=NULL) {

        //PRINT_DEBUG_MSG_LVL1("Freeing memory of packet reception buffer");
        //PRINT_DEBUG_MSG_NL1;
        free(pktBuf);
        pktBuf = NULL;

        /* enable soft-reset of the micro (re-init ALL static vars to their reset values... fw-07-07 */
        pktBufSize = 0;

   }

}  /* end ExtModeShutdown */


/* Function: rt_ExtModeShutdown ================================================
 * Abstract:
 *  Called when target program terminates to enable cleanup of external 
 *  mode.
 */
PUBLIC boolean_T rt_ExtModeShutdown(int_T numSampTimes) {

int_T      i;
boolean_T  error = EXT_NO_ERROR;

    // local function name... debugging only
    DEFINE_DEBUG_FNAME("rt_ExtModeShutdown")

    for (i = 0; i < NUM_UPINFOS; i++) {
    
        ExtModeShutdown(i, numSampTimes);
        
    }

    if (commInitialized) {
    
        error = SendPktToHost(EXT_MODEL_SHUTDOWN, 0, NULL);
        
        if (error != EXT_NO_ERROR) {

            abort_LED(95);
            //fprintf(stderr,
            //    "\nError sending EXT_MODEL_SHUTDOWN packet to host.\n");

        }
        
        commInitialized = FALSE;
        
    }
    
    if (connected) {
    
        connected   = FALSE;
        modelStatus = TARGET_STATUS_WAITING_TO_START;        

        #if LCDUSE4ERRORS == 1
        writeLine("-> not connected", 1);
        #endif
          
        //PRINT_DEBUG_MSG_LVL1("connected = FALSE");
        //PRINT_DEBUG_MSG_NL1;
        //PRINT_DEBUG_MSG_LVL1("commInitialized = FALSE");
        //PRINT_DEBUG_MSG_NL1;
        //PRINT_DEBUG_MSG_LVL1("modelStatus = TARGET_STATUS_WAITING_TO_START");
        //PRINT_DEBUG_MSG_NL1;

   }

    ExtShutDown(extUD);
    ExtUserDataDestroy(extUD);
    
    rtExtModeTestingRemoveBatMarker();
    
    return error;
    
}  /* end rt_ExtModeShutdown */

/* Function: rt_UploadCheckTrigger =============================================
 * Abstract:
 *  Wrapper function that calls UploadCheckTrigger once for each upInfo
 */
PUBLIC void rt_UploadCheckTrigger(int_T numSampTimes) {

int_T  i;
    
    for (i = 0; i < NUM_UPINFOS; i++) {
    
        UploadCheckTrigger(i, numSampTimes);
        
    }
    
}  /* end rt_UploadCheckTrigger */


/* Function: rt_UploadCheckEndTrigger ==========================================
 * Abstract:
 *  Wrapper function that calls UploadCheckTrigger once for each upInfo
 */
PUBLIC void rt_UploadCheckEndTrigger(void) {

int_T  i;
    
    for (i = 0; i < NUM_UPINFOS; i++) {
    
        UploadCheckEndTrigger(i);
        
    }
    
}  /* end rt_UploadCheckEndTrigger */


/* Function: rt_UploadBufAddTimePoint ==========================================
 * Abstract:
 *  Wrapper function that calls UploadBufAddTimePoint once for each upInfo
 */
PUBLIC void rt_UploadBufAddTimePoint(int_T tid, real_T taskTime) {

int_T  i;

    #ifdef TXactiveControl
    /* only buffer data if the host is ready to receive data...   --  fw-07-07 */
    if(TXactive) {
    #endif
    
        for (i = 0; i < NUM_UPINFOS; i++) {
        
            UploadBufAddTimePoint(tid, taskTime, i);
            
        }

    #ifdef TXactiveControl
    }
    #endif

}  /* end rt_UploadBufAddTimePoint */

/* [EOF] ext_svr.c */