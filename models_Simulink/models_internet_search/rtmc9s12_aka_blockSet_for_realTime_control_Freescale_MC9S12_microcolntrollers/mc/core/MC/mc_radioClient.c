/**
 * Code to manage the client's radio transceiver.
 * See main.c for a simple example of a basic client application.
 *
 * Read README for further documentation.
 *
 * Use at own risk, etc. Feel free to modify and distribute.
 *
 * @author Stephen Craig, 07/08/2006
 */

/* Model dependent constants -- generated by 'gen_mc_defines_h.m' */
#include "mc_defines.h"

/* HAS_RFCOMMS:  '0' : no RF communications, '1' : server, '2' : client, '3' : 'both' */
#if ((HAS_RFCOMMS == 2) | (HAS_RFCOMMS == 3))

/* ensure that SPI support is enabled */
#ifndef HAS_SPI
#define HAS_SPI    1
#endif




#include "mc_radioClient.h"        /* various macros etc */
//#include "bsp_sci0.h"               /* support for SCI0 */
#include "mc_rb.h"                 /* ring buffer implementation */
#include "bsp_timer.h"             /* included for TIMER_PRESCALER */

/* define a macro to set the current module state */
#define setState(s) tickCounter = 0, moduleState = s

 /* RF baud rate macro.
    Include the macro for 1 MBits (may be necessary for large ranges)
    Remove macro for 2 MBits */
    
// #define SLOW_RF_BAUD_RATE 

#define CE              PTM_PTM7   /* chip enable */
#define CE_DDR          DDRM_DDRM7 /* chip enable data direction */

/* macro used to print out some debug info */
// #define TO_DEBUG
// #define TO_DEBUG_ERROR_CONDITIONS

#ifdef TO_DEBUG
  #define TO_DEBUG_ERROR_CONDITIONS
#endif

#ifdef TO_DEBUG

/* when debugging, make the whole thing run as slow as possible */
#define TICK_PRESCALAR              0xffff
#define WAIT_FOR_ACK_TICK_COUNT     17

#else
#ifdef SLOW_RF_BAUD_RATE 
/* For 1MBits, nominal time between T~ and ACK is given by
    128 + 5 + 128 + 5 + 2*(33 + 33 + 4*(5 + 2 + PAYLOAD_LEN)) = 710us */
  #define TICK_PRESCALAR   (24*712/TIMER_PRESCALER)

/* If every packet fails, then MAX_RT will occur in
    (250*1 + 8*(5+2+PAYLOAD_LEN) + 138.5)*16 = 12712us = 16 ticks
   Make it 17 to be conservative */
  #define WAIT_FOR_ACK_TICK_COUNT     (17)

#else
/* For 2MBits, nominal time between T~ and ACK is given by
    128 + 5 + 128 + 5 + 1*(33 + 33 + 4*(5 + 2 + PAYLOAD_LEN)) = 488us */
  #define TICK_PRESCALAR   (24*490/TIMER_PRESCALER)

/* If every packet fails, then MAX_RT will occur in
    (250*1 + 4*(5+2+PAYLOAD_LEN) + 138.5)*16 = 8712us = 18 ticks
    Make it 19 to be conservative */ 
  #define WAIT_FOR_ACK_TICK_COUNT     (19)
#endif
#endif

#define TIME_OUT_TICK_COUNT          (255)

#define TICK_REGISTER   TC0
#define TICK_ENABLE     TIE_C0I
#define TICK_INTERRUPT  TFLG1_C0F
// RadioClient_OnTick

/* a delay is required for the client to enter receive mode */
#define WAIT_FOR_SERVER_TICK_COUNT     1

#define ADDRESS_LENGTH       5  /* Address length (should be 5) */

/* define useful mnemonics */
/* these are all reads */
#define R_CONFIG          0x00     // Configuration Register
#define R_EN_AA           0x01     // Enable Auto Acknowledge
#define R_EN_RXADDR       0x02     // Enable RX Addresses
#define R_SETUP_AW        0x03     // Setup of Address Widths
#define R_SETUP_RETR      0x04     // Setup of Automatic Retransmission
#define R_RF_CH           0x05     // RF Channel
#define R_RF_SETUP        0x06     // RF Setup
#define R_STATUS          0x07     // Status
#define R_OBSERVE_TX      0x08     // Transmit Observe register
#define R_CD              0x09     // Carrier Detect
#define R_RX_ADDR_P0      0x0a     // Receive address data pipe 0
#define R_RX_ADDR_P1      0x0b     // Receive address data pipe 1
#define R_RX_ADDR_P2      0x0c     // Receive address data pipe 2
#define R_RX_ADDR_P3      0x0d     // Receive address data pipe 3
#define R_RX_ADDR_P4      0x0e     // Receive address data pipe 4
#define R_RX_ADDR_P5      0x0f     // Receive address data pipe 5
#define R_TX_ADDR         0x10     // Transmit address
#define R_RX_PW_0         0x11     // Number of bytes in RX payload for pipe 0
#define R_RX_PW_1         0x12     // Number of bytes in RX payload for pipe 1
#define R_RX_PW_2         0x13     // Number of bytes in RX payload for pipe 2
#define R_RX_PW_3         0x14     // Number of bytes in RX payload for pipe 3
#define R_RW_PW_4         0x15     // Number of bytes in RX payload for pipe 4
#define R_RW_PW_5         0x16     // Number of bytes in RX payload for pipe 5
#define R_FIFO_STATUS     0x17     // FIFO Status register

/* these are all writes */
#define W_CONFIG          0x20     // Configuration Register
#define W_EN_AA           0x21     // Enable Auto Acknowledge
#define W_EN_RXADDR       0x22     // Enable RX Addresses
#define W_SETUP_AW        0x23     // Setup of Address Widths
#define W_SETUP_RETR      0x24     // Setup of Automatic Retransmission
#define W_RF_CH           0x25     // RF Channel
#define W_RF_SETUP        0x26     // RF Setup
#define W_STATUS          0x27     // Status
#define W_OBSERVE_TX      0x28     // Transmit Observe register
#define W_RX_ADDR_P0      0x2a     // Receive address data pipe 0
#define W_RX_ADDR_P1      0x2b     // Receive address data pipe 1
#define W_RX_ADDR_P2      0x2c     // Receive address data pipe 2
#define W_RX_ADDR_P3      0x2d     // Receive address data pipe 3
#define W_RX_ADDR_P4      0x2e     // Receive address data pipe 4
#define W_RX_ADDR_P5      0x2f     // Receive address data pipe 5
#define W_TX_ADDR         0x30     // Transmit address
#define W_RX_PW_0         0x31     // Number of bytes in RX payload for pipe 0
#define W_RX_PW_1         0x32     // Number of bytes in RX payload for pipe 1
#define W_RX_PW_2         0x33     // Number of bytes in RX payload for pipe 2
#define W_RX_PW_3         0x34     // Number of bytes in RX payload for pipe 3
#define W_RX_PW_4         0x35     // Number of bytes in RX payload for pipe 4
#define W_RX_PW_5         0x36     // Number of bytes in RX payload for pipe 5

#define R_RX_PAYLOAD      0x61     // Read RX-payload
#define W_TX_PAYLOAD      0xa0     // Write TX-payload

#define FLUSH_TX          0xe1     // Flush transmit buffer
#define FLUSH_RX          0xe2     // Flush receive buffer
#define REUSE_TX_PL       0xe3     // Reuse last transmission
#define NOP               0xff     // No operation

/* Flags in STATUS */
#define RX_DR_MASK        0x40     /* Data Ready RX FIFO interrupt */
#define TX_DS_MASK        0x20     /* Data Sent TX FIFO interrupt */
#define MAX_RT_MASK       0x10     /* Max number of TX retries interrupt */
#define RX_P_NO_MASK      0x0e     /* Mask to retrieve the data pipe number */

#define RX_EMPTY_MASK     0x01     /* Flag in FIFO_STATUS register */

#define RF_CH_MASK        0x7f     /* To ensure 0 < rf_ch < 127 */

/* used to escape the characters matching the EOT token and ESCAPE */
#define RADIO_ESCAPE_CHAR           0xfe

/* end of transmission token */
#define RADIO_EOT_CHAR              0xfd

/* define states */
#define STATE_WAIT_FOR_EOT             0
#define STATE_WAIT_FOR_RECEIVE         1
#define STATE_WAIT_FOR_SERVER          2

/* First byte of every message is a header byte */

/* This flag is set if the client (or server) has been reset. */
#define HEADER_RESET_MASK           0x80
/* This flag is set if the client (or server) acknowledges reset. */
#define HEADER_ACK_RESET_MASK       0x40
/* This bit is set in the header byte if the header is to be
   interpretted as EOT */
#define HEADER_EOT_MASK             0x10

/* Last byte of client 0's address, etc 
   Must match the address specified in radioClient.c */
#define CLIENT_TAIL_0               0xc2
#define CLIENT_TAIL_1               0xc3
#define CLIENT_TAIL_2               0xc4
#define CLIENT_TAIL_3               0xc5
#define CLIENT_TAIL_4               0xc6

#define RB_TX_FULL(b) \
  ( ((tINT8U)((b)->out - (b)->in) <= PAYLOAD_LEN - 3) \
   && ((b)->in != (b)->out) \
  )

#define RB_TX_PUSH(b, v) \
    (RB_TX_FULL(b) ? 1 : \
     ((b)->start[(b)->in++] = (v), (b)->nElements++, 0) \
    )

typedef struct {
  /* the index of the state in the commStates array */
  tINT8U id;

  /* memory for outgoing data, has to be 256 bytes */
  tINT8U outBuf[256];

  /* memory for incoming data, has to be 256 bytes */
  tINT8U inBuf[256];

  /* declare pointers to rb data structures */
  rbType outRB;
  rbType inRB;

  /* store the last tID sent here */
  tINT8U lastTID;

  /* flags to store reset status */
  tINT8U reset;

  tINT16U failureCount;

} commStateType;

commStateType commState;
commStateType *cc = NULL;

/* store the current state */
tINT8U moduleState;

/* incremented every time there is a tick */
tINT8U tickCounter;

/* 
  Transmit() is a private procedure that is only called when the
  client is in possession of the EOT token.
*/
tVOID RadioClient_Transmit(tVOID) {
tINT8U i, haveSentEOT, header, data;
  
#ifdef TO_DEBUG
  SCI0_OutString("T\r\n"); /* enter Transmit */
#endif
  
  /* can only re-configure if in stand-by mode */
  CE = 0;

  /* a good idea to clear all interrupts and flush buffers first */
  SPI_OutChar(FLUSH_TX);
  SPI_OutChar(FLUSH_RX);
  
  /* clears all interrupts */
  SPI_OutChar2(W_STATUS, RX_DR_MASK | TX_DS_MASK | MAX_RT_MASK);

  /*
    bit  CONFIG Register
      7  0  Reserved
      6  1  MASK_RX_DR  : Don't reflect RX_DR on IRQ pin
      5  1  MASK_TX_DS  : Don't reflect TX_DS on IRQ pin
      4  1  MASK_MAX_RT : Don't reflect MAX_RT on IRQ pin
      3  1  EN_CRC      : Enable CRC
      2  1  CRCO        : 2 byte CRC
      1  1  PWR_UP      : Power Up
      0  0  PRIM_RX     : PTX
      
      Enter transmit mode
  */
  SPI_OutChar2(W_CONFIG, 0x7e);

  /* download the next segment */

  while(SPI0SR_SPTEF == 0) {}

  /* begin SPI segment */
  CSN = 0;

  /* output the write transmit buffer command */
  SPI0DR = W_TX_PAYLOAD;
  SPI_Pause();

  /* Determine what the header byte should be */
  header = cc->reset;
  
  if(header & HEADER_RESET_MASK) {
    /* if we've reset recently, make sure we start transmitting
       from the start of the transmit buffer */
    RB_SET_OUT(&cc->outRB, 0); 
    header |= HEADER_EOT_MASK;
  }

  /* determine whether we should send EOT in header byte */
  if(RB_EMPTY(&cc->outRB)) {
    header |= HEADER_EOT_MASK;
  }
  
  /* output the header byte */
  while(SPI0SR_SPTEF == 0) {}
  SPI0DR = header;
  SPI_Pause();

  /* work out if EOT was set in header */
  haveSentEOT = (header & HEADER_EOT_MASK) != 0;

  /* output the rID */
  while(SPI0SR_SPTEF == 0) {}
  SPI0DR = cc->inRB.in;
  SPI_Pause();

  /* output the tID */
  while(SPI0SR_SPTEF == 0) {}
  SPI0DR = cc->outRB.out;
  SPI_Pause();

  /* store what the last tID sent was */
  cc->lastTID = cc->outRB.out;
  
  /* fill the remaining 31 bytes */
  for(i=3; i<PAYLOAD_LEN; i++) {

    while(SPI0SR_SPTEF == 0) {}
  
      if(haveSentEOT == 0) {

        if(RB_EMPTY(&cc->outRB)) {
          /* if there's no more data to be sent, then EOT */

          SPI0DR = RADIO_EOT_CHAR;
          haveSentEOT = 1;

        } else {
        
          /* check what the next byte is to send */
          RB_PEEK(&cc->outRB, &data);

          if(data != RADIO_ESCAPE_CHAR
             && data != RADIO_EOT_CHAR) {

            /* the byte is not a special token, transmit it */
            RB_POP(&cc->outRB, &SPI0DR);
            
          } else {
            /* the data to be sent matches a special token, need to
               escape the data to be sent so it doesn't get
               misinterpretted */
            if(i == PAYLOAD_LEN - 1) {
              /* there's not enough space for the ESCAPE token and
                 the escaped char in this segment,
                 => EOT, send the character next time */
              SPI0DR = RADIO_EOT_CHAR;
              haveSentEOT = 1;
              
            } else {
              /* there is space for the ESCAPE token and the escaped
                 char */
              SPI0DR = RADIO_ESCAPE_CHAR;
              SPI_Pause();
              
              while(SPI0SR_SPTEF == 0) {}
              RB_POP(&cc->outRB, &SPI0DR);
              
              i++;
            }
          }
        }
      } else {
        /* we have sent EOT, but still need to fill tx_payload */
        /* fill the rest of the transmit buffer with \0 */
        SPI0DR = 0x00;
      }

    SPI_Pause();
  }
  
  /* end SPI packet */
  CSN = 1;

#ifdef TO_DEBUG  
  SCI0_OutString("T~\r\n"); /* exit Transmit() */
#endif

  // Pulse CE to start transmission (must be > 10us)
  CE = 1;
}

/* 
  EnterReceive is a private procedure to configure the module for
  receive mode.
  Must be in a standby-mode to call this method.
*/
tVOID RadioClient_EnterReceive(tVOID) {

  /* a good idea to clear all interrupts and flush buffers first */
  SPI_OutChar(FLUSH_TX);
  SPI_OutChar(FLUSH_RX);
  SPI_OutChar2(W_STATUS, RX_DR_MASK | TX_DS_MASK | MAX_RT_MASK);

  /*
    bit  CONFIG Register
      7  0  Reserved
      6  1  MASK_RX_DR  : Don't reflect RX_DR on IRQ pin
      5  1  MASK_TX_DS  : Don't reflect TX_DS on IRQ pin
      4  1  MASK_MAX_RT : Don't reflect MAX_RT on IRQ pin
      3  1  EN_CRC      : Enable CRC
      2  1  CRCO        : 2 byte CRC
      1  1  PWR_UP      : Power Up
      0  1  PRIM_RX     : PRX
      
      Enter receive mode
  */
  SPI_OutChar2(W_CONFIG, 0x7f);
 
  CE = 1;
}

/* 
  OnReceive() is a private procedure which is called when the
  RX_DR flag is set in the STATUS register.
  Returns 1 if have received EOT, otherwise returns 0
*/
tVOID RadioClient_OnReceive(tVOID) {
tINT8U header, rID, tID, in, i, toEscape, haveReceivedEOT, trustData;

#ifdef TO_DEBUG
  SCI0_OutString("R\r\n"); /* enter onReceive() */
#endif                                                            

  /* use in as a dummy */
  in = SPI0SR;
  in = SPI0DR;  // clear SPIF

  toEscape = haveReceivedEOT = 0;

  while(SPI0SR_SPTEF == 0) {}

  CSN = 0;
  
  /* send the read command */
  SPI0DR = R_RX_PAYLOAD;
  SPI_Pause();
  in = SPI_InChar(); // discard the status byte

  while(SPI0SR_SPTEF == 0) {}
  SPI0DR = NOP;      // output a dummy value to generate SCK
  SPI_Pause();

  /* read in header byte */
  header = SPI_InChar();

  while(SPI0SR_SPTEF == 0) {}
  SPI0DR = NOP;      // output a dummy value to generate SCK
  SPI_Pause();

  /* read in rID */
  rID = SPI_InChar();

  while(SPI0SR_SPTEF == 0) {}
  SPI0DR = NOP;      // output a dummy value to generate SCK
  SPI_Pause();

  /* read in tID */
  tID = SPI_InChar();

  if(tID == cc->inRB.in) {
    /* server's tID matches expected rID, i.e. the server's sending
       requested byte next, so can probably trust */
    trustData = 1;

  } else {

    /* the server is sending a byte out of order, probably cannot
       trust */
    trustData = 0;
    
#ifdef TO_DEBUG_ERROR_CONDITIONS
    SCI0_OutString("Invalid tID: ");
    SCI0_OutUDec(tID);
    SCI0_OutString(", expected ");
    SCI0_OutUDec(cc->inRB.in);
    SCI0_OutString("\r\n");
#endif
  }

  /* may be able to trust the data if the client has been reset
     recently */
  if(cc->reset & HEADER_RESET_MASK) {
    /* client has been reset recently */

    if(header & HEADER_ACK_RESET_MASK) {
      /* server has acknowledged client reset */
      cc->reset &= ~HEADER_RESET_MASK;
      
      /* what follows must be valid, since the server has ack'd
         reset */
      trustData = 1;

#ifdef TO_DEBUG
      SCI0_OutString("ACK'd reset\r\n");
#endif
    
    } else {

      /* server has not acknowledged reset, cannot trust data,
         even if had a "valid" tID */
      trustData = 0;

#ifdef TO_DEBUG_ERROR_CONDITIONS
      SCI0_OutString("Not ACK'd reset\r\n");
#endif
    }
  }
  
  /* if the server itself has been reset, we can trust the data */
  if(header & HEADER_RESET_MASK) {
    /* Server has been reset!
       This can be bad if there's still data in the buffer,
       may get data queued from another session => clean them */
    RadioClient_CleanOut();
    RadioClient_CleanIn();
  
    /* acknowledge to server that the reset has been a success */
    cc->reset |= HEADER_ACK_RESET_MASK;

    cc->failureCount = 0;

    /* what follows is a new byte (it's byte 0) */
    trustData = 1;
#ifdef TO_DEBUG
    SCI0_OutString("Server reset\r\n");
#endif
  } else {
    /* if server hasn't reset, clear ACK_RESET flag */
    cc->reset &= ~HEADER_ACK_RESET_MASK;
  }
  
#ifdef TO_DEBUG_ERROR_CONDITIONS
  if(!trustData) {
    SCI0_OutString("Discard data\r\n");
  }
#endif

  haveReceivedEOT = (header & HEADER_EOT_MASK) != 0;

  for(i=3; i<PAYLOAD_LEN; i++) {

    while(SPI0SR_SPTEF == 0) {}
    SPI0DR = NOP;      // output a dummy value to generate SCK
    SPI_Pause();

    in = SPI_InChar(); // read in potentially valid byte

    if(trustData && (haveReceivedEOT == 0)) {
      if(toEscape == 0) {    // last character in wasn't the ESCAPE char
        switch(in) {
        case RADIO_ESCAPE_CHAR:
          toEscape = 1;
          break;
          
        case RADIO_EOT_CHAR:
          /* have received EOT */
          haveReceivedEOT = 1;
          break;
          
        default:
          if(RB_PUSH(&cc->inRB, in)) {
#ifdef TO_DEBUG_ERROR_CONDITIONS
            SCI0_OutString("Dropped char: ");
            SCI0_OutUHex(in);
            SCI0_OutString("\r\n");
#endif
          }
          break;
        }
      } else {
        if(RB_PUSH(&cc->inRB, in)) {
#ifdef TO_DEBUG_ERROR_CONDITIONS
          SCI0_OutString("Dropped char: ");
          SCI0_OutUHex(in);
          SCI0_OutString("\r\n");
#endif
        }
        toEscape = 0;
      }
    }
  }
  
  CSN = 1;
  
#ifdef TO_DEBUG_ERROR_CONDITIONS
  if(cc->outRB.out != rID) {
    SCI0_OutString("Invalid rID: ");
    SCI0_OutUDec(rID);
    SCI0_OutString(", expected ");
    SCI0_OutUDec(cc->outRB.out);
    SCI0_OutString("\r\n");
  }
#endif

  RB_SET_OUT(&cc->outRB, rID);

    /* no more data in RX buffer */
#ifdef TO_DEBUG
  SCI0_OutString("R~"); /* exit onReceive() */
#endif
}

/*
  Setup timer.
*/
tVOID RadioClient_RestartTick() {
  TICK_ENABLE = 1;
  TICK_REGISTER = TICK_PRESCALAR + TCNT;
  TICK_INTERRUPT = 1;
}



/* beginning of the interrupt service routine =================================  */

/**
 * Called regularly.
 */

#define CPL_PRAGMA_ISR_START
#include "cpl_pragma.h"

CPL_INTERRUPT tVOID RadioClient_OnTick(tVOID) {

tINT8U status;

  /* first deal with the timer flags */
  TICK_ENABLE = 0;
  TICK_INTERRUPT = 1;

  /* re-enable all interrupts (to allow servicing of RxD interrupt) */
  asm cli                // re-enable interrupts to allow this one to be interrupted
  

  /* always increment the tick counter */
  tickCounter++;

#ifdef TO_DEBUG
  SCI0_OutChar('`'); /* tick */
#endif

  switch(moduleState) {
  
  case STATE_WAIT_FOR_EOT:

#ifdef TO_DEBUG
    SCI0_OutChar('@');
#endif

    /* read status (one byte long) */
    SPI_Read(R_STATUS, &status, 1);

    if(status & TX_DS_MASK) {
      
      /* successfully transmitted PAYLOAD_LEN bytes */
      
#ifdef TO_DEBUG
      SCI0_OutString("T'd\r\n"); /* successful transmit */
#endif

      /* clear interrupt */
      SPI_OutChar2(W_STATUS, TX_DS_MASK);

      /* Since EOT was transmitted, client is about to send,
         => enter RX */

      RadioClient_EnterReceive();

      setState(STATE_WAIT_FOR_RECEIVE);
      
    } else if(status & MAX_RT_MASK) {

      /* module has informed us there's been a timeout */

#ifdef TO_DEBUG_ERROR_CONDITIONS
      SCI0_OutString("F'd\r\n"); /* explicit timeout */
#endif

      /* clear interrupt */

      SPI_OutChar2(W_STATUS, MAX_RT_MASK);

      RB_SET_OUT(&cc->outRB, cc->lastTID);
      
      cc->failureCount++;

      RadioClient_EnterReceive();

      setState(STATE_WAIT_FOR_RECEIVE);

    } else if(tickCounter >= WAIT_FOR_ACK_TICK_COUNT) {

#ifdef TO_DEBUG_ERROR_CONDITIONS
      SCI0_OutString("Q'd\r\n"); /* implicit timeout */
#endif

      /* this is a very bizarre state to get into, treat it similarly
         to as though we had explicitly received a timeout */

      RB_SET_OUT(&cc->outRB, cc->lastTID);

      cc->failureCount++;

      RadioClient_EnterReceive();

      setState(STATE_WAIT_FOR_RECEIVE);
    }
    
    break;

  case STATE_WAIT_FOR_RECEIVE:


#ifdef TO_DEBUG
    SCI0_OutChar('r'); /* wait in receive */
#endif

    /* read status (one byte long) */
    SPI_Read(R_STATUS, &status, 1);

    if(status & RX_DR_MASK) {
#ifdef TO_DEBUG
      SCI0_OutString("R'd"); /* successful receive */
#endif

      /* to be pedantic, should ensure that the RX_P_NO matches
         the receive address pipe (1) */
      if((((status & RX_P_NO_MASK) >> 1) - 1) == cc->id) {
        RadioClient_OnReceive();
        setState(STATE_WAIT_FOR_SERVER);
      } else {
#ifdef TO_DEBUG_ERROR_CONDITIONS
        SCI0_OutString("Wrong pipe number!");
        SCI0_OutUHex((status & RX_P_NO_MASK) >> 1);
#endif
        RadioClient_EnterReceive();
        setState(STATE_WAIT_FOR_RECEIVE);

      }
    } else if(tickCounter >= TIME_OUT_TICK_COUNT) {

      /* client has timed out */
#ifdef TO_DEBUG_ERROR_CONDITIONS
      SCI0_OutString("Timeout");
#endif      

      RadioClient_EnterReceive();
      setState(STATE_WAIT_FOR_RECEIVE);
    }
    
    break;
  
  case STATE_WAIT_FOR_SERVER:

#ifdef TO_DEBUG
    SCI0_OutChar('S');
#endif

    /* server is now in receive mode */
    if(tickCounter >= WAIT_FOR_SERVER_TICK_COUNT) {
      RadioClient_Transmit();
      setState(STATE_WAIT_FOR_EOT);
    }
    break;
  }
 
  /* restart the timer */
  RadioClient_RestartTick();
  
}

#define CPL_PRAGMA_ISR_STOP
#include "cpl_pragma.h"

/* end of the interrupt service routine =================================  */



tINT8U RadioClient_Init(tINT8U baudRate,
                               tINT8U rfChannel,
                               unsigned long serverAddressHeader,
                               unsigned long clientAddressHeader,
                               tINT8U client) {

/* declare space for rx and tx addresses */
tINT8U rx1_address_array[ADDRESS_LENGTH];
tINT8U tx_address_array[ADDRESS_LENGTH];

// space to test the first the receive address was correctly written
tINT8U test[ADDRESS_LENGTH];

  /* configure CE pin as an output */
  CE_DDR = 1;

  /* Enter Standby-I Mode */
  CE = 0;

  /* initialise the SPI */
  SPI_Init(baudRate);
  
  /* Select the first flagged client as the current client, and 
     simultaneously check for the no client flag set error.
     If a client's flag is not set, it will not be polled. */
  if(client == CLIENT_FLAG_0) {
    rx1_address_array[0] = tx_address_array[0] = CLIENT_TAIL_0;
  } else if(client == CLIENT_FLAG_1) {
    rx1_address_array[0] = tx_address_array[0] = CLIENT_TAIL_1;
  } else if(client == CLIENT_FLAG_2) {
    rx1_address_array[0] = tx_address_array[0] = CLIENT_TAIL_2;
  } else if(client == CLIENT_FLAG_3) {
    rx1_address_array[0] = tx_address_array[0] = CLIENT_TAIL_3;
  } else if(client == CLIENT_FLAG_4) {
    rx1_address_array[0] = tx_address_array[0] = CLIENT_TAIL_4;
  } else {
     // no clients are active, return error
     return INIT_ERROR_NO_CLIENT_SET;
  }

  /* set the first four bytes of the receive address of pipe 1
     as serverAddress */
  rx1_address_array[1] = clientAddressHeader & 0xff;
  rx1_address_array[2] = (clientAddressHeader >> 8) & 0xff;
  rx1_address_array[3] = (clientAddressHeader >> 16) & 0xff;
  rx1_address_array[4] = (clientAddressHeader >> 24) & 0xff;
  
  /* set the first four of the client transmit bytes */
  tx_address_array[1] = serverAddressHeader & 0xff;
  tx_address_array[2] = (serverAddressHeader >> 8) & 0xff;
  tx_address_array[3] = (serverAddressHeader >> 16) & 0xff;
  tx_address_array[4] = (serverAddressHeader >> 24) & 0xff;

  cc = &commState;

  cc->id = 0;

  /* init the transmit ring buffers */
  RB_INIT(&cc->outRB, cc->outBuf);

  /* init the receive ring buffers */
  RB_INIT(&cc->inRB, cc->inBuf);
  
  /* lastTID is 0x00 */
  cc->lastTID = 0x00;
  
  /* notify clients that the server has been reset */
  cc->reset = HEADER_RESET_MASK;
  
  /* seems to be required? May be an artifact of original buggy SPI code... */
  SPI_OutChar(NOP);

  /*
    bit  EN_AA Register
    7:6  00 Reserved    : Must be zero
      5   1             : Enable auto-ACK on data pipe 5
      4   1             : Enable auto-ACK on data pipe 4
      3   1             : Enable auto-ACK on data pipe 3
      2   1             : Enable auto-ACK on data pipe 2
      1   1             : Enable auto-ACK on data pipe 1
      0   1             : Enable auto-ACK on data pipe 0
     */
  SPI_OutChar2(W_EN_AA, 0x3f);

  /*
    bit  EN_RXADDR Register
    7:6  0  Reserved    : Must be zero
      5  0  ERX_P5      : Disable
      4  0  ERX_P4      : Disable
      3  0  ERX_P3      : Disable
      2  0  ERX_P2      : Disable
      1  1  ERX_P1      : Enable server
      0  1  ERX_P0      : Reserved for ACKs
  */
  SPI_OutChar2(W_EN_RXADDR, 0x03);
  
  /*
    bit  SETUP_AW Register
    7:2  0  Reserved    : Must be zero
    1:0  11 AW          : RX/TA Address field width = 5
  */
  SPI_OutChar2(W_SETUP_AW, 0x03);

  /*
    bit  SETUP_RETR Register
    7:4  01  ARD (Auto re-transmit delay)
    3:1  15  ARC (Auto re-transmit count)
  */
  SPI_OutChar2(W_SETUP_RETR, 0x0f);
  
  /*
    Set the RF_CH, which RF channel to receive/transmit on
  */
  SPI_OutChar2(W_RF_CH, (rfChannel & RF_CH_MASK));

  /*
    bit  RF_SETUP Register
    7:5  0  Reserved
      4  0  PLL_LOCK    : Use Default
      3  X  RF_DR       : RF baud rate, depends on RF_BAUD_RATE
    2:1  11 RF_PWR      : 0dBm output power in TX mode (max)
      0  1  LNA_HCURR   : Setup LNA gain
  */
  
#ifdef SLOW_RF_BAUD_RATE

  SPI_OutChar2(W_RF_SETUP, 0x07);

#else // FAST_RF_BAUD_RATE

  SPI_OutChar2(W_RF_SETUP, 0x0f);

#endif  

  /*
    RX_ADDR_P0 Register
    Receive address for current client (for ACK).
  */
  SPI_OutChar3(W_RX_ADDR_P0, tx_address_array, ADDRESS_LENGTH);

  /*
    RX_ADDR_P1 Register
    Receive address for client 0.
  */
  SPI_OutChar3(W_RX_ADDR_P1, rx1_address_array, ADDRESS_LENGTH);

  /*
    Perform a simple read to make sure that memory is being
    correctly written.
  */
  SPI_Read(R_RX_ADDR_P1, test, ADDRESS_LENGTH);

  /*
    Will return NO_POWER if the read RX1 address does not match
    the address written, meaning that there's no power to the
    module.
  */
  if(test[0] != rx1_address_array[0]
  || test[1] != rx1_address_array[1]
  || test[2] != rx1_address_array[2]
  || test[3] != rx1_address_array[3]
  || test[4] != rx1_address_array[4]) {
    return INIT_ERROR_NO_POWER;
  }

  /*
    TX_ADDR Register
    Transmit address for current client.
  */
  SPI_OutChar3(W_TX_ADDR, tx_address_array, ADDRESS_LENGTH);

  /*
    RW_PW_0 Register
    Set the width of data pipe 0 (Reserved for ACKs)
  */
  SPI_OutChar2(W_RX_PW_0, 0);

  /*
    RW_PW_1 Register
    Set the width of the RX payload on pipe 1
  */
  SPI_OutChar2(W_RX_PW_1, PAYLOAD_LEN);
  
  /* clear all previous interrupts */
  SPI_OutChar2(W_STATUS, 0x70);

  /* flush buffers */
  SPI_OutChar(FLUSH_TX);
  SPI_OutChar(FLUSH_RX);

  /* start in receive mode */
  RadioClient_EnterReceive();
  setState(STATE_WAIT_FOR_RECEIVE);

  /* start the ticker */
  RadioClient_RestartTick();

  return INIT_NO_ERROR;
}

/*
  Diagnostic to check for carriers (jammed signal). Infinite loop.
  Cycle through all 128 channels. If Carrier is detected on a channel,
  increment its corresponding element in the carrier_detect array.
  See radioClient.h for more info.
*/
tVOID RadioClient_CheckCarrier(tVOID) {
tINT8U i,j,k,cd;
tINT16U carrier_detect[128];

  while(1) {
    for(i = 127; i != 0; i++) {

      CE = 0;

      /*
        bit  CONFIG Register
          7  0  Reserved
          6  1  MASK_RX_DR  : Don't reflect RX_DR on IRQ pin
          5  1  MASK_TX_DS  : Don't reflect TX_DS on IRQ pin
          4  1  MASK_MAX_RT : Don't reflect MAX_RT on IRQ pin
          3  1  EN_CRC      : Enable CRC
          2  1  CRCO        : 2 byte CRC
          1  1  PWR_UP      : Power Up
          0  1  PRIM_RX     : PRX
          
          Enter receive mode
      */
      SPI_OutChar2(W_CONFIG, 0x7f);
      
      /* select a new RF channel */
      SPI_OutChar2(W_RF_CH, i);
      
      CE = 1;
      
      for(j=255; j!=0; j--) {
        for(k=255; k!=0; k--) {
          /* Specification seems to imply 258us delay is required here.
             This will delay for quite a bit longer than that. */
        }
      }

      /* read the one byte long CD register */
      SPI_Read(R_CD, &cd, 1);
      
      /* if carrier is detected, increment carrier_detect[i] */
      if(cd) {
        /* protect against overflow */
        if(carrier_detect[i] != 0xffff) {
          carrier_detect[i]++; 
        }
      }
    }
    
    /*
      Each time all channels have been tested, output the results to date.
      The longer this is left to run, a better average of the results should
      be obtained.
     */
      
#if (DEBUG_MSG_LVL > 0)
    for(i = 127; i != 0; i--) {
      SCI0_OutUDec(i);
      SCI0_OutString(", ");
      SCI0_OutUDec(carrier_detect[i]);
      SCI0_OutChar(CR);
      SCI0_OutChar(LF); 
    }
#endif /* DEBUG_MSG_LVL */
  }
}

tINT8U RadioClient_OutChar(tINT8U val) {
  return RB_TX_PUSH(&cc->outRB, val);
}

tVOID RadioClient_OutCharArray(tINT8U *pt,
                              tINT8U len) {
tINT8U i;
  for(i=0; i<len; i++) {
    while(RadioClient_OutChar(pt[i]));
  }
}

tVOID RadioClient_OutString(tINT8U *pt) {
  while(*pt) {
    while(RadioClient_OutChar(*pt++));
    while(RadioClient_OutChar(0x00));
  }
}

tINT8U RadioClient_IsOutFull(tVOID) {
  return RB_TX_FULL(&cc->outRB);
}

tINT8U RadioClient_IsOutEmpty(tVOID) {
  return RB_EMPTY(&cc->outRB);
}

tINT8U RadioClient_IsInFull(tVOID) {
  return RB_FULL(&cc->inRB);
}

tINT8U RadioClient_IsInEmpty(tVOID) {
  return RB_EMPTY(&cc->inRB);
}

tINT8U RadioClient_HasElements(tVOID) {
  return RB_ELEMENTS(&cc->inRB);
}

tVOID RadioClient_CleanIn(tVOID) {
  RB_CLEAN(&cc->inRB);
}

tVOID RadioClient_CleanOut(tVOID) {
  RB_CLEAN(&cc->outRB);
}

tINT8U RadioClient_InChar(tVOID) {
tINT8U toReturn;
  while(RB_POP(&cc->inRB, &toReturn));
  return toReturn;
}

tVOID RadioClient_InCharArray(tINT8U *charArray,
                             tINT8U len) {
tINT8U i;
  for(i = 0; i<len; i++) {
    while(RB_POP(&cc->inRB, &charArray[i]));
  }
}

tINT16U RadioClient_GetFailureCount(tVOID) {
  return commState.failureCount;
}

#endif /* HAS_COMMS */
